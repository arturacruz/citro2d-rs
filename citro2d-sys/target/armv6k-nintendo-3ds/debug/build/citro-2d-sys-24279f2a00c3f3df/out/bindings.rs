/* automatically generated by rust-bindgen 0.71.1 */

use ctru_sys::*;
use libc::FILE;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const M_TAU: f64 = 6.283185307179586;
pub const C3D_AspectRatioTop: f64 = 1.6666666666666667;
pub const C3D_AspectRatioBot: f64 = 1.3333333333333333;
pub const C3D_MTXSTACK_SIZE: u8 = 8;
pub const C3D_FVUNIF_COUNT: u8 = 96;
pub const C3D_IVUNIF_COUNT: u8 = 4;
pub const C3D_DEFAULT_CMDBUF_SIZE: u32 = 262144;
pub const C3DF_LightEnv_IsCP_Any: u32 = 66846720;
pub const C3DF_LightEnv_LutDirtyAll: u32 = 4227858432;
pub const C2D_DEFAULT_MAX_OBJECTS: u16 = 4096;
pub type __int64_t = ::libc::c_longlong;
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type wint_t = ::libc::c_int;
pub type C3D_IVec = u32_;
unsafe extern "C" {
    #[link_name = "IVec_Pack__extern"]
    pub fn IVec_Pack(x: u8_, y: u8_, z: u8_, w: u8_) -> C3D_IVec;
}
#[doc = "C3D_FVec\n Float vector\n\n Matches PICA layout"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_FVec {
    pub __bindgen_anon_1: C3D_FVec__bindgen_ty_1,
    pub __bindgen_anon_2: C3D_FVec__bindgen_ty_2,
    #[doc = "Raw access"]
    pub c: [f32; 4usize],
}
#[doc = "Vector access"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FVec__bindgen_ty_1 {
    #[doc = "< W-component"]
    pub w: f32,
    #[doc = "< Z-component"]
    pub z: f32,
    #[doc = "< Y-component"]
    pub y: f32,
    #[doc = "< X-component"]
    pub x: f32,
}
#[doc = "Quaternion access"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FVec__bindgen_ty_2 {
    #[doc = "< Real component"]
    pub r: f32,
    #[doc = "< K-component"]
    pub k: f32,
    #[doc = "< J-component"]
    pub j: f32,
    #[doc = "< I-component"]
    pub i: f32,
}
#[doc = "C3D_FQuat\n Float quaternion. See C3D_FVec."]
pub type C3D_FQuat = C3D_FVec;
#[doc = "C3D_Mtx\n Row-major 4x4 matrix"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Mtx {
    #[doc = "< Rows are vectors"]
    pub r: [C3D_FVec; 4usize],
    #[doc = "< Raw access"]
    pub m: [f32; 16usize],
}
unsafe extern "C" {
    #[doc = "Create a new FVec4\n # Arguments\n\n* `x` (direction in) - X-component\n * `y` (direction in) - Y-component\n * `z` (direction in) - Z-component\n * `w` (direction in) - W-component\n # Returns\n\nNew FVec4"]
    #[link_name = "FVec4_New__extern"]
    pub fn FVec4_New(x: f32, y: f32, z: f32, w: f32) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Add two FVec4s\n # Arguments\n\n* `lhs` (direction in) - Augend\n * `rhs` (direction in) - Addend\n # Returns\n\nlhs+rhs (sum)"]
    #[link_name = "FVec4_Add__extern"]
    pub fn FVec4_Add(lhs: C3D_FVec, rhs: C3D_FVec) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Subtract two FVec4s\n # Arguments\n\n* `lhs` (direction in) - Minuend\n * `rhs` (direction in) - Subtrahend\n # Returns\n\nlhs-rhs (difference)"]
    #[link_name = "FVec4_Subtract__extern"]
    pub fn FVec4_Subtract(lhs: C3D_FVec, rhs: C3D_FVec) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Negate a FVec4\n > **Note:** This is equivalent to `FVec4_Scale(v, -1)`\n # Arguments\n\n* `v` (direction in) - Vector to negate\n # Returns\n\n-v"]
    #[link_name = "FVec4_Negate__extern"]
    pub fn FVec4_Negate(v: C3D_FVec) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Scale a FVec4\n # Arguments\n\n* `v` (direction in) - Vector to scale\n * `s` (direction in) - Scale factor\n # Returns\n\nv*s"]
    #[link_name = "FVec4_Scale__extern"]
    pub fn FVec4_Scale(v: C3D_FVec, s: f32) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Perspective divide\n # Arguments\n\n* `v` (direction in) - Vector to divide\n # Returns\n\nv/v.w"]
    #[link_name = "FVec4_PerspDivide__extern"]
    pub fn FVec4_PerspDivide(v: C3D_FVec) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Dot product of two FVec4s\n # Arguments\n\n* `lhs` (direction in) - Left-side FVec4\n * `rhs` (direction in) - Right-side FVec4\n # Returns\n\nlhs∙rhs"]
    #[link_name = "FVec4_Dot__extern"]
    pub fn FVec4_Dot(lhs: C3D_FVec, rhs: C3D_FVec) -> f32;
}
unsafe extern "C" {
    #[doc = "Magnitude of a FVec4\n # Arguments\n\n* `v` (direction in) - Vector\n # Returns\n\n‖v‖"]
    #[link_name = "FVec4_Magnitude__extern"]
    pub fn FVec4_Magnitude(v: C3D_FVec) -> f32;
}
unsafe extern "C" {
    #[doc = "Normalize a FVec4\n # Arguments\n\n* `v` (direction in) - FVec4 to normalize\n # Returns\n\nv/‖v‖"]
    #[link_name = "FVec4_Normalize__extern"]
    pub fn FVec4_Normalize(v: C3D_FVec) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Create a new FVec3\n # Arguments\n\n* `x` (direction in) - X-component\n * `y` (direction in) - Y-component\n * `z` (direction in) - Z-component\n # Returns\n\nNew FVec3"]
    #[link_name = "FVec3_New__extern"]
    pub fn FVec3_New(x: f32, y: f32, z: f32) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Dot product of two FVec3s\n # Arguments\n\n* `lhs` (direction in) - Left-side FVec3\n * `rhs` (direction in) - Right-side FVec3\n # Returns\n\nlhs∙rhs"]
    #[link_name = "FVec3_Dot__extern"]
    pub fn FVec3_Dot(lhs: C3D_FVec, rhs: C3D_FVec) -> f32;
}
unsafe extern "C" {
    #[doc = "Magnitude of a FVec3\n # Arguments\n\n* `v` (direction in) - Vector\n # Returns\n\n‖v‖"]
    #[link_name = "FVec3_Magnitude__extern"]
    pub fn FVec3_Magnitude(v: C3D_FVec) -> f32;
}
unsafe extern "C" {
    #[doc = "Normalize a FVec3\n # Arguments\n\n* `v` (direction in) - FVec3 to normalize\n # Returns\n\nv/‖v‖"]
    #[link_name = "FVec3_Normalize__extern"]
    pub fn FVec3_Normalize(v: C3D_FVec) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Add two FVec3s\n # Arguments\n\n* `lhs` (direction in) - Augend\n * `rhs` (direction in) - Addend\n # Returns\n\nlhs+rhs (sum)"]
    #[link_name = "FVec3_Add__extern"]
    pub fn FVec3_Add(lhs: C3D_FVec, rhs: C3D_FVec) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Subtract two FVec3s\n # Arguments\n\n* `lhs` (direction in) - Minuend\n * `rhs` (direction in) - Subtrahend\n # Returns\n\nlhs-rhs (difference)"]
    #[link_name = "FVec3_Subtract__extern"]
    pub fn FVec3_Subtract(lhs: C3D_FVec, rhs: C3D_FVec) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Distance between two 3D points\n # Arguments\n\n* `lhs` (direction in) - Relative origin\n * `rhs` (direction in) - Relative point of interest\n # Returns\n\n‖lhs-rhs‖"]
    #[link_name = "FVec3_Distance__extern"]
    pub fn FVec3_Distance(lhs: C3D_FVec, rhs: C3D_FVec) -> f32;
}
unsafe extern "C" {
    #[doc = "Scale a FVec3\n # Arguments\n\n* `v` (direction in) - Vector to scale\n * `s` (direction in) - Scale factor\n # Returns\n\nv*s"]
    #[link_name = "FVec3_Scale__extern"]
    pub fn FVec3_Scale(v: C3D_FVec, s: f32) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Negate a FVec3\n > **Note:** This is equivalent to `FVec3_Scale(v, -1)`\n # Arguments\n\n* `v` (direction in) - Vector to negate\n # Returns\n\n-v"]
    #[link_name = "FVec3_Negate__extern"]
    pub fn FVec3_Negate(v: C3D_FVec) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Cross product of two FVec3s\n > **Note:** This returns a pseudo-vector which is perpendicular to the plane\n spanned by the two input vectors.\n # Arguments\n\n* `lhs` (direction in) - Left-side FVec3\n * `rhs` (direction in) - Right-side FVec3\n # Returns\n\nlhs×rhs"]
    #[link_name = "FVec3_Cross__extern"]
    pub fn FVec3_Cross(lhs: C3D_FVec, rhs: C3D_FVec) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Zero matrix\n # Arguments\n\n* `out` (direction out) - Matrix to zero"]
    #[link_name = "Mtx_Zeros__extern"]
    pub fn Mtx_Zeros(out: *mut C3D_Mtx);
}
unsafe extern "C" {
    #[doc = "Copy a matrix\n # Arguments\n\n* `out` (direction out) - Output matrix\n * `in` (direction in) - Input matrix"]
    #[link_name = "Mtx_Copy__extern"]
    pub fn Mtx_Copy(out: *mut C3D_Mtx, in_: *const C3D_Mtx);
}
unsafe extern "C" {
    #[doc = "Creates a matrix with the diagonal using the given parameters.\n # Arguments\n\n* `out` (direction out) - Output matrix.\n * `x` (direction in) - The X component.\n * `y` (direction in) - The Y component.\n * `z` (direction in) - The Z component.\n * `w` (direction in) - The W component."]
    #[link_name = "Mtx_Diagonal__extern"]
    pub fn Mtx_Diagonal(out: *mut C3D_Mtx, x: f32, y: f32, z: f32, w: f32);
}
unsafe extern "C" {
    #[doc = "Identity matrix\n # Arguments\n\n* `out` (direction out) - Matrix to fill"]
    #[link_name = "Mtx_Identity__extern"]
    pub fn Mtx_Identity(out: *mut C3D_Mtx);
}
unsafe extern "C" {
    #[doc = "Transposes the matrix. Row => Column, and vice versa.\n# Arguments\n\n* `out` (direction in, out) - Output matrix."]
    pub fn Mtx_Transpose(out: *mut C3D_Mtx);
}
unsafe extern "C" {
    #[doc = "Matrix addition\n # Arguments\n\n* `out` (direction out) - Output matrix.\n * `lhs` (direction in) - Left matrix.\n * `rhs` (direction in) - Right matrix.\n # Returns\n\nlhs+rhs (sum)"]
    #[link_name = "Mtx_Add__extern"]
    pub fn Mtx_Add(out: *mut C3D_Mtx, lhs: *const C3D_Mtx, rhs: *const C3D_Mtx);
}
unsafe extern "C" {
    #[doc = "Matrix subtraction\n # Arguments\n\n* `out` (direction out) - Output matrix.\n * `lhs` (direction in) - Left matrix.\n * `rhs` (direction in) - Right matrix.\n # Returns\n\nlhs-rhs (difference)"]
    #[link_name = "Mtx_Subtract__extern"]
    pub fn Mtx_Subtract(out: *mut C3D_Mtx, lhs: *const C3D_Mtx, rhs: *const C3D_Mtx);
}
unsafe extern "C" {
    #[doc = "Multiply two matrices\n # Arguments\n\n* `out` (direction out) - Output matrix\n * `a` (direction in) - Multiplicand\n * `b` (direction in) - Multiplier"]
    pub fn Mtx_Multiply(out: *mut C3D_Mtx, a: *const C3D_Mtx, b: *const C3D_Mtx);
}
unsafe extern "C" {
    #[doc = "Inverse a matrix\n # Arguments\n\n* `out` (direction in, out) - Matrix to inverse\n # Returns\n\n* `0.0f` - Degenerate matrix (no inverse)\n determinant"]
    pub fn Mtx_Inverse(out: *mut C3D_Mtx) -> f32;
}
unsafe extern "C" {
    #[doc = "Multiply 3x3 matrix by a FVec3\n # Arguments\n\n* `mtx` (direction in) - Matrix\n * `v` (direction in) - Vector\n # Returns\n\nmtx*v (product)"]
    pub fn Mtx_MultiplyFVec3(mtx: *const C3D_Mtx, v: C3D_FVec) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Multiply 4x4 matrix by a FVec4\n # Arguments\n\n* `mtx` (direction in) - Matrix\n * `v` (direction in) - Vector\n # Returns\n\nmtx*v (product)"]
    pub fn Mtx_MultiplyFVec4(mtx: *const C3D_Mtx, v: C3D_FVec) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Multiply 4x3 matrix by a FVec3\n # Arguments\n\n* `mtx` (direction in) - Matrix\n * `v` (direction in) - Vector\n # Returns\n\nmtx*v (product)"]
    #[link_name = "Mtx_MultiplyFVecH__extern"]
    pub fn Mtx_MultiplyFVecH(mtx: *const C3D_Mtx, v: C3D_FVec) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Get 4x4 matrix equivalent to Quaternion\n # Arguments\n\n* `m` (direction out) - Output matrix\n * `q` (direction in) - Input Quaternion"]
    pub fn Mtx_FromQuat(m: *mut C3D_Mtx, q: C3D_FQuat);
}
unsafe extern "C" {
    #[doc = "3D translation\n # Arguments\n\n* `mtx` (direction in, out) - Matrix to translate\n * `x` (direction in) - X component to translate\n * `y` (direction in) - Y component to translate\n * `z` (direction in) - Z component to translate\n * `bRightSide` (direction in) - Whether to transform from the right side"]
    pub fn Mtx_Translate(mtx: *mut C3D_Mtx, x: f32, y: f32, z: f32, bRightSide: bool);
}
unsafe extern "C" {
    #[doc = "3D Scale\n # Arguments\n\n* `mtx` (direction in, out) - Matrix to scale\n * `x` (direction in) - X component to scale\n * `y` (direction in) - Y component to scale\n * `z` (direction in) - Z component to scale"]
    pub fn Mtx_Scale(mtx: *mut C3D_Mtx, x: f32, y: f32, z: f32);
}
unsafe extern "C" {
    #[doc = "3D Rotation\n # Arguments\n\n* `mtx` (direction in, out) - Matrix to rotate\n * `axis` (direction in) - Axis about which to rotate\n * `angle` (direction in) - Radians to rotate\n * `bRightSide` (direction in) - Whether to transform from the right side"]
    pub fn Mtx_Rotate(mtx: *mut C3D_Mtx, axis: C3D_FVec, angle: f32, bRightSide: bool);
}
unsafe extern "C" {
    #[doc = "3D Rotation about the X axis\n # Arguments\n\n* `mtx` (direction in, out) - Matrix to rotate\n * `angle` (direction in) - Radians to rotate\n * `bRightSide` (direction in) - Whether to transform from the right side"]
    pub fn Mtx_RotateX(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
unsafe extern "C" {
    #[doc = "3D Rotation about the Y axis\n # Arguments\n\n* `mtx` (direction in, out) - Matrix to rotate\n * `angle` (direction in) - Radians to rotate\n * `bRightSide` (direction in) - Whether to transform from the right side"]
    pub fn Mtx_RotateY(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
unsafe extern "C" {
    #[doc = "3D Rotation about the Z axis\n # Arguments\n\n* `mtx` (direction in, out) - Matrix to rotate\n * `angle` (direction in) - Radians to rotate\n * `bRightSide` (direction in) - Whether to transform from the right side"]
    pub fn Mtx_RotateZ(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
unsafe extern "C" {
    #[doc = "Orthogonal projection\n # Arguments\n\n* `mtx` (direction out) - Output matrix\n * `left` (direction in) - Left clip plane (X=left)\n * `right` (direction in) - Right clip plane (X=right)\n * `bottom` (direction in) - Bottom clip plane (Y=bottom)\n * `top` (direction in) - Top clip plane (Y=top)\n * `near` (direction in) - Near clip plane (Z=near)\n * `far` (direction in) - Far clip plane (Z=far)\n * `isLeftHanded` (direction in) - Whether to build a LH projection\n [`Mtx_OrthoTilt`]"]
    pub fn Mtx_Ortho(
        mtx: *mut C3D_Mtx,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
unsafe extern "C" {
    #[doc = "Perspective projection\n # Arguments\n\n* `mtx` (direction out) - Output matrix\n * `fovy` (direction in) - Vertical field of view in radians\n * `aspect` (direction in) - Aspect ration of projection plane (width/height)\n * `near` (direction in) - Near clip plane (Z=near)\n * `far` (direction in) - Far clip plane (Z=far)\n * `isLeftHanded` (direction in) - Whether to build a LH projection\n [`Mtx_PerspTilt`]\n [`Mtx_PerspStereo`]\n [`Mtx_PerspStereoTilt`]"]
    pub fn Mtx_Persp(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
unsafe extern "C" {
    #[doc = "Stereo perspective projection\n > **Note:** Typically you will use iod to mean the distance between the eyes. Plug\n in -iod for the left eye and iod for the right eye.\n > **Note:** The focal length is defined by screen. If objects are further than this,\n they will appear to be inside the screen. If objects are closer than this,\n they will appear to pop out of the screen. Objects at this distance appear\n to be at the screen.\n # Arguments\n\n* `mtx` (direction out) - Output matrix\n * `fovy` (direction in) - Vertical field of view in radians\n * `aspect` (direction in) - Aspect ration of projection plane (width/height)\n * `near` (direction in) - Near clip plane (Z=near)\n * `far` (direction in) - Far clip plane (Z=far)\n * `iod` (direction in) - Interocular distance\n * `screen` (direction in) - Focal length\n * `isLeftHanded` (direction in) - Whether to build a LH projection\n [`Mtx_Persp`]\n [`Mtx_PerspTilt`]\n [`Mtx_PerspStereoTilt`]"]
    pub fn Mtx_PerspStereo(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        iod: f32,
        screen: f32,
        isLeftHanded: bool,
    );
}
unsafe extern "C" {
    #[doc = "Orthogonal projection, tilted to account for the 3DS screen rotation\n # Arguments\n\n* `mtx` (direction out) - Output matrix\n * `left` (direction in) - Left clip plane (X=left)\n * `right` (direction in) - Right clip plane (X=right)\n * `bottom` (direction in) - Bottom clip plane (Y=bottom)\n * `top` (direction in) - Top clip plane (Y=top)\n * `near` (direction in) - Near clip plane (Z=near)\n * `far` (direction in) - Far clip plane (Z=far)\n * `isLeftHanded` (direction in) - Whether to build a LH projection\n [`Mtx_Ortho`]"]
    pub fn Mtx_OrthoTilt(
        mtx: *mut C3D_Mtx,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
unsafe extern "C" {
    #[doc = "Perspective projection, tilted to account for the 3DS screen rotation\n # Arguments\n\n* `mtx` (direction out) - Output matrix\n * `fovy` (direction in) - Vertical field of view in radians\n * `aspect` (direction in) - Aspect ration of projection plane (width/height)\n * `near` (direction in) - Near clip plane (Z=near)\n * `far` (direction in) - Far clip plane (Z=far)\n * `isLeftHanded` (direction in) - Whether to build a LH projection\n [`Mtx_Persp`]\n [`Mtx_PerspStereo`]\n [`Mtx_PerspStereoTilt`]"]
    pub fn Mtx_PerspTilt(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
unsafe extern "C" {
    #[doc = "Stereo perspective projection, tilted to account for the 3DS screen rotation\n > **Note:** See the notes for Mtx_PerspStereo\n # Arguments\n\n* `mtx` (direction out) - Output matrix\n * `fovy` (direction in) - Vertical field of view in radians\n * `aspect` (direction in) - Aspect ration of projection plane (width/height)\n * `near` (direction in) - Near clip plane (Z=near)\n * `far` (direction in) - Far clip plane (Z=far)\n * `iod` (direction in) - Interocular distance\n * `screen` (direction in) - Focal length\n * `isLeftHanded` (direction in) - Whether to build a LH projection\n [`Mtx_Persp`]\n [`Mtx_PerspTilt`]\n [`Mtx_PerspStereo`]"]
    pub fn Mtx_PerspStereoTilt(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        iod: f32,
        screen: f32,
        isLeftHanded: bool,
    );
}
unsafe extern "C" {
    #[doc = "Look-At matrix, based on DirectX implementation\n > **Note:** See https://msdn.microsoft.com/en-us/library/windows/desktop/bb205342\n # Arguments\n\n* `out` (direction out) - Output matrix.\n * `cameraPosition` (direction in) - Position of the intended camera in 3D space.\n * `cameraTarget` (direction in) - Position of the intended target the camera is supposed to face in 3D space.\n * `cameraUpVector` (direction in) - The vector that points straight up depending on the camera's \"Up\" direction.\n * `isLeftHanded` (direction in) - Whether to build a LH projection"]
    pub fn Mtx_LookAt(
        out: *mut C3D_Mtx,
        cameraPosition: C3D_FVec,
        cameraTarget: C3D_FVec,
        cameraUpVector: C3D_FVec,
        isLeftHanded: bool,
    );
}
unsafe extern "C" {
    #[doc = "Multiply two Quaternions\n # Arguments\n\n* `lhs` (direction in) - Multiplicand\n * `rhs` (direction in) - Multiplier\n # Returns\n\nlhs*rhs"]
    pub fn Quat_Multiply(lhs: C3D_FQuat, rhs: C3D_FQuat) -> C3D_FQuat;
}
unsafe extern "C" {
    #[doc = "Raise Quaternion to a power\n > **Note:** If p is 0, this returns the identity Quaternion.\n If p is 1, this returns q.\n # Arguments\n\n* `q` (direction in) - Base Quaternion\n * `p` (direction in) - Power\n # Returns\n\nq<sup>p</sup>"]
    pub fn Quat_Pow(q: C3D_FQuat, p: f32) -> C3D_FQuat;
}
unsafe extern "C" {
    #[doc = "Cross product of Quaternion and FVec3\n # Arguments\n\n* `q` (direction in) - Base Quaternion\n * `v` (direction in) - Vector to cross\n # Returns\n\nq×v"]
    pub fn Quat_CrossFVec3(q: C3D_FQuat, v: C3D_FVec) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "3D Rotation\n # Arguments\n\n* `q` (direction in) - Quaternion to rotate\n * `axis` (direction in) - Axis about which to rotate\n * `r` (direction in) - Radians to rotate\n * `bRightSide` (direction in) - Whether to transform from the right side\n # Returns\n\nRotated Quaternion"]
    pub fn Quat_Rotate(q: C3D_FQuat, axis: C3D_FVec, r: f32, bRightSide: bool) -> C3D_FQuat;
}
unsafe extern "C" {
    #[doc = "3D Rotation about the X axis\n # Arguments\n\n* `q` (direction in) - Quaternion to rotate\n * `r` (direction in) - Radians to rotate\n * `bRightSide` (direction in) - Whether to transform from the right side\n # Returns\n\nRotated Quaternion"]
    pub fn Quat_RotateX(q: C3D_FQuat, r: f32, bRightSide: bool) -> C3D_FQuat;
}
unsafe extern "C" {
    #[doc = "3D Rotation about the Y axis\n # Arguments\n\n* `q` (direction in) - Quaternion to rotate\n * `r` (direction in) - Radians to rotate\n * `bRightSide` (direction in) - Whether to transform from the right side\n # Returns\n\nRotated Quaternion"]
    pub fn Quat_RotateY(q: C3D_FQuat, r: f32, bRightSide: bool) -> C3D_FQuat;
}
unsafe extern "C" {
    #[doc = "3D Rotation about the Z axis\n # Arguments\n\n* `q` (direction in) - Quaternion to rotate\n * `r` (direction in) - Radians to rotate\n * `bRightSide` (direction in) - Whether to transform from the right side\n # Returns\n\nRotated Quaternion"]
    pub fn Quat_RotateZ(q: C3D_FQuat, r: f32, bRightSide: bool) -> C3D_FQuat;
}
unsafe extern "C" {
    #[doc = "Get Quaternion equivalent to 4x4 matrix\n > **Note:** If the matrix is orthogonal or special orthogonal, where determinant(matrix) = +1.0f, then the matrix can be converted.\n # Arguments\n\n* `m` (direction in) - Input Matrix\n # Returns\n\nGenerated Quaternion"]
    pub fn Quat_FromMtx(m: *const C3D_Mtx) -> C3D_FQuat;
}
unsafe extern "C" {
    #[doc = "Identity Quaternion\n # Returns\n\nIdentity Quaternion"]
    #[link_name = "Quat_Identity__extern"]
    pub fn Quat_Identity() -> C3D_FQuat;
}
unsafe extern "C" {
    #[doc = "Quaternion conjugate\n # Arguments\n\n* `q` (direction in) - Quaternion of which to get conjugate\n # Returns\n\nq*"]
    #[link_name = "Quat_Conjugate__extern"]
    pub fn Quat_Conjugate(q: C3D_FQuat) -> C3D_FQuat;
}
unsafe extern "C" {
    #[doc = "Quaternion inverse\n > **Note:** This is equivalent to `Quat_Pow(v, -1)`\n # Arguments\n\n* `q` (direction in) - Quaternion of which to get inverse\n # Returns\n\nq<sup>-1</sup>"]
    #[link_name = "Quat_Inverse__extern"]
    pub fn Quat_Inverse(q: C3D_FQuat) -> C3D_FQuat;
}
unsafe extern "C" {
    #[doc = "Cross product of FVec3 and Quaternion\n # Arguments\n\n* `v` (direction in) - Base FVec3\n * `q` (direction in) - Quaternion to cross\n # Returns\n\nv×q"]
    #[link_name = "FVec3_CrossQuat__extern"]
    pub fn FVec3_CrossQuat(v: C3D_FVec, q: C3D_FQuat) -> C3D_FVec;
}
unsafe extern "C" {
    #[doc = "Converting Pitch, Yaw, and Roll to Quaternion equivalent\n # Arguments\n\n* `pitch` (direction in) - The pitch angle in radians.\n * `yaw` (direction in) - The yaw angle in radians.\n * `roll` (direction in) - The roll angle in radians.\n * `bRightSide` (direction in) - Whether to transform from the right side\n # Returns\n\nC3D_FQuat The Quaternion equivalent with the pitch, yaw, and roll (in that order) orientations applied."]
    pub fn Quat_FromPitchYawRoll(pitch: f32, yaw: f32, roll: f32, bRightSide: bool) -> C3D_FQuat;
}
unsafe extern "C" {
    #[doc = "Quaternion Look-At\n # Arguments\n\n* `source` (direction in) - C3D_FVec Starting position. Origin of rotation.\n * `target` (direction in) - C3D_FVec Target position to orient towards.\n * `forwardVector` (direction in) - C3D_FVec The Up vector.\n * `upVector` (direction in) - C3D_FVec The Up vector.\n # Returns\n\nQuaternion rotation."]
    pub fn Quat_LookAt(
        source: C3D_FVec,
        target: C3D_FVec,
        forwardVector: C3D_FVec,
        upVector: C3D_FVec,
    ) -> C3D_FQuat;
}
unsafe extern "C" {
    #[doc = "Quaternion, created from a given axis and angle in radians.\n # Arguments\n\n* `axis` (direction in) - C3D_FVec The axis to rotate around at.\n * `angle` (direction in) - float The angle to rotate. Unit: Radians\n # Returns\n\nQuaternion rotation based on the axis and angle. Axis doesn't have to be orthogonal."]
    pub fn Quat_FromAxisAngle(axis: C3D_FVec, angle: f32) -> C3D_FQuat;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_MtxStack {
    pub m: [C3D_Mtx; 8usize],
    pub pos: ::libc::c_int,
    pub unifType: u8_,
    pub unifPos: u8_,
    pub unifLen: u8_,
    pub isDirty: bool,
}
unsafe extern "C" {
    #[link_name = "MtxStack_Cur__extern"]
    pub fn MtxStack_Cur(stk: *mut C3D_MtxStack) -> *mut C3D_Mtx;
}
unsafe extern "C" {
    pub fn MtxStack_Init(stk: *mut C3D_MtxStack);
}
unsafe extern "C" {
    pub fn MtxStack_Bind(
        stk: *mut C3D_MtxStack,
        unifType: GPU_SHADER_TYPE,
        unifPos: ::libc::c_int,
        unifLen: ::libc::c_int,
    );
}
unsafe extern "C" {
    pub fn MtxStack_Push(stk: *mut C3D_MtxStack) -> *mut C3D_Mtx;
}
unsafe extern "C" {
    pub fn MtxStack_Pop(stk: *mut C3D_MtxStack) -> *mut C3D_Mtx;
}
unsafe extern "C" {
    pub fn MtxStack_Update(stk: *mut C3D_MtxStack);
}
unsafe extern "C" {
    pub static mut C3D_FVUnif: [[C3D_FVec; 96usize]; 2usize];
}
unsafe extern "C" {
    pub static mut C3D_IVUnif: [[C3D_IVec; 4usize]; 2usize];
}
unsafe extern "C" {
    pub static mut C3D_BoolUnifs: [u16_; 2usize];
}
unsafe extern "C" {
    pub static mut C3D_FVUnifDirty: [[bool; 96usize]; 2usize];
}
unsafe extern "C" {
    pub static mut C3D_IVUnifDirty: [[bool; 4usize]; 2usize];
}
unsafe extern "C" {
    pub static mut C3D_BoolUnifsDirty: [bool; 2usize];
}
unsafe extern "C" {
    #[link_name = "C3D_FVUnifWritePtr__extern"]
    pub fn C3D_FVUnifWritePtr(
        type_: GPU_SHADER_TYPE,
        id: ::libc::c_int,
        size: ::libc::c_int,
    ) -> *mut C3D_FVec;
}
unsafe extern "C" {
    #[link_name = "C3D_IVUnifWritePtr__extern"]
    pub fn C3D_IVUnifWritePtr(type_: GPU_SHADER_TYPE, id: ::libc::c_int) -> *mut C3D_IVec;
}
unsafe extern "C" {
    #[link_name = "C3D_FVUnifMtxNx4__extern"]
    pub fn C3D_FVUnifMtxNx4(
        type_: GPU_SHADER_TYPE,
        id: ::libc::c_int,
        mtx: *const C3D_Mtx,
        num: ::libc::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "C3D_FVUnifMtx4x4__extern"]
    pub fn C3D_FVUnifMtx4x4(type_: GPU_SHADER_TYPE, id: ::libc::c_int, mtx: *const C3D_Mtx);
}
unsafe extern "C" {
    #[link_name = "C3D_FVUnifMtx3x4__extern"]
    pub fn C3D_FVUnifMtx3x4(type_: GPU_SHADER_TYPE, id: ::libc::c_int, mtx: *const C3D_Mtx);
}
unsafe extern "C" {
    #[link_name = "C3D_FVUnifMtx2x4__extern"]
    pub fn C3D_FVUnifMtx2x4(type_: GPU_SHADER_TYPE, id: ::libc::c_int, mtx: *const C3D_Mtx);
}
unsafe extern "C" {
    #[link_name = "C3D_FVUnifSet__extern"]
    pub fn C3D_FVUnifSet(type_: GPU_SHADER_TYPE, id: ::libc::c_int, x: f32, y: f32, z: f32, w: f32);
}
unsafe extern "C" {
    #[link_name = "C3D_IVUnifSet__extern"]
    pub fn C3D_IVUnifSet(
        type_: GPU_SHADER_TYPE,
        id: ::libc::c_int,
        x: ::libc::c_int,
        y: ::libc::c_int,
        z: ::libc::c_int,
        w: ::libc::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "C3D_BoolUnifSet__extern"]
    pub fn C3D_BoolUnifSet(type_: GPU_SHADER_TYPE, id: ::libc::c_int, value: bool);
}
unsafe extern "C" {
    pub fn C3D_UpdateUniforms(type_: GPU_SHADER_TYPE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_AttrInfo {
    pub flags: [u32_; 2usize],
    pub permutation: u64_,
    pub attrCount: ::libc::c_int,
}
unsafe extern "C" {
    pub fn AttrInfo_Init(info: *mut C3D_AttrInfo);
}
unsafe extern "C" {
    pub fn AttrInfo_AddLoader(
        info: *mut C3D_AttrInfo,
        regId: ::libc::c_int,
        format: GPU_FORMATS,
        count: ::libc::c_int,
    ) -> ::libc::c_int;
}
unsafe extern "C" {
    pub fn AttrInfo_AddFixed(info: *mut C3D_AttrInfo, regId: ::libc::c_int) -> ::libc::c_int;
}
unsafe extern "C" {
    pub fn C3D_GetAttrInfo() -> *mut C3D_AttrInfo;
}
unsafe extern "C" {
    pub fn C3D_SetAttrInfo(info: *mut C3D_AttrInfo);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_BufCfg {
    pub offset: u32_,
    pub flags: [u32_; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_BufInfo {
    pub base_paddr: u32_,
    pub bufCount: ::libc::c_int,
    pub buffers: [C3D_BufCfg; 12usize],
}
unsafe extern "C" {
    pub fn BufInfo_Init(info: *mut C3D_BufInfo);
}
unsafe extern "C" {
    pub fn BufInfo_Add(
        info: *mut C3D_BufInfo,
        data: *const ::libc::c_void,
        stride: isize,
        attribCount: ::libc::c_int,
        permutation: u64_,
    ) -> ::libc::c_int;
}
unsafe extern "C" {
    pub fn C3D_GetBufInfo() -> *mut C3D_BufInfo;
}
unsafe extern "C" {
    pub fn C3D_SetBufInfo(info: *mut C3D_BufInfo);
}
pub const C3D_UNSIGNED_BYTE: _bindgen_ty_39 = 0;
pub const C3D_UNSIGNED_SHORT: _bindgen_ty_39 = 1;
pub type _bindgen_ty_39 = ::libc::c_uchar;
unsafe extern "C" {
    pub fn C3D_Init(cmdBufSize: usize) -> bool;
}
unsafe extern "C" {
    pub fn C3D_Fini();
}
unsafe extern "C" {
    pub fn C3D_GetCmdBufUsage() -> f32;
}
unsafe extern "C" {
    pub fn C3D_BindProgram(program: *mut shaderProgram_s);
}
unsafe extern "C" {
    pub fn C3D_SetViewport(x: u32_, y: u32_, w: u32_, h: u32_);
}
unsafe extern "C" {
    pub fn C3D_SetScissor(mode: GPU_SCISSORMODE, left: u32_, top: u32_, right: u32_, bottom: u32_);
}
unsafe extern "C" {
    pub fn C3D_DrawArrays(primitive: GPU_Primitive_t, first: ::libc::c_int, size: ::libc::c_int);
}
unsafe extern "C" {
    pub fn C3D_DrawElements(
        primitive: GPU_Primitive_t,
        count: ::libc::c_int,
        type_: ::libc::c_int,
        indices: *const ::libc::c_void,
    );
}
unsafe extern "C" {
    pub fn C3D_ImmDrawBegin(primitive: GPU_Primitive_t);
}
unsafe extern "C" {
    pub fn C3D_ImmSendAttrib(x: f32, y: f32, z: f32, w: f32);
}
unsafe extern "C" {
    pub fn C3D_ImmDrawEnd();
}
unsafe extern "C" {
    #[link_name = "C3D_ImmDrawRestartPrim__extern"]
    pub fn C3D_ImmDrawRestartPrim();
}
unsafe extern "C" {
    pub fn C3D_FixedAttribGetWritePtr(id: ::libc::c_int) -> *mut C3D_FVec;
}
unsafe extern "C" {
    #[link_name = "C3D_FixedAttribSet__extern"]
    pub fn C3D_FixedAttribSet(id: ::libc::c_int, x: f32, y: f32, z: f32, w: f32);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_TexEnv {
    pub srcRgb: u16_,
    pub srcAlpha: u16_,
    pub __bindgen_anon_1: C3D_TexEnv__bindgen_ty_1,
    pub funcRgb: u16_,
    pub funcAlpha: u16_,
    pub color: u32_,
    pub scaleRgb: u16_,
    pub scaleAlpha: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_TexEnv__bindgen_ty_1 {
    pub opAll: u32_,
    pub __bindgen_anon_1: C3D_TexEnv__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexEnv__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
impl C3D_TexEnv__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn opRgb(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_opRgb(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn opRgb_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_opRgb_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn opAlpha(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_opAlpha(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn opAlpha_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_opAlpha_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(opRgb: u32_, opAlpha: u32_) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let opRgb: u32 = unsafe { ::core::mem::transmute(opRgb) };
            opRgb as u64
        });
        __bindgen_bitfield_unit.set(12usize, 12u8, {
            let opAlpha: u32 = unsafe { ::core::mem::transmute(opAlpha) };
            opAlpha as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_RGB: C3D_TexEnvMode = 1;
pub const C3D_Alpha: C3D_TexEnvMode = 2;
pub const C3D_Both: C3D_TexEnvMode = 3;
pub type C3D_TexEnvMode = ::libc::c_uchar;
unsafe extern "C" {
    pub fn C3D_GetTexEnv(id: ::libc::c_int) -> *mut C3D_TexEnv;
}
unsafe extern "C" {
    pub fn C3D_SetTexEnv(id: ::libc::c_int, env: *mut C3D_TexEnv);
}
unsafe extern "C" {
    pub fn C3D_DirtyTexEnv(env: *mut C3D_TexEnv);
}
unsafe extern "C" {
    pub fn C3D_TexEnvBufUpdate(mode: ::libc::c_int, mask: ::libc::c_int);
}
unsafe extern "C" {
    pub fn C3D_TexEnvBufColor(color: u32_);
}
unsafe extern "C" {
    #[link_name = "C3D_TexEnvInit__extern"]
    pub fn C3D_TexEnvInit(env: *mut C3D_TexEnv);
}
unsafe extern "C" {
    #[link_name = "C3D_TexEnvSrc__extern"]
    pub fn C3D_TexEnvSrc(
        env: *mut C3D_TexEnv,
        mode: C3D_TexEnvMode,
        s1: GPU_TEVSRC,
        s2: GPU_TEVSRC,
        s3: GPU_TEVSRC,
    );
}
unsafe extern "C" {
    #[link_name = "C3D_TexEnvOpRgb__extern"]
    pub fn C3D_TexEnvOpRgb(
        env: *mut C3D_TexEnv,
        o1: GPU_TEVOP_RGB,
        o2: GPU_TEVOP_RGB,
        o3: GPU_TEVOP_RGB,
    );
}
unsafe extern "C" {
    #[link_name = "C3D_TexEnvOpAlpha__extern"]
    pub fn C3D_TexEnvOpAlpha(
        env: *mut C3D_TexEnv,
        o1: GPU_TEVOP_A,
        o2: GPU_TEVOP_A,
        o3: GPU_TEVOP_A,
    );
}
unsafe extern "C" {
    #[link_name = "C3D_TexEnvFunc__extern"]
    pub fn C3D_TexEnvFunc(env: *mut C3D_TexEnv, mode: C3D_TexEnvMode, param: GPU_COMBINEFUNC);
}
unsafe extern "C" {
    #[link_name = "C3D_TexEnvColor__extern"]
    pub fn C3D_TexEnvColor(env: *mut C3D_TexEnv, color: u32_);
}
unsafe extern "C" {
    #[link_name = "C3D_TexEnvScale__extern"]
    pub fn C3D_TexEnvScale(env: *mut C3D_TexEnv, mode: ::libc::c_int, param: GPU_TEVSCALE);
}
unsafe extern "C" {
    pub fn C3D_DepthMap(bIsZBuffer: bool, zScale: f32, zOffset: f32);
}
unsafe extern "C" {
    pub fn C3D_CullFace(mode: GPU_CULLMODE);
}
unsafe extern "C" {
    pub fn C3D_StencilTest(
        enable: bool,
        function: GPU_TESTFUNC,
        ref_: ::libc::c_int,
        inputMask: ::libc::c_int,
        writeMask: ::libc::c_int,
    );
}
unsafe extern "C" {
    pub fn C3D_StencilOp(sfail: GPU_STENCILOP, dfail: GPU_STENCILOP, pass: GPU_STENCILOP);
}
unsafe extern "C" {
    pub fn C3D_BlendingColor(color: u32_);
}
unsafe extern "C" {
    pub fn C3D_EarlyDepthTest(enable: bool, function: GPU_EARLYDEPTHFUNC, ref_: u32_);
}
unsafe extern "C" {
    pub fn C3D_DepthTest(enable: bool, function: GPU_TESTFUNC, writemask: GPU_WRITEMASK);
}
unsafe extern "C" {
    pub fn C3D_AlphaTest(enable: bool, function: GPU_TESTFUNC, ref_: ::libc::c_int);
}
unsafe extern "C" {
    pub fn C3D_AlphaBlend(
        colorEq: GPU_BLENDEQUATION,
        alphaEq: GPU_BLENDEQUATION,
        srcClr: GPU_BLENDFACTOR,
        dstClr: GPU_BLENDFACTOR,
        srcAlpha: GPU_BLENDFACTOR,
        dstAlpha: GPU_BLENDFACTOR,
    );
}
unsafe extern "C" {
    pub fn C3D_ColorLogicOp(op: GPU_LOGICOP);
}
unsafe extern "C" {
    pub fn C3D_FragOpMode(mode: GPU_FRAGOPMODE);
}
unsafe extern "C" {
    pub fn C3D_FragOpShadow(scale: f32, bias: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexCube {
    pub data: [*mut ::libc::c_void; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_Tex {
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_2: C3D_Tex__bindgen_ty_2,
    pub param: u32_,
    pub border: u32_,
    pub __bindgen_anon_3: C3D_Tex__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_1 {
    pub data: *mut ::libc::c_void,
    pub cube: *mut C3D_TexCube,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_2 {
    pub dim: u32_,
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Tex__bindgen_ty_2__bindgen_ty_1 {
    pub height: u16_,
    pub width: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_3 {
    pub lodParam: u32_,
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Tex__bindgen_ty_3__bindgen_ty_1 {
    pub lodBias: u16_,
    pub maxLevel: u8_,
    pub minLevel: u8_,
}
impl C3D_Tex {
    #[inline]
    pub fn fmt(&self) -> GPU_TEXCOLOR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_fmt(&mut self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fmt_raw(this: *const Self) -> GPU_TEXCOLOR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_fmt_raw(this: *mut Self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn size(&self) -> usize {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: usize) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn size_raw(this: *const Self) -> usize {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_size_raw(this: *mut Self, val: usize) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(fmt: GPU_TEXCOLOR, size: usize) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let fmt: u8 = unsafe { ::core::mem::transmute(fmt) };
            fmt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let size: u32 = unsafe { ::core::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexInitParams {
    pub width: u16_,
    pub height: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl C3D_TexInitParams {
    #[inline]
    pub fn maxLevel(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_maxLevel(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn maxLevel_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_maxLevel_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn format(&self) -> GPU_TEXCOLOR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_format(&mut self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn format_raw(this: *const Self) -> GPU_TEXCOLOR {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_format_raw(this: *mut Self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> GPU_TEXTURE_MODE_PARAM {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: GPU_TEXTURE_MODE_PARAM) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> GPU_TEXTURE_MODE_PARAM {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: GPU_TEXTURE_MODE_PARAM) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn onVram(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_onVram(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn onVram_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_onVram_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        maxLevel: u8_,
        format: GPU_TEXCOLOR,
        type_: GPU_TEXTURE_MODE_PARAM,
        onVram: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let maxLevel: u8 = unsafe { ::core::mem::transmute(maxLevel) };
            maxLevel as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let format: u8 = unsafe { ::core::mem::transmute(format) };
            format as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let type_: u8 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let onVram: u8 = unsafe { ::core::mem::transmute(onVram) };
            onVram as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub fn C3D_TexInitWithParams(
        tex: *mut C3D_Tex,
        cube: *mut C3D_TexCube,
        p: C3D_TexInitParams,
    ) -> bool;
}
unsafe extern "C" {
    pub fn C3D_TexLoadImage(
        tex: *mut C3D_Tex,
        data: *const ::libc::c_void,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
    );
}
unsafe extern "C" {
    pub fn C3D_TexGenerateMipmap(tex: *mut C3D_Tex, face: GPU_TEXFACE);
}
unsafe extern "C" {
    pub fn C3D_TexBind(unitId: ::libc::c_int, tex: *mut C3D_Tex);
}
unsafe extern "C" {
    pub fn C3D_TexFlush(tex: *mut C3D_Tex);
}
unsafe extern "C" {
    pub fn C3D_TexDelete(tex: *mut C3D_Tex);
}
unsafe extern "C" {
    pub fn C3D_TexShadowParams(perspective: bool, bias: f32);
}
unsafe extern "C" {
    #[link_name = "C3D_TexCalcMaxLevel__extern"]
    pub fn C3D_TexCalcMaxLevel(width: u32_, height: u32_) -> ::libc::c_int;
}
unsafe extern "C" {
    #[link_name = "C3D_TexCalcLevelSize__extern"]
    pub fn C3D_TexCalcLevelSize(size: u32_, level: ::libc::c_int) -> u32_;
}
unsafe extern "C" {
    #[link_name = "C3D_TexCalcTotalSize__extern"]
    pub fn C3D_TexCalcTotalSize(size: u32_, maxLevel: ::libc::c_int) -> u32_;
}
unsafe extern "C" {
    #[link_name = "C3D_TexInit__extern"]
    pub fn C3D_TexInit(tex: *mut C3D_Tex, width: u16_, height: u16_, format: GPU_TEXCOLOR) -> bool;
}
unsafe extern "C" {
    #[link_name = "C3D_TexInitMipmap__extern"]
    pub fn C3D_TexInitMipmap(
        tex: *mut C3D_Tex,
        width: u16_,
        height: u16_,
        format: GPU_TEXCOLOR,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "C3D_TexInitCube__extern"]
    pub fn C3D_TexInitCube(
        tex: *mut C3D_Tex,
        cube: *mut C3D_TexCube,
        width: u16_,
        height: u16_,
        format: GPU_TEXCOLOR,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "C3D_TexInitVRAM__extern"]
    pub fn C3D_TexInitVRAM(
        tex: *mut C3D_Tex,
        width: u16_,
        height: u16_,
        format: GPU_TEXCOLOR,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "C3D_TexInitShadow__extern"]
    pub fn C3D_TexInitShadow(tex: *mut C3D_Tex, width: u16_, height: u16_) -> bool;
}
unsafe extern "C" {
    #[link_name = "C3D_TexInitShadowCube__extern"]
    pub fn C3D_TexInitShadowCube(
        tex: *mut C3D_Tex,
        cube: *mut C3D_TexCube,
        width: u16_,
        height: u16_,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "C3D_TexGetType__extern"]
    pub fn C3D_TexGetType(tex: *mut C3D_Tex) -> GPU_TEXTURE_MODE_PARAM;
}
unsafe extern "C" {
    #[link_name = "C3D_TexGetImagePtr__extern"]
    pub fn C3D_TexGetImagePtr(
        tex: *mut C3D_Tex,
        data: *mut ::libc::c_void,
        level: ::libc::c_int,
        size: *mut u32_,
    ) -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[link_name = "C3D_Tex2DGetImagePtr__extern"]
    pub fn C3D_Tex2DGetImagePtr(
        tex: *mut C3D_Tex,
        level: ::libc::c_int,
        size: *mut u32_,
    ) -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[link_name = "C3D_TexCubeGetImagePtr__extern"]
    pub fn C3D_TexCubeGetImagePtr(
        tex: *mut C3D_Tex,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
        size: *mut u32_,
    ) -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[link_name = "C3D_TexUpload__extern"]
    pub fn C3D_TexUpload(tex: *mut C3D_Tex, data: *const ::libc::c_void);
}
unsafe extern "C" {
    #[link_name = "C3D_TexSetFilter__extern"]
    pub fn C3D_TexSetFilter(
        tex: *mut C3D_Tex,
        magFilter: GPU_TEXTURE_FILTER_PARAM,
        minFilter: GPU_TEXTURE_FILTER_PARAM,
    );
}
unsafe extern "C" {
    #[link_name = "C3D_TexSetFilterMipmap__extern"]
    pub fn C3D_TexSetFilterMipmap(tex: *mut C3D_Tex, filter: GPU_TEXTURE_FILTER_PARAM);
}
unsafe extern "C" {
    #[link_name = "C3D_TexSetWrap__extern"]
    pub fn C3D_TexSetWrap(
        tex: *mut C3D_Tex,
        wrapS: GPU_TEXTURE_WRAP_PARAM,
        wrapT: GPU_TEXTURE_WRAP_PARAM,
    );
}
unsafe extern "C" {
    #[link_name = "C3D_TexSetLodBias__extern"]
    pub fn C3D_TexSetLodBias(tex: *mut C3D_Tex, lodBias: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTexColorLut {
    pub color: [u32_; 256usize],
    pub diff: [u32_; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_ProcTex {
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_1,
    pub __bindgen_anon_2: C3D_ProcTex__bindgen_ty_2,
    pub __bindgen_anon_3: C3D_ProcTex__bindgen_ty_3,
    pub __bindgen_anon_4: C3D_ProcTex__bindgen_ty_4,
    pub __bindgen_anon_5: C3D_ProcTex__bindgen_ty_5,
    pub __bindgen_anon_6: C3D_ProcTex__bindgen_ty_6,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_1 {
    pub proctex0: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn uClamp(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_uClamp(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uClamp_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_uClamp_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vClamp(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_vClamp(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vClamp_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vClamp_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rgbFunc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rgbFunc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rgbFunc_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rgbFunc_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn alphaFunc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_alphaFunc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn alphaFunc_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_alphaFunc_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn alphaSeparate(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_alphaSeparate(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn alphaSeparate_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_alphaSeparate_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableNoise(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enableNoise(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableNoise_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enableNoise_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn uShift(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_uShift(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uShift_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_uShift_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vShift(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_vShift(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vShift_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vShift_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lodBiasLow(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lodBiasLow(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lodBiasLow_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lodBiasLow_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uClamp: u32_,
        vClamp: u32_,
        rgbFunc: u32_,
        alphaFunc: u32_,
        alphaSeparate: bool,
        enableNoise: bool,
        uShift: u32_,
        vShift: u32_,
        lodBiasLow: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let uClamp: u32 = unsafe { ::core::mem::transmute(uClamp) };
            uClamp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let vClamp: u32 = unsafe { ::core::mem::transmute(vClamp) };
            vClamp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let rgbFunc: u32 = unsafe { ::core::mem::transmute(rgbFunc) };
            rgbFunc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let alphaFunc: u32 = unsafe { ::core::mem::transmute(alphaFunc) };
            alphaFunc as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let alphaSeparate: u8 = unsafe { ::core::mem::transmute(alphaSeparate) };
            alphaSeparate as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enableNoise: u8 = unsafe { ::core::mem::transmute(enableNoise) };
            enableNoise as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let uShift: u32 = unsafe { ::core::mem::transmute(uShift) };
            uShift as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let vShift: u32 = unsafe { ::core::mem::transmute(vShift) };
            vShift as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let lodBiasLow: u32 = unsafe { ::core::mem::transmute(lodBiasLow) };
            lodBiasLow as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_2 {
    pub proctex1: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_2__bindgen_ty_1 {
    pub uNoiseAmpl: u16_,
    pub uNoisePhase: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_3 {
    pub proctex2: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_3__bindgen_ty_1 {
    pub vNoiseAmpl: u16_,
    pub vNoisePhase: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_4 {
    pub proctex3: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_4__bindgen_ty_1 {
    pub uNoiseFreq: u16_,
    pub vNoiseFreq: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_5 {
    pub proctex4: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn minFilter(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_minFilter(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn minFilter_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_minFilter_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn unknown1(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_unknown1(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn unknown1_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_unknown1_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn width(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_width(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn width_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_width_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lodBiasHigh(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lodBiasHigh(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lodBiasHigh_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lodBiasHigh_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        minFilter: u32_,
        unknown1: u32_,
        width: u32_,
        lodBiasHigh: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let minFilter: u32 = unsafe { ::core::mem::transmute(minFilter) };
            minFilter as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let unknown1: u32 = unsafe { ::core::mem::transmute(unknown1) };
            unknown1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 8u8, {
            let width: u32 = unsafe { ::core::mem::transmute(width) };
            width as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let lodBiasHigh: u32 = unsafe { ::core::mem::transmute(lodBiasHigh) };
            lodBiasHigh as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_6 {
    pub proctex5: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn offset(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offset_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_offset_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn unknown2(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_unknown2(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn unknown2_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_unknown2_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(offset: u32_, unknown2: u32_) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let offset: u32 = unsafe { ::core::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let unknown2: u32 = unsafe { ::core::mem::transmute(unknown2) };
            unknown2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_ProcTex_U: _bindgen_ty_40 = 1;
pub const C3D_ProcTex_V: _bindgen_ty_40 = 2;
pub const C3D_ProcTex_UV: _bindgen_ty_40 = 3;
pub type _bindgen_ty_40 = ::libc::c_uchar;
unsafe extern "C" {
    pub fn C3D_ProcTexInit(pt: *mut C3D_ProcTex, offset: ::libc::c_int, length: ::libc::c_int);
}
unsafe extern "C" {
    pub fn C3D_ProcTexNoiseCoefs(
        pt: *mut C3D_ProcTex,
        mode: ::libc::c_int,
        amplitude: f32,
        frequency: f32,
        phase: f32,
    );
}
unsafe extern "C" {
    pub fn C3D_ProcTexLodBias(pt: *mut C3D_ProcTex, bias: f32);
}
unsafe extern "C" {
    pub fn C3D_ProcTexBind(texCoordId: ::libc::c_int, pt: *mut C3D_ProcTex);
}
pub type C3D_ProcTexLut = [u32_; 128usize];
unsafe extern "C" {
    pub fn C3D_ProcTexLutBind(id: GPU_PROCTEX_LUTID, lut: *mut C3D_ProcTexLut);
}
unsafe extern "C" {
    pub fn ProcTexLut_FromArray(lut: *mut C3D_ProcTexLut, in_: *const f32);
}
unsafe extern "C" {
    pub fn C3D_ProcTexColorLutBind(lut: *mut C3D_ProcTexColorLut);
}
unsafe extern "C" {
    pub fn ProcTexColorLut_Write(
        out: *mut C3D_ProcTexColorLut,
        in_: *const u32_,
        offset: ::libc::c_int,
        length: ::libc::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "C3D_ProcTexClamp__extern"]
    pub fn C3D_ProcTexClamp(pt: *mut C3D_ProcTex, u: GPU_PROCTEX_CLAMP, v: GPU_PROCTEX_CLAMP);
}
unsafe extern "C" {
    #[link_name = "C3D_ProcTexCombiner__extern"]
    pub fn C3D_ProcTexCombiner(
        pt: *mut C3D_ProcTex,
        separate: bool,
        rgb: GPU_PROCTEX_MAPFUNC,
        alpha: GPU_PROCTEX_MAPFUNC,
    );
}
unsafe extern "C" {
    #[link_name = "C3D_ProcTexNoiseEnable__extern"]
    pub fn C3D_ProcTexNoiseEnable(pt: *mut C3D_ProcTex, enable: bool);
}
unsafe extern "C" {
    #[link_name = "C3D_ProcTexShift__extern"]
    pub fn C3D_ProcTexShift(pt: *mut C3D_ProcTex, u: GPU_PROCTEX_SHIFT, v: GPU_PROCTEX_SHIFT);
}
unsafe extern "C" {
    #[link_name = "C3D_ProcTexFilter__extern"]
    pub fn C3D_ProcTexFilter(pt: *mut C3D_ProcTex, min: GPU_PROCTEX_FILTER);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLut {
    pub data: [u32_; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLutDA {
    pub lut: C3D_LightLut,
    pub bias: f32,
    pub scale: f32,
}
pub type C3D_LightLutFunc = ::core::option::Option<unsafe extern "C" fn(x: f32, param: f32) -> f32>;
pub type C3D_LightLutFuncDA =
    ::core::option::Option<unsafe extern "C" fn(dist: f32, arg0: f32, arg1: f32) -> f32>;
unsafe extern "C" {
    #[link_name = "quadratic_dist_attn__extern"]
    pub fn quadratic_dist_attn(dist: f32, linear: f32, quad_t: f32) -> f32;
}
unsafe extern "C" {
    #[link_name = "spot_step__extern"]
    pub fn spot_step(angle: f32, cutoff: f32) -> f32;
}
unsafe extern "C" {
    pub fn LightLut_FromArray(lut: *mut C3D_LightLut, data: *mut f32);
}
unsafe extern "C" {
    pub fn LightLut_FromFunc(
        lut: *mut C3D_LightLut,
        func: C3D_LightLutFunc,
        param: f32,
        negative: bool,
    );
}
unsafe extern "C" {
    pub fn LightLutDA_Create(
        lut: *mut C3D_LightLutDA,
        func: C3D_LightLutFuncDA,
        from: f32,
        to: f32,
        arg0: f32,
        arg1: f32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Material {
    pub ambient: [f32; 3usize],
    pub diffuse: [f32; 3usize],
    pub specular0: [f32; 3usize],
    pub specular1: [f32; 3usize],
    pub emission: [f32; 3usize],
}
pub type C3D_Light = C3D_Light_t;
pub type C3D_LightEnv = C3D_LightEnv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLutInputConf {
    pub abs: u32_,
    pub select: u32_,
    pub scale: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightEnvConf {
    pub ambient: u32_,
    pub numLights: u32_,
    pub config: [u32_; 2usize],
    pub lutInput: C3D_LightLutInputConf,
    pub permutation: u32_,
}
pub const C3DF_LightEnv_Dirty: _bindgen_ty_41 = 1;
pub const C3DF_LightEnv_MtlDirty: _bindgen_ty_41 = 2;
pub const C3DF_LightEnv_LCDirty: _bindgen_ty_41 = 4;
pub type _bindgen_ty_41 = ::libc::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightEnv_t {
    pub flags: u32_,
    pub luts: [*mut C3D_LightLut; 6usize],
    pub ambient: [f32; 3usize],
    pub lights: [*mut C3D_Light; 8usize],
    pub conf: C3D_LightEnvConf,
    pub material: C3D_Material,
}
unsafe extern "C" {
    pub fn C3D_LightEnvInit(env: *mut C3D_LightEnv);
}
unsafe extern "C" {
    pub fn C3D_LightEnvBind(env: *mut C3D_LightEnv);
}
unsafe extern "C" {
    pub fn C3D_LightEnvMaterial(env: *mut C3D_LightEnv, mtl: *const C3D_Material);
}
unsafe extern "C" {
    pub fn C3D_LightEnvAmbient(env: *mut C3D_LightEnv, r: f32, g: f32, b: f32);
}
unsafe extern "C" {
    pub fn C3D_LightEnvLut(
        env: *mut C3D_LightEnv,
        lutId: GPU_LIGHTLUTID,
        input: GPU_LIGHTLUTINPUT,
        negative: bool,
        lut: *mut C3D_LightLut,
    );
}
pub const GPU_SHADOW_PRIMARY: _bindgen_ty_42 = 65536;
pub const GPU_SHADOW_SECONDARY: _bindgen_ty_42 = 131072;
pub const GPU_INVERT_SHADOW: _bindgen_ty_42 = 262144;
pub const GPU_SHADOW_ALPHA: _bindgen_ty_42 = 524288;
pub type _bindgen_ty_42 = ::libc::c_uint;
unsafe extern "C" {
    pub fn C3D_LightEnvFresnel(env: *mut C3D_LightEnv, selector: GPU_FRESNELSEL);
}
unsafe extern "C" {
    pub fn C3D_LightEnvBumpMode(env: *mut C3D_LightEnv, mode: GPU_BUMPMODE);
}
unsafe extern "C" {
    pub fn C3D_LightEnvBumpSel(env: *mut C3D_LightEnv, texUnit: ::libc::c_int);
}
unsafe extern "C" {
    #[doc = "Configures whether to use the z component of the normal map.\n # Arguments\n\n* `env` (direction out) - Pointer to light environment structure.\n * `enable` (direction in) - false if the z component is reconstructed from the xy components\n of the normal map, true if the z component is taken from the normal map."]
    pub fn C3D_LightEnvBumpNormalZ(env: *mut C3D_LightEnv, enable: bool);
}
unsafe extern "C" {
    pub fn C3D_LightEnvShadowMode(env: *mut C3D_LightEnv, mode: u32_);
}
unsafe extern "C" {
    pub fn C3D_LightEnvShadowSel(env: *mut C3D_LightEnv, texUnit: ::libc::c_int);
}
unsafe extern "C" {
    pub fn C3D_LightEnvClampHighlights(env: *mut C3D_LightEnv, clamp: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightMatConf {
    pub specular0: u32_,
    pub specular1: u32_,
    pub diffuse: u32_,
    pub ambient: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightConf {
    pub material: C3D_LightMatConf,
    pub position: [u16_; 3usize],
    pub padding0: u16_,
    pub spotDir: [u16_; 3usize],
    pub padding1: u16_,
    pub padding2: u32_,
    pub config: u32_,
    pub distAttnBias: u32_,
    pub distAttnScale: u32_,
}
pub const C3DF_Light_Enabled: _bindgen_ty_43 = 1;
pub const C3DF_Light_Dirty: _bindgen_ty_43 = 2;
pub const C3DF_Light_MatDirty: _bindgen_ty_43 = 4;
pub const C3DF_Light_SPDirty: _bindgen_ty_43 = 16384;
pub const C3DF_Light_DADirty: _bindgen_ty_43 = 32768;
pub type _bindgen_ty_43 = ::libc::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Light_t {
    pub flags: u16_,
    pub id: u16_,
    pub parent: *mut C3D_LightEnv,
    pub lut_SP: *mut C3D_LightLut,
    pub lut_DA: *mut C3D_LightLut,
    pub ambient: [f32; 3usize],
    pub diffuse: [f32; 3usize],
    pub specular0: [f32; 3usize],
    pub specular1: [f32; 3usize],
    pub conf: C3D_LightConf,
}
unsafe extern "C" {
    pub fn C3D_LightInit(light: *mut C3D_Light, env: *mut C3D_LightEnv) -> ::libc::c_int;
}
unsafe extern "C" {
    pub fn C3D_LightEnable(light: *mut C3D_Light, enable: bool);
}
unsafe extern "C" {
    pub fn C3D_LightTwoSideDiffuse(light: *mut C3D_Light, enable: bool);
}
unsafe extern "C" {
    pub fn C3D_LightGeoFactor(light: *mut C3D_Light, id: ::libc::c_int, enable: bool);
}
unsafe extern "C" {
    pub fn C3D_LightAmbient(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
unsafe extern "C" {
    pub fn C3D_LightDiffuse(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
unsafe extern "C" {
    pub fn C3D_LightSpecular0(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
unsafe extern "C" {
    pub fn C3D_LightSpecular1(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
unsafe extern "C" {
    pub fn C3D_LightPosition(light: *mut C3D_Light, pos: *mut C3D_FVec);
}
unsafe extern "C" {
    pub fn C3D_LightShadowEnable(light: *mut C3D_Light, enable: bool);
}
unsafe extern "C" {
    pub fn C3D_LightSpotEnable(light: *mut C3D_Light, enable: bool);
}
unsafe extern "C" {
    pub fn C3D_LightSpotDir(light: *mut C3D_Light, x: f32, y: f32, z: f32);
}
unsafe extern "C" {
    pub fn C3D_LightSpotLut(light: *mut C3D_Light, lut: *mut C3D_LightLut);
}
unsafe extern "C" {
    pub fn C3D_LightDistAttnEnable(light: *mut C3D_Light, enable: bool);
}
unsafe extern "C" {
    pub fn C3D_LightDistAttn(light: *mut C3D_Light, lut: *mut C3D_LightLutDA);
}
unsafe extern "C" {
    #[link_name = "C3D_LightColor__extern"]
    pub fn C3D_LightColor(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FogLut {
    pub data: [u32_; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_GasLut {
    pub diff: [u32_; 8usize],
    pub color: [u32_; 8usize],
}
unsafe extern "C" {
    #[link_name = "FogLut_CalcZ__extern"]
    pub fn FogLut_CalcZ(depth: f32, near: f32, far: f32) -> f32;
}
unsafe extern "C" {
    pub fn FogLut_FromArray(lut: *mut C3D_FogLut, data: *const f32);
}
unsafe extern "C" {
    pub fn FogLut_Exp(lut: *mut C3D_FogLut, density: f32, gradient: f32, near: f32, far: f32);
}
unsafe extern "C" {
    pub fn C3D_FogGasMode(fogMode: GPU_FOGMODE, gasMode: GPU_GASMODE, zFlip: bool);
}
unsafe extern "C" {
    pub fn C3D_FogColor(color: u32_);
}
unsafe extern "C" {
    pub fn C3D_FogLutBind(lut: *mut C3D_FogLut);
}
unsafe extern "C" {
    pub fn GasLut_FromArray(lut: *mut C3D_GasLut, data: *const u32_);
}
unsafe extern "C" {
    pub fn C3D_GasBeginAcc();
}
unsafe extern "C" {
    pub fn C3D_GasDeltaZ(value: f32);
}
unsafe extern "C" {
    pub fn C3D_GasAccMax(value: f32);
}
unsafe extern "C" {
    pub fn C3D_GasAttn(value: f32);
}
unsafe extern "C" {
    pub fn C3D_GasLightPlanar(min: f32, max: f32, attn: f32);
}
unsafe extern "C" {
    pub fn C3D_GasLightView(min: f32, max: f32, attn: f32);
}
unsafe extern "C" {
    pub fn C3D_GasLightDirection(dotp: f32);
}
unsafe extern "C" {
    pub fn C3D_GasLutInput(input: GPU_GASLUTINPUT);
}
unsafe extern "C" {
    pub fn C3D_GasLutBind(lut: *mut C3D_GasLut);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FrameBuf {
    pub colorBuf: *mut ::libc::c_void,
    pub depthBuf: *mut ::libc::c_void,
    pub width: u16_,
    pub height: u16_,
    pub colorFmt: GPU_COLORBUF,
    pub depthFmt: GPU_DEPTHBUF,
    pub block32: bool,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl C3D_FrameBuf {
    #[inline]
    pub fn colorMask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_colorMask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn colorMask_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_colorMask_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn depthMask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_depthMask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn depthMask_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_depthMask_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(colorMask: u8_, depthMask: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let colorMask: u8 = unsafe { ::core::mem::transmute(colorMask) };
            colorMask as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let depthMask: u8 = unsafe { ::core::mem::transmute(depthMask) };
            depthMask as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_CLEAR_COLOR: C3D_ClearBits = 1;
pub const C3D_CLEAR_DEPTH: C3D_ClearBits = 2;
pub const C3D_CLEAR_ALL: C3D_ClearBits = 3;
pub type C3D_ClearBits = ::libc::c_uchar;
unsafe extern "C" {
    pub fn C3D_CalcColorBufSize(width: u32_, height: u32_, fmt: GPU_COLORBUF) -> u32_;
}
unsafe extern "C" {
    pub fn C3D_CalcDepthBufSize(width: u32_, height: u32_, fmt: GPU_DEPTHBUF) -> u32_;
}
unsafe extern "C" {
    pub fn C3D_GetFrameBuf() -> *mut C3D_FrameBuf;
}
unsafe extern "C" {
    pub fn C3D_SetFrameBuf(fb: *mut C3D_FrameBuf);
}
unsafe extern "C" {
    pub fn C3D_FrameBufTex(
        fb: *mut C3D_FrameBuf,
        tex: *mut C3D_Tex,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
    );
}
unsafe extern "C" {
    pub fn C3D_FrameBufClear(
        fb: *mut C3D_FrameBuf,
        clearBits: C3D_ClearBits,
        clearColor: u32_,
        clearDepth: u32_,
    );
}
unsafe extern "C" {
    pub fn C3D_FrameBufTransfer(
        fb: *mut C3D_FrameBuf,
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        transferFlags: u32_,
    );
}
unsafe extern "C" {
    #[link_name = "C3D_FrameBufAttrib__extern"]
    pub fn C3D_FrameBufAttrib(fb: *mut C3D_FrameBuf, width: u16_, height: u16_, block32: bool);
}
unsafe extern "C" {
    #[link_name = "C3D_FrameBufColor__extern"]
    pub fn C3D_FrameBufColor(fb: *mut C3D_FrameBuf, buf: *mut ::libc::c_void, fmt: GPU_COLORBUF);
}
unsafe extern "C" {
    #[link_name = "C3D_FrameBufDepth__extern"]
    pub fn C3D_FrameBufDepth(fb: *mut C3D_FrameBuf, buf: *mut ::libc::c_void, fmt: GPU_DEPTHBUF);
}
pub type C3D_RenderTarget = C3D_RenderTarget_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_RenderTarget_tag {
    pub next: *mut C3D_RenderTarget,
    pub prev: *mut C3D_RenderTarget,
    pub frameBuf: C3D_FrameBuf,
    pub used: bool,
    pub ownsColor: bool,
    pub ownsDepth: bool,
    pub linked: bool,
    pub screen: gfxScreen_t,
    pub side: gfx3dSide_t,
    pub transferFlags: u32_,
}
pub const C3D_FRAME_SYNCDRAW: _bindgen_ty_44 = 1;
pub const C3D_FRAME_NONBLOCK: _bindgen_ty_44 = 2;
pub type _bindgen_ty_44 = ::libc::c_uchar;
unsafe extern "C" {
    pub fn C3D_FrameRate(fps: f32) -> f32;
}
unsafe extern "C" {
    pub fn C3D_FrameSync();
}
unsafe extern "C" {
    pub fn C3D_FrameCounter(id: ::libc::c_int) -> u32_;
}
unsafe extern "C" {
    pub fn C3D_FrameBegin(flags: u8_) -> bool;
}
unsafe extern "C" {
    pub fn C3D_FrameDrawOn(target: *mut C3D_RenderTarget) -> bool;
}
unsafe extern "C" {
    pub fn C3D_FrameSplit(flags: u8_);
}
unsafe extern "C" {
    pub fn C3D_FrameEnd(flags: u8_);
}
unsafe extern "C" {
    pub fn C3D_FrameEndHook(
        hook: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
        param: *mut ::libc::c_void,
    );
}
unsafe extern "C" {
    pub fn C3D_GetDrawingTime() -> f32;
}
unsafe extern "C" {
    pub fn C3D_GetProcessingTime() -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_DEPTHTYPE {
    pub __i: ::libc::c_int,
    pub __e: GPU_DEPTHBUF,
}
unsafe extern "C" {
    pub fn C3D_RenderTargetCreate(
        width: ::libc::c_int,
        height: ::libc::c_int,
        colorFmt: GPU_COLORBUF,
        depthFmt: C3D_DEPTHTYPE,
    ) -> *mut C3D_RenderTarget;
}
unsafe extern "C" {
    pub fn C3D_RenderTargetCreateFromTex(
        tex: *mut C3D_Tex,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
        depthFmt: C3D_DEPTHTYPE,
    ) -> *mut C3D_RenderTarget;
}
unsafe extern "C" {
    pub fn C3D_RenderTargetDelete(target: *mut C3D_RenderTarget);
}
unsafe extern "C" {
    pub fn C3D_RenderTargetSetOutput(
        target: *mut C3D_RenderTarget,
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        transferFlags: u32_,
    );
}
unsafe extern "C" {
    #[link_name = "C3D_RenderTargetDetachOutput__extern"]
    pub fn C3D_RenderTargetDetachOutput(target: *mut C3D_RenderTarget);
}
unsafe extern "C" {
    #[link_name = "C3D_RenderTargetClear__extern"]
    pub fn C3D_RenderTargetClear(
        target: *mut C3D_RenderTarget,
        clearBits: C3D_ClearBits,
        clearColor: u32_,
        clearDepth: u32_,
    );
}
unsafe extern "C" {
    pub fn C3D_SyncDisplayTransfer(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        flags: u32_,
    );
}
unsafe extern "C" {
    pub fn C3D_SyncTextureCopy(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        size: u32_,
        flags: u32_,
    );
}
unsafe extern "C" {
    pub fn C3D_SyncMemoryFill(
        buf0a: *mut u32_,
        buf0v: u32_,
        buf0e: *mut u32_,
        control0: u16_,
        buf1a: *mut u32_,
        buf1v: u32_,
        buf1e: *mut u32_,
        control1: u16_,
    );
}
#[doc = "Subtexture\n > **Note:** If top < bottom, the subtexture is rotated 1/4 revolution counter-clockwise"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tex3DS_SubTexture {
    #[doc = "< Sub-texture width (pixels)"]
    pub width: u16_,
    #[doc = "< Sub-texture height (pixels)"]
    pub height: u16_,
    #[doc = "< Left u-coordinate"]
    pub left: f32,
    #[doc = "< Top v-coordinate"]
    pub top: f32,
    #[doc = "< Right u-coordinate"]
    pub right: f32,
    #[doc = "< Bottom v-coordinate"]
    pub bottom: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tex3DS_Texture_s {
    _unused: [u8; 0],
}
#[doc = "Texture"]
pub type Tex3DS_Texture = *mut Tex3DS_Texture_s;
unsafe extern "C" {
    #[doc = "Import Tex3DS texture\n # Arguments\n\n* `input` (direction in) - Input data\n * `insize` (direction in) - Size of the input data\n * `tex` (direction out) - citro3d texture\n * `texcube` (direction out) - citro3d texcube\n * `vram` (direction in) - Whether to store textures in VRAM\n # Returns\n\nTex3DS texture"]
    pub fn Tex3DS_TextureImport(
        input: *const ::libc::c_void,
        insize: usize,
        tex: *mut C3D_Tex,
        texcube: *mut C3D_TexCube,
        vram: bool,
    ) -> Tex3DS_Texture;
}
unsafe extern "C" {
    #[doc = "Import Tex3DS texture\n\n For example, use this if you want to import from a large file without\n pulling the entire file into memory.\n\n # Arguments\n\n* `tex` (direction out) - citro3d texture\n * `texcube` (direction out) - citro3d texcube\n * `vram` (direction in) - Whether to store textures in VRAM\n * `callback` (direction in) - Data callback\n * `userdata` (direction in) - User data passed to callback\n # Returns\n\nTex3DS texture"]
    pub fn Tex3DS_TextureImportCallback(
        tex: *mut C3D_Tex,
        texcube: *mut C3D_TexCube,
        vram: bool,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
    ) -> Tex3DS_Texture;
}
unsafe extern "C" {
    #[doc = "Import Tex3DS texture\n\n Starts reading at the current file descriptor's offset. The file\n descriptor's position is left at the end of the decoded data. On error, the\n file descriptor's position is indeterminate.\n\n # Arguments\n\n* `fd` (direction in) - Open file descriptor\n * `tex` (direction out) - citro3d texture\n * `texcube` (direction out) - citro3d texcube\n * `vram` (direction in) - Whether to store textures in VRAM\n # Returns\n\nTex3DS texture"]
    pub fn Tex3DS_TextureImportFD(
        fd: ::libc::c_int,
        tex: *mut C3D_Tex,
        texcube: *mut C3D_TexCube,
        vram: bool,
    ) -> Tex3DS_Texture;
}
unsafe extern "C" {
    #[doc = "Import Tex3DS texture\n\n Starts reading at the current file stream's offset. The file stream's\n position is left at the end of the decoded data. On error, the file\n stream's position is indeterminate.\n\n # Arguments\n\n* `fp` (direction in) - Open file stream\n * `tex` (direction out) - citro3d texture\n * `texcube` (direction out) - citro3d texcube\n * `vram` (direction in) - Whether to store textures in VRAM\n # Returns\n\nTex3DS texture"]
    pub fn Tex3DS_TextureImportStdio(
        fp: *mut FILE,
        tex: *mut C3D_Tex,
        texcube: *mut C3D_TexCube,
        vram: bool,
    ) -> Tex3DS_Texture;
}
unsafe extern "C" {
    #[doc = "Get number of subtextures\n # Arguments\n\n* `texture` (direction in) - Tex3DS texture\n # Returns\n\nNumber of subtextures"]
    pub fn Tex3DS_GetNumSubTextures(texture: Tex3DS_Texture) -> usize;
}
unsafe extern "C" {
    #[doc = "Get subtexture\n # Arguments\n\n* `texture` (direction in) - Tex3DS texture\n * `index` (direction in) - Subtexture index\n # Returns\n\nSubtexture info"]
    pub fn Tex3DS_GetSubTexture(texture: Tex3DS_Texture, index: usize) -> *const Tex3DS_SubTexture;
}
unsafe extern "C" {
    #[doc = "Check if subtexture is rotated\n # Arguments\n\n* `subtex` (direction in) - Subtexture to check\n # Returns\n\nwhether subtexture is rotated"]
    #[link_name = "Tex3DS_SubTextureRotated__extern"]
    pub fn Tex3DS_SubTextureRotated(subtex: *const Tex3DS_SubTexture) -> bool;
}
unsafe extern "C" {
    #[doc = "Get bottom-left texcoords\n # Arguments\n\n* `subtex` (direction in) - Subtexture\n * `u` (direction out) - u-coordinate\n * `v` (direction out) - v-coordinate"]
    #[link_name = "Tex3DS_SubTextureBottomLeft__extern"]
    pub fn Tex3DS_SubTextureBottomLeft(subtex: *const Tex3DS_SubTexture, u: *mut f32, v: *mut f32);
}
unsafe extern "C" {
    #[doc = "Get bottom-right texcoords\n # Arguments\n\n* `subtex` (direction in) - Subtexture\n * `u` (direction out) - u-coordinate\n * `v` (direction out) - v-coordinate"]
    #[link_name = "Tex3DS_SubTextureBottomRight__extern"]
    pub fn Tex3DS_SubTextureBottomRight(subtex: *const Tex3DS_SubTexture, u: *mut f32, v: *mut f32);
}
unsafe extern "C" {
    #[doc = "Get top-left texcoords\n # Arguments\n\n* `subtex` (direction in) - Subtexture\n * `u` (direction out) - u-coordinate\n * `v` (direction out) - v-coordinate"]
    #[link_name = "Tex3DS_SubTextureTopLeft__extern"]
    pub fn Tex3DS_SubTextureTopLeft(subtex: *const Tex3DS_SubTexture, u: *mut f32, v: *mut f32);
}
unsafe extern "C" {
    #[doc = "Get top-right texcoords\n # Arguments\n\n* `subtex` (direction in) - Subtexture\n * `u` (direction out) - u-coordinate\n * `v` (direction out) - v-coordinate"]
    #[link_name = "Tex3DS_SubTextureTopRight__extern"]
    pub fn Tex3DS_SubTextureTopRight(subtex: *const Tex3DS_SubTexture, u: *mut f32, v: *mut f32);
}
unsafe extern "C" {
    #[doc = "Free Tex3DS texture\n # Arguments\n\n* `texture` (direction in) - Tex3DS texture to free"]
    pub fn Tex3DS_TextureFree(texture: Tex3DS_Texture);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_DrawParams {
    pub pos: C2D_DrawParams__bindgen_ty_1,
    pub center: C2D_DrawParams__bindgen_ty_2,
    pub depth: f32,
    pub angle: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_DrawParams__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_DrawParams__bindgen_ty_2 {
    pub x: f32,
    pub y: f32,
}
#[doc = "< Plain solid tint color"]
pub const C2D_TintSolid: C2D_TintMode = 0;
#[doc = "< Tint color multiplied by texture color"]
pub const C2D_TintMult: C2D_TintMode = 1;
#[doc = "< Tint color multiplied by grayscale converted texture color"]
pub const C2D_TintLuma: C2D_TintMode = 2;
pub type C2D_TintMode = ::libc::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Tint {
    #[doc = "< RGB tint color and Alpha transparency"]
    pub color: u32_,
    #[doc = "< Blending strength of the tint color (0.0~1.0)"]
    pub blend: f32,
}
#[doc = "< Top left corner"]
pub const C2D_TopLeft: C2D_Corner = 0;
#[doc = "< Top right corner"]
pub const C2D_TopRight: C2D_Corner = 1;
#[doc = "< Bottom left corner"]
pub const C2D_BotLeft: C2D_Corner = 2;
#[doc = "< Bottom right corner"]
pub const C2D_BotRight: C2D_Corner = 3;
pub type C2D_Corner = ::libc::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Image {
    pub tex: *mut C3D_Tex,
    pub subtex: *const Tex3DS_SubTexture,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_ImageTint {
    pub corners: [C2D_Tint; 4usize],
}
unsafe extern "C" {
    #[doc = "Clamps a value between bounds\n # Arguments\n\n* `x` (direction in) - The value to clamp\n * `min` (direction in) - The lower bound\n * `max` (direction in) - The upper bound\n # Returns\n\nThe clamped value"]
    #[link_name = "C2D_Clamp__extern"]
    pub fn C2D_Clamp(x: f32, min: f32, max: f32) -> f32;
}
unsafe extern "C" {
    #[doc = "Converts a float to u8\n # Arguments\n\n* `x` (direction in) - Input value (0.0~1.0)\n # Returns\n\nOutput value (0~255)"]
    #[link_name = "C2D_FloatToU8__extern"]
    pub fn C2D_FloatToU8(x: f32) -> u8_;
}
unsafe extern "C" {
    #[doc = "Builds a 32-bit RGBA color value\n # Arguments\n\n* `r` (direction in) - Red component (0~255)\n * `g` (direction in) - Green component (0~255)\n * `b` (direction in) - Blue component (0~255)\n * `a` (direction in) - Alpha component (0~255)\n # Returns\n\nThe 32-bit RGBA color value"]
    #[link_name = "C2D_Color32__extern"]
    pub fn C2D_Color32(r: u8_, g: u8_, b: u8_, a: u8_) -> u32_;
}
unsafe extern "C" {
    #[doc = "Builds a 32-bit RGBA color value from float values\n # Arguments\n\n* `r` (direction in) - Red component (0.0~1.0)\n * `g` (direction in) - Green component (0.0~1.0)\n * `b` (direction in) - Blue component (0.0~1.0)\n * `a` (direction in) - Alpha component (0.0~1.0)\n # Returns\n\nThe 32-bit RGBA color value"]
    #[link_name = "C2D_Color32f__extern"]
    pub fn C2D_Color32f(r: f32, g: f32, b: f32, a: f32) -> u32_;
}
unsafe extern "C" {
    #[doc = "Configures one corner of an image tint structure\n # Arguments\n\n* `tint` (direction in) - Image tint structure\n * `corner` (direction in) - The corner of the image to tint\n * `color` (direction in) - RGB tint color and Alpha transparency\n * `blend` (direction in) - Blending strength of the tint color (0.0~1.0)"]
    #[link_name = "C2D_SetImageTint__extern"]
    pub fn C2D_SetImageTint(tint: *mut C2D_ImageTint, corner: C2D_Corner, color: u32_, blend: f32);
}
unsafe extern "C" {
    #[doc = "Configures an image tint structure with the specified tint parameters applied to all corners\n # Arguments\n\n* `tint` (direction in) - Image tint structure\n * `color` (direction in) - RGB tint color and Alpha transparency\n * `blend` (direction in) - Blending strength of the tint color (0.0~1.0)"]
    #[link_name = "C2D_PlainImageTint__extern"]
    pub fn C2D_PlainImageTint(tint: *mut C2D_ImageTint, color: u32_, blend: f32);
}
unsafe extern "C" {
    #[doc = "Configures an image tint structure to just apply transparency to the image\n # Arguments\n\n* `tint` (direction in) - Image tint structure\n * `alpha` (direction in) - Alpha transparency value to apply to the image"]
    #[link_name = "C2D_AlphaImageTint__extern"]
    pub fn C2D_AlphaImageTint(tint: *mut C2D_ImageTint, alpha: f32);
}
unsafe extern "C" {
    #[doc = "Configures an image tint structure with the specified tint parameters applied to the top side (e.g. for gradients)\n # Arguments\n\n* `tint` (direction in) - Image tint structure\n * `color` (direction in) - RGB tint color and Alpha transparency\n * `blend` (direction in) - Blending strength of the tint color (0.0~1.0)"]
    #[link_name = "C2D_TopImageTint__extern"]
    pub fn C2D_TopImageTint(tint: *mut C2D_ImageTint, color: u32_, blend: f32);
}
unsafe extern "C" {
    #[doc = "Configures an image tint structure with the specified tint parameters applied to the bottom side (e.g. for gradients)\n # Arguments\n\n* `tint` (direction in) - Image tint structure\n * `color` (direction in) - RGB tint color and Alpha transparency\n * `blend` (direction in) - Blending strength of the tint color (0.0~1.0)"]
    #[link_name = "C2D_BottomImageTint__extern"]
    pub fn C2D_BottomImageTint(tint: *mut C2D_ImageTint, color: u32_, blend: f32);
}
unsafe extern "C" {
    #[doc = "Configures an image tint structure with the specified tint parameters applied to the left side (e.g. for gradients)\n # Arguments\n\n* `tint` (direction in) - Image tint structure\n * `color` (direction in) - RGB tint color and Alpha transparency\n * `blend` (direction in) - Blending strength of the tint color (0.0~1.0)"]
    #[link_name = "C2D_LeftImageTint__extern"]
    pub fn C2D_LeftImageTint(tint: *mut C2D_ImageTint, color: u32_, blend: f32);
}
unsafe extern "C" {
    #[doc = "Configures an image tint structure with the specified tint parameters applied to the right side (e.g. for gradients)\n # Arguments\n\n* `tint` (direction in) - Image tint structure\n * `color` (direction in) - RGB tint color and Alpha transparency\n * `blend` (direction in) - Blending strength of the tint color (0.0~1.0)"]
    #[link_name = "C2D_RightImageTint__extern"]
    pub fn C2D_RightImageTint(tint: *mut C2D_ImageTint, color: u32_, blend: f32);
}
unsafe extern "C" {
    #[doc = "Initialize citro2d\n # Arguments\n\n* `maxObjects` (direction in) - Maximum number of 2D objects that can be drawn per frame.\n > Pass C2D_DEFAULT_MAX_OBJECTS as a starting point.\n # Returns\n\ntrue on success, false on failure"]
    pub fn C2D_Init(maxObjects: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Deinitialize citro2d"]
    pub fn C2D_Fini();
}
unsafe extern "C" {
    #[doc = "Prepares the GPU for rendering 2D content\n > This needs to be done only once in the program if citro2d is the sole user of the GPU."]
    pub fn C2D_Prepare();
}
unsafe extern "C" {
    #[doc = "Ensures all 2D objects so far have been drawn"]
    pub fn C2D_Flush();
}
unsafe extern "C" {
    #[doc = "Configures the size of the 2D scene.\n # Arguments\n\n* `width` (direction in) - The width of the scene, in pixels.\n * `height` (direction in) - The height of the scene, in pixels.\n * `tilt` (direction in) - Whether the scene is tilted like the 3DS's sideways screens."]
    pub fn C2D_SceneSize(width: u32_, height: u32_, tilt: bool);
}
unsafe extern "C" {
    #[doc = "Configures the size of the 2D scene to match that of the specified render target.\n # Arguments\n\n* `target` (direction in) - Render target"]
    #[link_name = "C2D_SceneTarget__extern"]
    pub fn C2D_SceneTarget(target: *mut C3D_RenderTarget);
}
unsafe extern "C" {
    #[doc = "Resets the model transformation matrix."]
    pub fn C2D_ViewReset();
}
unsafe extern "C" {
    #[doc = "Saves the current model transformation matrix.\n # Arguments\n\n* `matrix` (direction out) - Pointer to save the current matrix to"]
    pub fn C2D_ViewSave(matrix: *mut C3D_Mtx);
}
unsafe extern "C" {
    #[doc = "Restores a previously saved model transformation matrix.\n # Arguments\n\n* `matrix` (direction in) - Pointer to matrix to restor"]
    pub fn C2D_ViewRestore(matrix: *const C3D_Mtx);
}
unsafe extern "C" {
    #[doc = "Translates everything drawn via the model matrix.\n # Arguments\n\n* `x` (direction in) - Translation in the x direction\n * `y` (direction in) - Translation in the y direction"]
    pub fn C2D_ViewTranslate(x: f32, y: f32);
}
unsafe extern "C" {
    #[doc = "Rotates everything drawn via the model matrix.\n # Arguments\n\n* `rotation` (direction in) - Rotation in the counterclockwise direction in radians"]
    pub fn C2D_ViewRotate(rotation: f32);
}
unsafe extern "C" {
    #[doc = "Rotates everything drawn via the model matrix.\n # Arguments\n\n* `rotation` (direction in) - Rotation in the counterclockwise direction in degrees"]
    #[link_name = "C2D_ViewRotateDegrees__extern"]
    pub fn C2D_ViewRotateDegrees(rotation: f32);
}
unsafe extern "C" {
    #[doc = "Shears everything drawn via the model matrix.\n # Arguments\n\n* `x` (direction in) - Shear factor in the x direction\n * `y` (direction in) - Shear factor in the y direction"]
    pub fn C2D_ViewShear(x: f32, y: f32);
}
unsafe extern "C" {
    #[doc = "Scales everything drawn via the model matrix.\n # Arguments\n\n* `x` (direction in) - Scale factor in the x direction\n * `y` (direction in) - Scale factor in the y direction"]
    pub fn C2D_ViewScale(x: f32, y: f32);
}
unsafe extern "C" {
    #[doc = "Helper function to create a render target for a screen\n # Arguments\n\n* `screen` (direction in) - Screen (GFX_TOP or GFX_BOTTOM)\n * `side` (direction in) - Side (GFX_LEFT or GFX_RIGHT)\n # Returns\n\ncitro3d render target object"]
    pub fn C2D_CreateScreenTarget(screen: gfxScreen_t, side: gfx3dSide_t) -> *mut C3D_RenderTarget;
}
unsafe extern "C" {
    #[doc = "Helper function to clear a rendertarget using the specified color\n # Arguments\n\n* `target` (direction in) - Render target to clear\n * `color` (direction in) - 32-bit RGBA color value to fill the target with"]
    pub fn C2D_TargetClear(target: *mut C3D_RenderTarget, color: u32_);
}
unsafe extern "C" {
    #[doc = "Helper function to begin drawing a 2D scene on a render target\n # Arguments\n\n* `target` (direction in) - Render target to draw the 2D scene to"]
    #[link_name = "C2D_SceneBegin__extern"]
    pub fn C2D_SceneBegin(target: *mut C3D_RenderTarget);
}
unsafe extern "C" {
    #[doc = "Configures the fading color\n # Arguments\n\n* `color` (direction in) - 32-bit RGBA color value to be used as the fading color (0 by default)\n > The alpha component of the color is used as the strength of the fading color.\n If alpha is zero, the fading color has no effect. If it is the highest value,\n the rendered pixels will all have the fading color. Everything inbetween is\n rendered as a blend of the original pixel color and the fading color."]
    pub fn C2D_Fade(color: u32_);
}
unsafe extern "C" {
    #[doc = "Configures the formula used to calculate the tinted texture color\n # Arguments\n\n* `mode` (direction in) - Tinting mode\n > Texture tinting works by linearly interpolating between the regular texture color\n and the tinted texture color according to the blending strength parameter.\n This function can be used to change how the tinted texture color is precisely\n calculated, refer to C2D_TintMode for a list of available tinting modes."]
    pub fn C2D_SetTintMode(mode: C2D_TintMode);
}
unsafe extern "C" {
    #[doc = "Draws an image using the GPU (variant accepting C2D_DrawParams)\n # Arguments\n\n* `img` (direction in) - Handle of the image to draw\n * `params` (direction in) - Parameters with which to draw the image\n * `tint` (direction in) - Tint parameters to apply to the image (optional, can be null)\n # Returns\n\ntrue on success, false on failure"]
    pub fn C2D_DrawImage(
        img: C2D_Image,
        params: *const C2D_DrawParams,
        tint: *const C2D_ImageTint,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Draws an image using the GPU (variant accepting position/scaling)\n # Arguments\n\n* `img` (direction in) - Handle of the image to draw\n * `x` (direction in) - X coordinate at which to place the top left corner of the image\n * `y` (direction in) - Y coordinate at which to place the top left corner of the image\n * `depth` (direction in) - Depth value to draw the image with\n * `tint` (direction in) - Tint parameters to apply to the image (optional, can be null)\n * `scaleX` (direction in) - Horizontal scaling factor to apply to the image (optional, by default 1.0f); negative values apply a horizontal flip\n * `scaleY` (direction in) - Vertical scaling factor to apply to the image (optional, by default 1.0f); negative values apply a vertical flip"]
    #[link_name = "C2D_DrawImageAt__extern"]
    pub fn C2D_DrawImageAt(
        img: C2D_Image,
        x: f32,
        y: f32,
        depth: f32,
        tint: *const C2D_ImageTint,
        scaleX: f32,
        scaleY: f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Draws an image using the GPU (variant accepting position/scaling/rotation)\n # Arguments\n\n* `img` (direction in) - Handle of the image to draw\n * `x` (direction in) - X coordinate at which to place the center of the image\n * `y` (direction in) - Y coordinate at which to place the center of the image\n * `depth` (direction in) - Depth value to draw the image with\n * `angle` (direction in) - Angle (in radians) to rotate the image by, counter-clockwise\n * `tint` (direction in) - Tint parameters to apply to the image (optional, can be null)\n * `scaleX` (direction in) - Horizontal scaling factor to apply to the image (optional, by default 1.0f); negative values apply a horizontal flip\n * `scaleY` (direction in) - Vertical scaling factor to apply to the image (optional, by default 1.0f); negative values apply a vertical flip"]
    #[link_name = "C2D_DrawImageAtRotated__extern"]
    pub fn C2D_DrawImageAtRotated(
        img: C2D_Image,
        x: f32,
        y: f32,
        depth: f32,
        angle: f32,
        tint: *const C2D_ImageTint,
        scaleX: f32,
        scaleY: f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Draws a plain triangle using the GPU\n # Arguments\n\n* `x0` (direction in) - X coordinate of the first vertex of the triangle\n * `y0` (direction in) - Y coordinate of the first vertex of the triangle\n * `clr0` (direction in) - 32-bit RGBA color of the first vertex of the triangle\n * `x1` (direction in) - X coordinate of the second vertex of the triangle\n * `y1` (direction in) - Y coordinate of the second vertex of the triangle\n * `clr1` (direction in) - 32-bit RGBA color of the second vertex of the triangle\n * `x2` (direction in) - X coordinate of the third vertex of the triangle\n * `y2` (direction in) - Y coordinate of the third vertex of the triangle\n * `clr2` (direction in) - 32-bit RGBA color of the third vertex of the triangle\n * `depth` (direction in) - Depth value to draw the triangle with"]
    pub fn C2D_DrawTriangle(
        x0: f32,
        y0: f32,
        clr0: u32_,
        x1: f32,
        y1: f32,
        clr1: u32_,
        x2: f32,
        y2: f32,
        clr2: u32_,
        depth: f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Draws a plain line using the GPU\n # Arguments\n\n* `x0` (direction in) - X coordinate of the first vertex of the line\n * `y0` (direction in) - Y coordinate of the first vertex of the line\n * `clr0` (direction in) - 32-bit RGBA color of the first vertex of the line\n * `x1` (direction in) - X coordinate of the second vertex of the line\n * `y1` (direction in) - Y coordinate of the second vertex of the line\n * `clr1` (direction in) - 32-bit RGBA color of the second vertex of the line\n * `thickness` (direction in) - Thickness, in pixels, of the line\n * `depth` (direction in) - Depth value to draw the line with"]
    pub fn C2D_DrawLine(
        x0: f32,
        y0: f32,
        clr0: u32_,
        x1: f32,
        y1: f32,
        clr1: u32_,
        thickness: f32,
        depth: f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Draws a plain rectangle using the GPU\n # Arguments\n\n* `x` (direction in) - X coordinate of the top-left vertex of the rectangle\n * `y` (direction in) - Y coordinate of the top-left vertex of the rectangle\n * `z` (direction in) - Z coordinate (depth value) to draw the rectangle with\n * `w` (direction in) - Width of the rectangle\n * `h` (direction in) - Height of the rectangle\n * `clr0` (direction in) - 32-bit RGBA color of the top-left corner of the rectangle\n * `clr1` (direction in) - 32-bit RGBA color of the top-right corner of the rectangle\n * `clr2` (direction in) - 32-bit RGBA color of the bottom-left corner of the rectangle\n * `clr3` (direction in) - 32-bit RGBA color of the bottom-right corner of the rectangle"]
    pub fn C2D_DrawRectangle(
        x: f32,
        y: f32,
        z: f32,
        w: f32,
        h: f32,
        clr0: u32_,
        clr1: u32_,
        clr2: u32_,
        clr3: u32_,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Draws a plain rectangle using the GPU (with a solid color)\n # Arguments\n\n* `x` (direction in) - X coordinate of the top-left vertex of the rectangle\n * `y` (direction in) - Y coordinate of the top-left vertex of the rectangle\n * `z` (direction in) - Z coordinate (depth value) to draw the rectangle with\n * `w` (direction in) - Width of the rectangle\n * `h` (direction in) - Height of the rectangle\n * `clr` (direction in) - 32-bit RGBA color of the rectangle"]
    #[link_name = "C2D_DrawRectSolid__extern"]
    pub fn C2D_DrawRectSolid(x: f32, y: f32, z: f32, w: f32, h: f32, clr: u32_) -> bool;
}
unsafe extern "C" {
    #[doc = "Draws an ellipse using the GPU\n # Arguments\n\n* `x` (direction in) - X coordinate of the top-left vertex of the ellipse\n * `y` (direction in) - Y coordinate of the top-left vertex of the ellipse\n * `z` (direction in) - Z coordinate (depth value) to draw the ellipse with\n * `w` (direction in) - Width of the ellipse\n * `h` (direction in) - Height of the ellipse\n * `clr0` (direction in) - 32-bit RGBA color of the top-left corner of the ellipse\n * `clr1` (direction in) - 32-bit RGBA color of the top-right corner of the ellipse\n * `clr2` (direction in) - 32-bit RGBA color of the bottom-left corner of the ellipse\n * `clr3` (direction in) - 32-bit RGBA color of the bottom-right corner of the ellipse\n > **Note:** Switching to and from \"circle mode\" internally requires an expensive state change. As such, the recommended usage of this feature is to draw all non-circular objects first, then draw all circular objects."]
    pub fn C2D_DrawEllipse(
        x: f32,
        y: f32,
        z: f32,
        w: f32,
        h: f32,
        clr0: u32_,
        clr1: u32_,
        clr2: u32_,
        clr3: u32_,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Draws a ellipse using the GPU (with a solid color)\n # Arguments\n\n* `x` (direction in) - X coordinate of the top-left vertex of the ellipse\n * `y` (direction in) - Y coordinate of the top-left vertex of the ellipse\n * `z` (direction in) - Z coordinate (depth value) to draw the ellipse with\n * `w` (direction in) - Width of the ellipse\n * `h` (direction in) - Height of the ellipse\n * `clr` (direction in) - 32-bit RGBA color of the ellipse\n > **Note:** Switching to and from \"circle mode\" internally requires an expensive state change. As such, the recommended usage of this feature is to draw all non-circular objects first, then draw all circular objects."]
    #[link_name = "C2D_DrawEllipseSolid__extern"]
    pub fn C2D_DrawEllipseSolid(x: f32, y: f32, z: f32, w: f32, h: f32, clr: u32_) -> bool;
}
unsafe extern "C" {
    #[doc = "Draws a circle (an ellipse with identical width and height) using the GPU\n # Arguments\n\n* `x` (direction in) - X coordinate of the center of the circle\n * `y` (direction in) - Y coordinate of the center of the circle\n * `z` (direction in) - Z coordinate (depth value) to draw the ellipse with\n * `radius` (direction in) - Radius of the circle\n * `clr0` (direction in) - 32-bit RGBA color of the top-left corner of the ellipse\n * `clr1` (direction in) - 32-bit RGBA color of the top-right corner of the ellipse\n * `clr2` (direction in) - 32-bit RGBA color of the bottom-left corner of the ellipse\n * `clr3` (direction in) - 32-bit RGBA color of the bottom-right corner of the ellipse\n > **Note:** Switching to and from \"circle mode\" internally requires an expensive state change. As such, the recommended usage of this feature is to draw all non-circular objects first, then draw all circular objects."]
    #[link_name = "C2D_DrawCircle__extern"]
    pub fn C2D_DrawCircle(
        x: f32,
        y: f32,
        z: f32,
        radius: f32,
        clr0: u32_,
        clr1: u32_,
        clr2: u32_,
        clr3: u32_,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Draws a circle (an ellipse with identical width and height) using the GPU (with a solid color)\n # Arguments\n\n* `x` (direction in) - X coordinate of the center of the circle\n * `y` (direction in) - Y coordinate of the center of the circle\n * `z` (direction in) - Z coordinate (depth value) to draw the ellipse with\n * `radius` (direction in) - Radius of the circle\n * `clr` (direction in) - 32-bit RGBA color of the ellipse\n > **Note:** Switching to and from \"circle mode\" internally requires an expensive state change. As such, the recommended usage of this feature is to draw all non-circular objects first, then draw all circular objects."]
    #[link_name = "C2D_DrawCircleSolid__extern"]
    pub fn C2D_DrawCircleSolid(x: f32, y: f32, z: f32, radius: f32, clr: u32_) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_SpriteSheet_s {
    _unused: [u8; 0],
}
pub type C2D_SpriteSheet = *mut C2D_SpriteSheet_s;
unsafe extern "C" {
    #[doc = "Load a sprite sheet from file\n # Arguments\n\n* `filename` (direction in) - Name of the sprite sheet file (.t3x)\n # Returns\n\nSprite sheet handle\n * `NULL` - Error"]
    pub fn C2D_SpriteSheetLoad(filename: *const ::libc::c_char) -> C2D_SpriteSheet;
}
unsafe extern "C" {
    #[doc = "Load a sprite sheet from memory\n # Arguments\n\n* `data` (direction in) - Data to load\n * `size` (direction in) - Size of the data to load\n # Returns\n\nSprite sheet handle\n * `NULL` - Error"]
    pub fn C2D_SpriteSheetLoadFromMem(data: *const ::libc::c_void, size: usize) -> C2D_SpriteSheet;
}
unsafe extern "C" {
    #[doc = "Load sprite sheet from file descriptor\n # Arguments\n\n* `fd` (direction in) - File descriptor used to load data\n # Returns\n\nSprite sheet handle\n * `NULL` - Error"]
    pub fn C2D_SpriteSheetFromFD(fd: ::libc::c_int) -> C2D_SpriteSheet;
}
unsafe extern "C" {
    #[doc = "Load sprite sheet from stdio file handle\n # Arguments\n\n* `f` (direction in) - File handle used to load data\n # Returns\n\nSprite sheet handle\n * `NULL` - Error"]
    pub fn C2D_SpriteSheetLoadFromHandle(f: *mut FILE) -> C2D_SpriteSheet;
}
unsafe extern "C" {
    #[doc = "Free a sprite sheet\n # Arguments\n\n* `sheet` (direction in) - Sprite sheet handle"]
    pub fn C2D_SpriteSheetFree(sheet: C2D_SpriteSheet);
}
unsafe extern "C" {
    #[doc = "Retrieves the number of sprites in the specified sprite sheet\n # Arguments\n\n* `sheet` (direction in) - Sprite sheet handle\n # Returns\n\nNumber of sprites"]
    pub fn C2D_SpriteSheetCount(sheet: C2D_SpriteSheet) -> usize;
}
unsafe extern "C" {
    #[doc = "Retrieves the specified image from the specified sprite sheet\n # Arguments\n\n* `sheet` (direction in) - Sprite sheet handle\n * `index` (direction in) - Index of the image to retrieve\n # Returns\n\nImage object"]
    pub fn C2D_SpriteSheetGetImage(sheet: C2D_SpriteSheet, index: usize) -> C2D_Image;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Sprite {
    pub image: C2D_Image,
    pub params: C2D_DrawParams,
}
unsafe extern "C" {
    #[doc = "Initializes a sprite from an image\n # Arguments\n\n* `Pointer` (direction in) - to sprite\n * `image` (direction in) - Image to use"]
    #[link_name = "C2D_SpriteFromImage__extern"]
    pub fn C2D_SpriteFromImage(sprite: *mut C2D_Sprite, image: C2D_Image);
}
unsafe extern "C" {
    #[doc = "Initializes a sprite from an image stored in a sprite sheet\n # Arguments\n\n* `Pointer` (direction in) - to sprite\n * `sheet` (direction in) - Sprite sheet handle\n * `index` (direction in) - Index of the image inside the sprite sheet"]
    #[link_name = "C2D_SpriteFromSheet__extern"]
    pub fn C2D_SpriteFromSheet(sprite: *mut C2D_Sprite, sheet: C2D_SpriteSheet, index: usize);
}
unsafe extern "C" {
    #[doc = "Scale sprite (relative)\n # Arguments\n\n* `sprite` (direction in) - Pointer to sprite\n * `x` (direction in) - X scale (negative values flip the sprite horizontally)\n * `y` (direction in) - Y scale (negative values flip the sprite vertically)"]
    #[link_name = "C2D_SpriteScale__extern"]
    pub fn C2D_SpriteScale(sprite: *mut C2D_Sprite, x: f32, y: f32);
}
unsafe extern "C" {
    #[doc = "Rotate sprite (relative)\n # Arguments\n\n* `sprite` (direction in) - Pointer to sprite\n * `radians` (direction in) - Amount to rotate in radians"]
    #[link_name = "C2D_SpriteRotate__extern"]
    pub fn C2D_SpriteRotate(sprite: *mut C2D_Sprite, radians: f32);
}
unsafe extern "C" {
    #[doc = "Rotate sprite (relative)\n # Arguments\n\n* `sprite` (direction in) - Pointer to sprite\n * `degrees` (direction in) - Amount to rotate in degrees"]
    #[link_name = "C2D_SpriteRotateDegrees__extern"]
    pub fn C2D_SpriteRotateDegrees(sprite: *mut C2D_Sprite, degrees: f32);
}
unsafe extern "C" {
    #[doc = "Move sprite (relative)\n # Arguments\n\n* `sprite` (direction in) - Pointer to sprite\n * `x` (direction in) - X translation\n * `y` (direction in) - Y translation"]
    #[link_name = "C2D_SpriteMove__extern"]
    pub fn C2D_SpriteMove(sprite: *mut C2D_Sprite, x: f32, y: f32);
}
unsafe extern "C" {
    #[doc = "Scale sprite (absolute)\n # Arguments\n\n* `sprite` (direction in) - Pointer to sprite\n * `x` (direction in) - X scale (negative values flip the sprite horizontally)\n * `y` (direction in) - Y scale (negative values flip the sprite vertically)"]
    #[link_name = "C2D_SpriteSetScale__extern"]
    pub fn C2D_SpriteSetScale(sprite: *mut C2D_Sprite, x: f32, y: f32);
}
unsafe extern "C" {
    #[doc = "Rotate sprite (absolute)\n # Arguments\n\n* `sprite` (direction in) - Pointer to sprite\n * `radians` (direction in) - Amount to rotate in radians"]
    #[link_name = "C2D_SpriteSetRotation__extern"]
    pub fn C2D_SpriteSetRotation(sprite: *mut C2D_Sprite, radians: f32);
}
unsafe extern "C" {
    #[doc = "Rotate sprite (absolute)\n # Arguments\n\n* `sprite` (direction in) - Pointer to sprite\n * `degrees` (direction in) - Amount to rotate in degrees"]
    #[link_name = "C2D_SpriteSetRotationDegrees__extern"]
    pub fn C2D_SpriteSetRotationDegrees(sprite: *mut C2D_Sprite, degrees: f32);
}
unsafe extern "C" {
    #[doc = "Set the center of a sprite in values independent of the sprite size (absolute)\n # Arguments\n\n* `sprite` (direction in) - Pointer to sprite\n * `x` (direction in) - X position of the center (0.0 through 1.0)\n * `y` (direction in) - Y position of the center (0.0 through 1.0)"]
    #[link_name = "C2D_SpriteSetCenter__extern"]
    pub fn C2D_SpriteSetCenter(sprite: *mut C2D_Sprite, x: f32, y: f32);
}
unsafe extern "C" {
    #[doc = "Set the center of a sprite in terms of pixels (absolute)\n # Arguments\n\n* `sprite` (direction in) - Pointer to sprite\n * `x` (direction in) - X position of the center (in pixels)\n * `y` (direction in) - Y position of the center (in pixels)"]
    #[link_name = "C2D_SpriteSetCenterRaw__extern"]
    pub fn C2D_SpriteSetCenterRaw(sprite: *mut C2D_Sprite, x: f32, y: f32);
}
unsafe extern "C" {
    #[doc = "Move sprite (absolute)\n # Arguments\n\n* `sprite` (direction in) - Pointer to sprite\n * `x` (direction in) - X position\n * `y` (direction in) - Y position"]
    #[link_name = "C2D_SpriteSetPos__extern"]
    pub fn C2D_SpriteSetPos(sprite: *mut C2D_Sprite, x: f32, y: f32);
}
unsafe extern "C" {
    #[doc = "Sets the depth level of a sprite (absolute)\n # Arguments\n\n* `sprite` (direction in) - Pointer to sprite\n * `depth` (direction in) - Depth value"]
    #[link_name = "C2D_SpriteSetDepth__extern"]
    pub fn C2D_SpriteSetDepth(sprite: *mut C2D_Sprite, depth: f32);
}
unsafe extern "C" {
    #[doc = "Draw sprite\n # Arguments\n\n* `sprite` (direction in) - Sprite to draw"]
    #[link_name = "C2D_DrawSprite__extern"]
    pub fn C2D_DrawSprite(sprite: *const C2D_Sprite) -> bool;
}
unsafe extern "C" {
    #[doc = "Draw sprite with color tinting\n # Arguments\n\n* `sprite` (direction in) - Sprite to draw\n * `tint` (direction in) - Color tinting parameters to apply to the sprite"]
    #[link_name = "C2D_DrawSpriteTinted__extern"]
    pub fn C2D_DrawSpriteTinted(sprite: *const C2D_Sprite, tint: *const C2D_ImageTint) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Font_s {
    _unused: [u8; 0],
}
pub type C2D_Font = *mut C2D_Font_s;
unsafe extern "C" {
    #[doc = "Load a font from a file\n # Arguments\n\n* `filename` (direction in) - Name of the font file (.bcfnt)\n # Returns\n\nFont handle\n * `NULL` - Error"]
    pub fn C2D_FontLoad(filename: *const ::libc::c_char) -> C2D_Font;
}
unsafe extern "C" {
    #[doc = "Load a font from memory\n # Arguments\n\n* `data` (direction in) - Data to load\n * `size` (direction in) - Size of the data to load\n # Returns\n\nFont handle\n * `NULL` - Error"]
    pub fn C2D_FontLoadFromMem(data: *const ::libc::c_void, size: usize) -> C2D_Font;
}
unsafe extern "C" {
    #[doc = "Load a font from file descriptor\n # Arguments\n\n* `fd` (direction in) - File descriptor used to load data\n # Returns\n\nFont handle\n * `NULL` - Error"]
    pub fn C2D_FontLoadFromFD(fd: ::libc::c_int) -> C2D_Font;
}
unsafe extern "C" {
    #[doc = "Load font from stdio file handle\n # Arguments\n\n* `f` (direction in) - File handle used to load data\n # Returns\n\nFont handle\n * `NULL` - Error"]
    pub fn C2D_FontLoadFromHandle(f: *mut FILE) -> C2D_Font;
}
unsafe extern "C" {
    #[doc = "Load corresponding font from system archive\n # Arguments\n\n* `region` (direction in) - Region to get font from\n # Returns\n\nFont handle\n * `NULL` - Error\n > JPN, USA, EUR, and AUS all use the same font."]
    pub fn C2D_FontLoadSystem(region: CFG_Region) -> C2D_Font;
}
unsafe extern "C" {
    #[doc = "Free a font\n # Arguments\n\n* `font` (direction in) - Font handle"]
    pub fn C2D_FontFree(font: C2D_Font);
}
unsafe extern "C" {
    #[doc = "Set a font's texture filter\n # Arguments\n\n* `font` (direction in) - Font handle\n * `magFilter` (direction in) - the magnification filter\n * `minFilter` (direction in) - the minification filter"]
    pub fn C2D_FontSetFilter(
        font: C2D_Font,
        magFilter: GPU_TEXTURE_FILTER_PARAM,
        minFilter: GPU_TEXTURE_FILTER_PARAM,
    );
}
unsafe extern "C" {
    #[doc = "Find the glyph index of a codepoint, or returns the default\n # Arguments\n\n* `font` (direction in) - Font to search, or NULL for system font\n * `codepoint` (direction in) - Codepoint to search for\n # Returns\n\nGlyph index\n * `font->cfnt->finf.alterCharIndex` - The codepoint does not exist in the font"]
    pub fn C2D_FontGlyphIndexFromCodePoint(font: C2D_Font, codepoint: u32_) -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Get character width info for a given index\n # Arguments\n\n* `font` (direction in) - Font to read from, or NULL for system font\n * `glyphIndex` (direction in) - Index to get the width of\n # Returns\n\nWidth info for glyph"]
    pub fn C2D_FontGetCharWidthInfo(
        font: C2D_Font,
        glyphIndex: ::libc::c_int,
    ) -> *mut charWidthInfo_s;
}
unsafe extern "C" {
    #[doc = "Calculate glyph position of given index\n # Arguments\n\n* `font` (direction in) - Font to read from, or NULL for system font\n * `out` (direction out) - Glyph position\n * `glyphIndex` (direction in) - Index to get position of\n * `flags` (direction in) - Misc flags\n * `scaleX` (direction in) - Size to scale in X\n * `scaleY` (direction in) - Size to scale in Y"]
    pub fn C2D_FontCalcGlyphPos(
        font: C2D_Font,
        out: *mut fontGlyphPos_s,
        glyphIndex: ::libc::c_int,
        flags: u32_,
        scaleX: f32,
        scaleY: f32,
    );
}
unsafe extern "C" {
    #[doc = "Get the font info structure associated with the font\n # Arguments\n\n* `font` (direction in) - Font to read from, or NULL for the system font\n # Returns\n\nFINF associated with the font"]
    pub fn C2D_FontGetInfo(font: C2D_Font) -> *mut FINF_s;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_TextBuf_s {
    _unused: [u8; 0],
}
pub type C2D_TextBuf = *mut C2D_TextBuf_s;
#[doc = "Text object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Text {
    #[doc = "< Buffer associated with the text."]
    pub buf: C2D_TextBuf,
    #[doc = "< Reserved for internal use."]
    pub begin: usize,
    #[doc = "< Reserved for internal use."]
    pub end: usize,
    #[doc = "< Width of the text in pixels, according to 1x scale metrics."]
    pub width: f32,
    #[doc = "< Number of lines in the text."]
    pub lines: u32_,
    #[doc = "< Number of words in the text."]
    pub words: u32_,
    #[doc = "< Font used to draw the text, or NULL for system font"]
    pub font: C2D_Font,
}
#[doc = "< Matches the Y coordinate with the baseline of the font."]
pub const C2D_AtBaseline: _bindgen_ty_45 = 1;
#[doc = "< Draws text with color. Requires a u32 color value."]
pub const C2D_WithColor: _bindgen_ty_45 = 2;
#[doc = "< Draws text aligned to the left. This is the default."]
pub const C2D_AlignLeft: _bindgen_ty_45 = 0;
#[doc = "< Draws text aligned to the right."]
pub const C2D_AlignRight: _bindgen_ty_45 = 4;
#[doc = "< Draws text centered."]
pub const C2D_AlignCenter: _bindgen_ty_45 = 8;
#[doc = "< Draws text justified. When C2D_WordWrap is not specified, right edge is x + scaleX*text->width. Otherwise, right edge is x + the width specified for those values."]
pub const C2D_AlignJustified: _bindgen_ty_45 = 12;
#[doc = "< Bitmask for alignment values."]
pub const C2D_AlignMask: _bindgen_ty_45 = 12;
#[doc = "< Draws text with wrapping of full words before specified width. Requires a float value, passed after color if C2D_WithColor is specified."]
pub const C2D_WordWrap: _bindgen_ty_45 = 16;
pub type _bindgen_ty_45 = ::libc::c_uchar;
unsafe extern "C" {
    #[doc = "Creates a new text buffer.\n # Arguments\n\n* `maxGlyphs` (direction in) - Maximum number of glyphs that can be stored in the buffer.\n # Returns\n\nText buffer handle (or NULL on failure)."]
    pub fn C2D_TextBufNew(maxGlyphs: usize) -> C2D_TextBuf;
}
unsafe extern "C" {
    #[doc = "Resizes a text buffer.\n # Arguments\n\n* `buf` (direction in) - Text buffer to resize.\n * `maxGlyphs` (direction in) - Maximum number of glyphs that can be stored in the buffer.\n # Returns\n\nNew text buffer handle (or NULL on failure).\n > If successful, old text buffer handle becomes invalid."]
    pub fn C2D_TextBufResize(buf: C2D_TextBuf, maxGlyphs: usize) -> C2D_TextBuf;
}
unsafe extern "C" {
    #[doc = "Deletes a text buffer.\n # Arguments\n\n* `buf` (direction in) - Text buffer handle.\n > This also invalidates all text objects previously created with this buffer."]
    pub fn C2D_TextBufDelete(buf: C2D_TextBuf);
}
unsafe extern "C" {
    #[doc = "Clears all stored text in a buffer.\n # Arguments\n\n* `buf` (direction in) - Text buffer handle."]
    pub fn C2D_TextBufClear(buf: C2D_TextBuf);
}
unsafe extern "C" {
    #[doc = "Retrieves the number of glyphs stored in a text buffer.\n # Arguments\n\n* `buf` (direction in) - Text buffer handle.\n # Returns\n\nThe number of glyphs."]
    pub fn C2D_TextBufGetNumGlyphs(buf: C2D_TextBuf) -> usize;
}
unsafe extern "C" {
    #[doc = "Parses and adds a single line of text to a text buffer.\n # Arguments\n\n* `text` (direction out) - Pointer to text object to store information in.\n * `buf` (direction in) - Text buffer handle.\n * `str` (direction in) - String to parse.\n * `lineNo` (direction in) - Line number assigned to the text (used to calculate vertical position).\n > Whitespace doesn't add any glyphs to the text buffer and is thus \"free\".\n # Returns\n\nOn success, a pointer to the character on which string processing stopped, which\n can be a newline ('indicating that's where the line ended), the null character\n ('indicating the end of the string was reached), or any other character\n (indicating the text buffer is full and no more glyphs can be added).\n On failure, NULL."]
    pub fn C2D_TextParseLine(
        text: *mut C2D_Text,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
        lineNo: u32_,
    ) -> *const ::libc::c_char;
}
unsafe extern "C" {
    #[doc = "Parses and adds a single line of text to a text buffer.\n # Arguments\n\n* `text` (direction out) - Pointer to text object to store information in.\n * `font` (direction in) - Font to get glyphs from, or null for system font\n * `buf` (direction in) - Text buffer handle.\n * `str` (direction in) - String to parse.\n * `lineNo` (direction in) - Line number assigned to the text (used to calculate vertical position).\n > Whitespace doesn't add any glyphs to the text buffer and is thus \"free\".\n # Returns\n\nOn success, a pointer to the character on which string processing stopped, which\n can be a newline ('indicating that's where the line ended), the null character\n ('indicating the end of the string was reached), or any other character\n (indicating the text buffer is full and no more glyphs can be added).\n On failure, NULL."]
    pub fn C2D_TextFontParseLine(
        text: *mut C2D_Text,
        font: C2D_Font,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
        lineNo: u32_,
    ) -> *const ::libc::c_char;
}
unsafe extern "C" {
    #[doc = "Parses and adds arbitrary text (including newlines) to a text buffer.\n # Arguments\n\n* `text` (direction out) - Pointer to text object to store information in.\n * `buf` (direction in) - Text buffer handle.\n * `str` (direction in) - String to parse.\n > Whitespace doesn't add any glyphs to the text buffer and is thus \"free\".\n # Returns\n\nOn success, a pointer to the character on which string processing stopped, which\n can be the null character ('indicating the end of the string was reached),\n or any other character (indicating the text buffer is full and no more glyphs can be added).\n On failure, NULL."]
    pub fn C2D_TextParse(
        text: *mut C2D_Text,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
    ) -> *const ::libc::c_char;
}
unsafe extern "C" {
    #[doc = "Parses and adds arbitrary text (including newlines) to a text buffer.\n # Arguments\n\n* `text` (direction out) - Pointer to text object to store information in.\n * `font` (direction in) - Font to get glyphs from, or null for system font\n * `buf` (direction in) - Text buffer handle.\n * `str` (direction in) - String to parse.\n > Whitespace doesn't add any glyphs to the text buffer and is thus \"free\".\n # Returns\n\nOn success, a pointer to the character on which string processing stopped, which\n can be the null character ('indicating the end of the string was reached),\n or any other character (indicating the text buffer is full and no more glyphs can be added).\n On failure, NULL."]
    pub fn C2D_TextFontParse(
        text: *mut C2D_Text,
        font: C2D_Font,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
    ) -> *const ::libc::c_char;
}
unsafe extern "C" {
    #[doc = "Optimizes a text object in order to be drawn more efficiently.\n # Arguments\n\n* `text` (direction in) - Pointer to text object."]
    pub fn C2D_TextOptimize(text: *const C2D_Text);
}
unsafe extern "C" {
    #[doc = "Retrieves the total dimensions of a text object.\n # Arguments\n\n* `text` (direction in) - Pointer to text object.\n * `scaleX` (direction in) - Horizontal size of the font. 1.0f corresponds to the native size of the font.\n * `scaleY` (direction in) - Vertical size of the font. 1.0f corresponds to the native size of the font.\n * `outWidth` (direction out) - (optional) Variable in which to store the width of the text.\n * `outHeight` (direction out) - (optional) Variable in which to store the height of the text."]
    pub fn C2D_TextGetDimensions(
        text: *const C2D_Text,
        scaleX: f32,
        scaleY: f32,
        outWidth: *mut f32,
        outHeight: *mut f32,
    );
}
unsafe extern "C" {
    #[doc = "Draws text using the GPU.\n # Arguments\n\n* `text` (direction in) - Pointer to text object.\n * `flags` (direction in) - Text drawing flags.\n * `x` (direction in) - Horizontal position to draw the text on.\n * `y` (direction in) - Vertical position to draw the text on. If C2D_AtBaseline is not specified (default), this\n is the top left corner of the block of text; otherwise this is the position of the baseline\n of the first line of text.\n * `z` (direction in) - Depth value of the text. If unsure, pass 0.0f.\n * `scaleX` (direction in) - Horizontal size of the font. 1.0f corresponds to the native size of the font.\n * `scaleY` (direction in) - Vertical size of the font. 1.0f corresponds to the native size of the font.\n > The default 3DS system font has a glyph height of 30px, and the baseline is at 25px."]
    pub fn C2D_DrawText(
        text: *const C2D_Text,
        flags: u32_,
        x: f32,
        y: f32,
        z: f32,
        scaleX: f32,
        scaleY: f32,
        ...
    );
}
