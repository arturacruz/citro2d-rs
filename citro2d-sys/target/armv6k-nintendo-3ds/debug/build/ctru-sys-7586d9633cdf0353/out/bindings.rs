/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        unsafe { ::core::slice::from_raw_parts(self.as_ptr(), len) }
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        unsafe { ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len) }
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        unsafe { ::core::mem::transmute(self) }
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        unsafe { ::core::mem::transmute(self) }
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const CUR_PROCESS_HANDLE: u32 = 4294934529;
pub const ARBITRATION_SIGNAL_ALL: i32 = -1;
pub const CUR_THREAD_HANDLE: u32 = 4294934528;
pub const SYSCLOCK_SOC: u32 = 16756991;
pub const SYSCLOCK_SYS: u32 = 33513982;
pub const SYSCLOCK_SDMMC: u32 = 67027964;
pub const SYSCLOCK_ARM9: u32 = 134055928;
pub const SYSCLOCK_ARM11: u32 = 268111856;
pub const SYSCLOCK_ARM11_LGR1: u32 = 536223712;
pub const SYSCLOCK_ARM11_LGR2: u32 = 804335568;
pub const SYSCLOCK_ARM11_NEW: u32 = 804335568;
pub const CPU_TICKS_PER_MSEC: f64 = 268111.856;
pub const CPU_TICKS_PER_USEC: f64 = 268.111856;
pub const OS_HEAP_AREA_BEGIN: u32 = 134217728;
pub const OS_HEAP_AREA_END: u32 = 234881024;
pub const OS_MAP_AREA_BEGIN: u32 = 268435456;
pub const OS_MAP_AREA_END: u32 = 335544320;
pub const OS_OLD_FCRAM_VADDR: u32 = 335544320;
pub const OS_OLD_FCRAM_PADDR: u32 = 536870912;
pub const OS_OLD_FCRAM_SIZE: u32 = 134217728;
pub const OS_QTMRAM_VADDR: u32 = 511705088;
pub const OS_QTMRAM_PADDR: u32 = 520093696;
pub const OS_QTMRAM_SIZE: u32 = 4194304;
pub const OS_MMIO_VADDR: u32 = 515899392;
pub const OS_MMIO_PADDR: u32 = 269484032;
pub const OS_MMIO_SIZE: u32 = 4194304;
pub const OS_VRAM_VADDR: u32 = 520093696;
pub const OS_VRAM_PADDR: u32 = 402653184;
pub const OS_VRAM_SIZE: u32 = 6291456;
pub const OS_DSPRAM_VADDR: u32 = 535822336;
pub const OS_DSPRAM_PADDR: u32 = 535822336;
pub const OS_DSPRAM_SIZE: u32 = 524288;
pub const OS_KERNELCFG_VADDR: u32 = 536346624;
pub const OS_SHAREDCFG_VADDR: u32 = 536350720;
pub const OS_FCRAM_VADDR: u32 = 805306368;
pub const OS_FCRAM_PADDR: u32 = 536870912;
pub const OS_FCRAM_SIZE: u32 = 268435456;
pub const GSP_SCREEN_TOP: u32 = 0;
pub const GSP_SCREEN_BOTTOM: u32 = 1;
pub const GSP_SCREEN_WIDTH: u32 = 240;
pub const GSP_SCREEN_HEIGHT_TOP: u32 = 400;
pub const GSP_SCREEN_HEIGHT_TOP_2X: u32 = 800;
pub const GSP_SCREEN_HEIGHT_BOTTOM: u32 = 320;
pub const CONSOLE_COLOR_BOLD: u32 = 1;
pub const CONSOLE_COLOR_FAINT: u32 = 2;
pub const CONSOLE_ITALIC: u32 = 4;
pub const CONSOLE_UNDERLINE: u32 = 8;
pub const CONSOLE_BLINK_SLOW: u32 = 16;
pub const CONSOLE_BLINK_FAST: u32 = 32;
pub const CONSOLE_COLOR_REVERSE: u32 = 64;
pub const CONSOLE_CONCEAL: u32 = 128;
pub const CONSOLE_CROSSED_OUT: u32 = 256;
pub const CONSOLE_FG_CUSTOM: u32 = 512;
pub const CONSOLE_BG_CUSTOM: u32 = 1024;
pub const CONSOLE_COLOR_FG_BRIGHT: u32 = 2048;
pub const CONSOLE_COLOR_BG_BRIGHT: u32 = 4096;
pub const MII_NAME_LEN: u32 = 11;
pub const FRIEND_COMMENT_LEN: u32 = 17;
pub const FRIEND_GAME_MODE_DESCRIPTION_LEN: u32 = 128;
pub const NASC_INGAMESN_LEN: u32 = 12;
pub const NASC_KEYHASH_LEN: u32 = 9;
pub const NASC_SVC_LEN: u32 = 5;
pub const FRIEND_LIST_SIZE: u32 = 100;
pub const NFS_TYPESTR_LEN: u32 = 3;
pub const ACCOUNT_ID_LEN: u32 = 17;
pub const ACCOUNT_EMAIL_LEN: u32 = 257;
pub const ACCOUNT_PASSWORD_LEN: u32 = 18;
pub const ACT_NNAS_SUBDOMAIN_LEN: u32 = 33;
pub const ACT_UUID_LEN: u32 = 16;
pub const ACT_DEFAULT_ACCOUNT: u32 = 254;
pub const ACT_UUID_REGULAR: i32 = -1;
pub const ACT_UUID_CURRENT_PROCESS: i32 = -2;
pub const ACT_TRANSFERABLE_ID_BASE_COMMON: u32 = 255;
pub const ACT_TRANSFERABLE_ID_BASE_CURRENT_ACCOUNT: u32 = 254;
pub const CSND_NUM_CHANNELS: u32 = 32;
pub const HTTPC_RESULTCODE_DOWNLOADPENDING: u32 = 3628113963;
pub const HTTPC_RESULTCODE_NOTFOUND: u32 = 3628113960;
pub const HTTPC_RESULTCODE_TIMEDOUT: u32 = 3626016873;
pub const UDS_MAXNODES: u32 = 16;
pub const UDS_BROADCAST_NETWORKNODEID: u32 = 65535;
pub const UDS_HOST_NETWORKNODEID: u32 = 1;
pub const UDS_DEFAULT_RECVBUFSIZE: u32 = 11824;
pub const UDS_DATAFRAME_MAXSIZE: u32 = 1478;
pub const ROUTING_FLAG_G: u32 = 1;
pub const TCP_STATE_CLOSED: u32 = 1;
pub const TCP_STATE_LISTEN: u32 = 2;
pub const TCP_STATE_ESTABLISHED: u32 = 5;
pub const TCP_STATE_FINWAIT1: u32 = 6;
pub const TCP_STATE_FINWAIT2: u32 = 7;
pub const TCP_STATE_CLOSE_WAIT: u32 = 8;
pub const TCP_STATE_LAST_ACK: u32 = 9;
pub const TCP_STATE_TIME_WAIT: u32 = 11;
pub const MVD_STATUS_OK: u32 = 94208;
pub const MVD_STATUS_PARAMSET: u32 = 94209;
pub const MVD_STATUS_BUSY: u32 = 94210;
pub const MVD_STATUS_FRAMEREADY: u32 = 94211;
pub const MVD_STATUS_INCOMPLETEPROCESSING: u32 = 94212;
pub const MVD_STATUS_NALUPROCFLAG: u32 = 94215;
pub const MVD_DEFAULT_WORKBUF_SIZE: u32 = 9438920;
pub const MVD_CALC_WITH_LEVEL_FLAG_NONE: u32 = 0;
pub const MVD_CALC_WITH_LEVEL_FLAG_ENABLE_CALC: u32 = 1;
pub const MVD_CALC_WITH_LEVEL_FLAG_ENABLE_EXTRA_OP: u32 = 2;
pub const MVD_CALC_WITH_LEVEL_FLAG_UNK: u32 = 4;
pub const MVD_H264_LEVEL_1_0: u32 = 0;
pub const MVD_H264_LEVEL_1_0B: u32 = 1;
pub const MVD_H264_LEVEL_1_1: u32 = 2;
pub const MVD_H264_LEVEL_1_2: u32 = 3;
pub const MVD_H264_LEVEL_1_3: u32 = 4;
pub const MVD_H264_LEVEL_2_0: u32 = 5;
pub const MVD_H264_LEVEL_2_1: u32 = 6;
pub const MVD_H264_LEVEL_2_2: u32 = 7;
pub const MVD_H264_LEVEL_3_0: u32 = 8;
pub const MVD_H264_LEVEL_3_1: u32 = 9;
pub const MVD_H264_LEVEL_3_2: u32 = 10;
pub const MVD_H264_LEVEL_4_0: u32 = 11;
pub const MVD_H264_LEVEL_4_1: u32 = 12;
pub const MVD_H264_LEVEL_4_2: u32 = 13;
pub const MVD_H264_LEVEL_5_0: u32 = 14;
pub const MVD_H264_LEVEL_5_1: u32 = 15;
pub const MVD_H264_LEVEL_5_2: u32 = 16;
pub const NFC_ERR_INVALID_STATE: u32 = 3366024704;
pub const NFC_ERR_APPDATA_UNINITIALIZED: u32 = 3366024736;
pub const NFC_ERR_AMIIBO_NOTSETUP: u32 = 3366024744;
pub const NFC_ERR_APPID_MISMATCH: u32 = 3366024760;
pub const NFC_ERR_DATACORRUPTION0: u32 = 3368121868;
pub const NFC_ERR_DATACORRUPTION1: u32 = 3366024728;
pub const NFC_STARTSCAN_DEFAULTINPUT: u32 = 0;
pub const QTM_STATUS_CFG_BLK_ID: u32 = 1572864;
pub const QTM_CAL_CFG_BLK_ID: u32 = 1572865;
pub const GPUREG_0000: u32 = 0;
pub const GPUREG_0001: u32 = 1;
pub const GPUREG_0002: u32 = 2;
pub const GPUREG_0003: u32 = 3;
pub const GPUREG_0004: u32 = 4;
pub const GPUREG_0005: u32 = 5;
pub const GPUREG_0006: u32 = 6;
pub const GPUREG_0007: u32 = 7;
pub const GPUREG_0008: u32 = 8;
pub const GPUREG_0009: u32 = 9;
pub const GPUREG_000A: u32 = 10;
pub const GPUREG_000B: u32 = 11;
pub const GPUREG_000C: u32 = 12;
pub const GPUREG_000D: u32 = 13;
pub const GPUREG_000E: u32 = 14;
pub const GPUREG_000F: u32 = 15;
pub const GPUREG_FINALIZE: u32 = 16;
pub const GPUREG_0011: u32 = 17;
pub const GPUREG_0012: u32 = 18;
pub const GPUREG_0013: u32 = 19;
pub const GPUREG_0014: u32 = 20;
pub const GPUREG_0015: u32 = 21;
pub const GPUREG_0016: u32 = 22;
pub const GPUREG_0017: u32 = 23;
pub const GPUREG_0018: u32 = 24;
pub const GPUREG_0019: u32 = 25;
pub const GPUREG_001A: u32 = 26;
pub const GPUREG_001B: u32 = 27;
pub const GPUREG_001C: u32 = 28;
pub const GPUREG_001D: u32 = 29;
pub const GPUREG_001E: u32 = 30;
pub const GPUREG_001F: u32 = 31;
pub const GPUREG_0020: u32 = 32;
pub const GPUREG_0021: u32 = 33;
pub const GPUREG_0022: u32 = 34;
pub const GPUREG_0023: u32 = 35;
pub const GPUREG_0024: u32 = 36;
pub const GPUREG_0025: u32 = 37;
pub const GPUREG_0026: u32 = 38;
pub const GPUREG_0027: u32 = 39;
pub const GPUREG_0028: u32 = 40;
pub const GPUREG_0029: u32 = 41;
pub const GPUREG_002A: u32 = 42;
pub const GPUREG_002B: u32 = 43;
pub const GPUREG_002C: u32 = 44;
pub const GPUREG_002D: u32 = 45;
pub const GPUREG_002E: u32 = 46;
pub const GPUREG_002F: u32 = 47;
pub const GPUREG_0030: u32 = 48;
pub const GPUREG_0031: u32 = 49;
pub const GPUREG_0032: u32 = 50;
pub const GPUREG_0033: u32 = 51;
pub const GPUREG_0034: u32 = 52;
pub const GPUREG_0035: u32 = 53;
pub const GPUREG_0036: u32 = 54;
pub const GPUREG_0037: u32 = 55;
pub const GPUREG_0038: u32 = 56;
pub const GPUREG_0039: u32 = 57;
pub const GPUREG_003A: u32 = 58;
pub const GPUREG_003B: u32 = 59;
pub const GPUREG_003C: u32 = 60;
pub const GPUREG_003D: u32 = 61;
pub const GPUREG_003E: u32 = 62;
pub const GPUREG_003F: u32 = 63;
pub const GPUREG_FACECULLING_CONFIG: u32 = 64;
pub const GPUREG_VIEWPORT_WIDTH: u32 = 65;
pub const GPUREG_VIEWPORT_INVW: u32 = 66;
pub const GPUREG_VIEWPORT_HEIGHT: u32 = 67;
pub const GPUREG_VIEWPORT_INVH: u32 = 68;
pub const GPUREG_0045: u32 = 69;
pub const GPUREG_0046: u32 = 70;
pub const GPUREG_FRAGOP_CLIP: u32 = 71;
pub const GPUREG_FRAGOP_CLIP_DATA0: u32 = 72;
pub const GPUREG_FRAGOP_CLIP_DATA1: u32 = 73;
pub const GPUREG_FRAGOP_CLIP_DATA2: u32 = 74;
pub const GPUREG_FRAGOP_CLIP_DATA3: u32 = 75;
pub const GPUREG_004C: u32 = 76;
pub const GPUREG_DEPTHMAP_SCALE: u32 = 77;
pub const GPUREG_DEPTHMAP_OFFSET: u32 = 78;
pub const GPUREG_SH_OUTMAP_TOTAL: u32 = 79;
pub const GPUREG_SH_OUTMAP_O0: u32 = 80;
pub const GPUREG_SH_OUTMAP_O1: u32 = 81;
pub const GPUREG_SH_OUTMAP_O2: u32 = 82;
pub const GPUREG_SH_OUTMAP_O3: u32 = 83;
pub const GPUREG_SH_OUTMAP_O4: u32 = 84;
pub const GPUREG_SH_OUTMAP_O5: u32 = 85;
pub const GPUREG_SH_OUTMAP_O6: u32 = 86;
pub const GPUREG_0057: u32 = 87;
pub const GPUREG_0058: u32 = 88;
pub const GPUREG_0059: u32 = 89;
pub const GPUREG_005A: u32 = 90;
pub const GPUREG_005B: u32 = 91;
pub const GPUREG_005C: u32 = 92;
pub const GPUREG_005D: u32 = 93;
pub const GPUREG_005E: u32 = 94;
pub const GPUREG_005F: u32 = 95;
pub const GPUREG_0060: u32 = 96;
pub const GPUREG_EARLYDEPTH_FUNC: u32 = 97;
pub const GPUREG_EARLYDEPTH_TEST1: u32 = 98;
pub const GPUREG_EARLYDEPTH_CLEAR: u32 = 99;
pub const GPUREG_SH_OUTATTR_MODE: u32 = 100;
pub const GPUREG_SCISSORTEST_MODE: u32 = 101;
pub const GPUREG_SCISSORTEST_POS: u32 = 102;
pub const GPUREG_SCISSORTEST_DIM: u32 = 103;
pub const GPUREG_VIEWPORT_XY: u32 = 104;
pub const GPUREG_0069: u32 = 105;
pub const GPUREG_EARLYDEPTH_DATA: u32 = 106;
pub const GPUREG_006B: u32 = 107;
pub const GPUREG_006C: u32 = 108;
pub const GPUREG_DEPTHMAP_ENABLE: u32 = 109;
pub const GPUREG_RENDERBUF_DIM: u32 = 110;
pub const GPUREG_SH_OUTATTR_CLOCK: u32 = 111;
pub const GPUREG_0070: u32 = 112;
pub const GPUREG_0071: u32 = 113;
pub const GPUREG_0072: u32 = 114;
pub const GPUREG_0073: u32 = 115;
pub const GPUREG_0074: u32 = 116;
pub const GPUREG_0075: u32 = 117;
pub const GPUREG_0076: u32 = 118;
pub const GPUREG_0077: u32 = 119;
pub const GPUREG_0078: u32 = 120;
pub const GPUREG_0079: u32 = 121;
pub const GPUREG_007A: u32 = 122;
pub const GPUREG_007B: u32 = 123;
pub const GPUREG_007C: u32 = 124;
pub const GPUREG_007D: u32 = 125;
pub const GPUREG_007E: u32 = 126;
pub const GPUREG_007F: u32 = 127;
pub const GPUREG_TEXUNIT_CONFIG: u32 = 128;
pub const GPUREG_TEXUNIT0_BORDER_COLOR: u32 = 129;
pub const GPUREG_TEXUNIT0_DIM: u32 = 130;
pub const GPUREG_TEXUNIT0_PARAM: u32 = 131;
pub const GPUREG_TEXUNIT0_LOD: u32 = 132;
pub const GPUREG_TEXUNIT0_ADDR1: u32 = 133;
pub const GPUREG_TEXUNIT0_ADDR2: u32 = 134;
pub const GPUREG_TEXUNIT0_ADDR3: u32 = 135;
pub const GPUREG_TEXUNIT0_ADDR4: u32 = 136;
pub const GPUREG_TEXUNIT0_ADDR5: u32 = 137;
pub const GPUREG_TEXUNIT0_ADDR6: u32 = 138;
pub const GPUREG_TEXUNIT0_SHADOW: u32 = 139;
pub const GPUREG_008C: u32 = 140;
pub const GPUREG_008D: u32 = 141;
pub const GPUREG_TEXUNIT0_TYPE: u32 = 142;
pub const GPUREG_LIGHTING_ENABLE0: u32 = 143;
pub const GPUREG_0090: u32 = 144;
pub const GPUREG_TEXUNIT1_BORDER_COLOR: u32 = 145;
pub const GPUREG_TEXUNIT1_DIM: u32 = 146;
pub const GPUREG_TEXUNIT1_PARAM: u32 = 147;
pub const GPUREG_TEXUNIT1_LOD: u32 = 148;
pub const GPUREG_TEXUNIT1_ADDR: u32 = 149;
pub const GPUREG_TEXUNIT1_TYPE: u32 = 150;
pub const GPUREG_0097: u32 = 151;
pub const GPUREG_0098: u32 = 152;
pub const GPUREG_TEXUNIT2_BORDER_COLOR: u32 = 153;
pub const GPUREG_TEXUNIT2_DIM: u32 = 154;
pub const GPUREG_TEXUNIT2_PARAM: u32 = 155;
pub const GPUREG_TEXUNIT2_LOD: u32 = 156;
pub const GPUREG_TEXUNIT2_ADDR: u32 = 157;
pub const GPUREG_TEXUNIT2_TYPE: u32 = 158;
pub const GPUREG_009F: u32 = 159;
pub const GPUREG_00A0: u32 = 160;
pub const GPUREG_00A1: u32 = 161;
pub const GPUREG_00A2: u32 = 162;
pub const GPUREG_00A3: u32 = 163;
pub const GPUREG_00A4: u32 = 164;
pub const GPUREG_00A5: u32 = 165;
pub const GPUREG_00A6: u32 = 166;
pub const GPUREG_00A7: u32 = 167;
pub const GPUREG_TEXUNIT3_PROCTEX0: u32 = 168;
pub const GPUREG_TEXUNIT3_PROCTEX1: u32 = 169;
pub const GPUREG_TEXUNIT3_PROCTEX2: u32 = 170;
pub const GPUREG_TEXUNIT3_PROCTEX3: u32 = 171;
pub const GPUREG_TEXUNIT3_PROCTEX4: u32 = 10;
pub const GPUREG_TEXUNIT3_PROCTEX5: u32 = 13;
pub const GPUREG_00AE: u32 = 174;
pub const GPUREG_PROCTEX_LUT: u32 = 175;
pub const GPUREG_PROCTEX_LUT_DATA0: u32 = 176;
pub const GPUREG_PROCTEX_LUT_DATA1: u32 = 177;
pub const GPUREG_PROCTEX_LUT_DATA2: u32 = 178;
pub const GPUREG_PROCTEX_LUT_DATA3: u32 = 179;
pub const GPUREG_PROCTEX_LUT_DATA4: u32 = 180;
pub const GPUREG_PROCTEX_LUT_DATA5: u32 = 181;
pub const GPUREG_PROCTEX_LUT_DATA6: u32 = 182;
pub const GPUREG_PROCTEX_LUT_DATA7: u32 = 183;
pub const GPUREG_00B8: u32 = 184;
pub const GPUREG_00B9: u32 = 185;
pub const GPUREG_00BA: u32 = 186;
pub const GPUREG_00BB: u32 = 187;
pub const GPUREG_00BC: u32 = 188;
pub const GPUREG_00BD: u32 = 189;
pub const GPUREG_00BE: u32 = 190;
pub const GPUREG_00BF: u32 = 191;
pub const GPUREG_TEXENV0_SOURCE: u32 = 192;
pub const GPUREG_TEXENV0_OPERAND: u32 = 193;
pub const GPUREG_TEXENV0_COMBINER: u32 = 194;
pub const GPUREG_TEXENV0_COLOR: u32 = 195;
pub const GPUREG_TEXENV0_SCALE: u32 = 196;
pub const GPUREG_00C5: u32 = 197;
pub const GPUREG_00C6: u32 = 198;
pub const GPUREG_00C7: u32 = 199;
pub const GPUREG_TEXENV1_SOURCE: u32 = 200;
pub const GPUREG_TEXENV1_OPERAND: u32 = 201;
pub const GPUREG_TEXENV1_COMBINER: u32 = 202;
pub const GPUREG_TEXENV1_COLOR: u32 = 203;
pub const GPUREG_TEXENV1_SCALE: u32 = 204;
pub const GPUREG_00CD: u32 = 205;
pub const GPUREG_00CE: u32 = 206;
pub const GPUREG_00CF: u32 = 207;
pub const GPUREG_TEXENV2_SOURCE: u32 = 208;
pub const GPUREG_TEXENV2_OPERAND: u32 = 209;
pub const GPUREG_TEXENV2_COMBINER: u32 = 210;
pub const GPUREG_TEXENV2_COLOR: u32 = 211;
pub const GPUREG_TEXENV2_SCALE: u32 = 212;
pub const GPUREG_00D5: u32 = 213;
pub const GPUREG_00D6: u32 = 214;
pub const GPUREG_00D7: u32 = 215;
pub const GPUREG_TEXENV3_SOURCE: u32 = 216;
pub const GPUREG_TEXENV3_OPERAND: u32 = 217;
pub const GPUREG_TEXENV3_COMBINER: u32 = 218;
pub const GPUREG_TEXENV3_COLOR: u32 = 219;
pub const GPUREG_TEXENV3_SCALE: u32 = 220;
pub const GPUREG_00DD: u32 = 221;
pub const GPUREG_00DE: u32 = 222;
pub const GPUREG_00DF: u32 = 223;
pub const GPUREG_TEXENV_UPDATE_BUFFER: u32 = 224;
pub const GPUREG_FOG_COLOR: u32 = 225;
pub const GPUREG_00E2: u32 = 226;
pub const GPUREG_00E3: u32 = 227;
pub const GPUREG_GAS_ATTENUATION: u32 = 228;
pub const GPUREG_GAS_ACCMAX: u32 = 229;
pub const GPUREG_FOG_LUT_INDEX: u32 = 230;
pub const GPUREG_00E7: u32 = 231;
pub const GPUREG_FOG_LUT_DATA0: u32 = 232;
pub const GPUREG_FOG_LUT_DATA1: u32 = 233;
pub const GPUREG_FOG_LUT_DATA2: u32 = 234;
pub const GPUREG_FOG_LUT_DATA3: u32 = 235;
pub const GPUREG_FOG_LUT_DATA4: u32 = 236;
pub const GPUREG_FOG_LUT_DATA5: u32 = 237;
pub const GPUREG_FOG_LUT_DATA6: u32 = 238;
pub const GPUREG_FOG_LUT_DATA7: u32 = 239;
pub const GPUREG_TEXENV4_SOURCE: u32 = 240;
pub const GPUREG_TEXENV4_OPERAND: u32 = 241;
pub const GPUREG_TEXENV4_COMBINER: u32 = 242;
pub const GPUREG_TEXENV4_COLOR: u32 = 243;
pub const GPUREG_TEXENV4_SCALE: u32 = 244;
pub const GPUREG_00F5: u32 = 245;
pub const GPUREG_00F6: u32 = 246;
pub const GPUREG_00F7: u32 = 247;
pub const GPUREG_TEXENV5_SOURCE: u32 = 248;
pub const GPUREG_TEXENV5_OPERAND: u32 = 249;
pub const GPUREG_TEXENV5_COMBINER: u32 = 250;
pub const GPUREG_TEXENV5_COLOR: u32 = 251;
pub const GPUREG_TEXENV5_SCALE: u32 = 252;
pub const GPUREG_TEXENV_BUFFER_COLOR: u32 = 253;
pub const GPUREG_00FE: u32 = 254;
pub const GPUREG_00FF: u32 = 255;
pub const GPUREG_COLOR_OPERATION: u32 = 256;
pub const GPUREG_BLEND_FUNC: u32 = 257;
pub const GPUREG_LOGIC_OP: u32 = 258;
pub const GPUREG_BLEND_COLOR: u32 = 259;
pub const GPUREG_FRAGOP_ALPHA_TEST: u32 = 260;
pub const GPUREG_STENCIL_TEST: u32 = 261;
pub const GPUREG_STENCIL_OP: u32 = 262;
pub const GPUREG_DEPTH_COLOR_MASK: u32 = 263;
pub const GPUREG_0108: u32 = 264;
pub const GPUREG_0109: u32 = 265;
pub const GPUREG_010A: u32 = 266;
pub const GPUREG_010B: u32 = 267;
pub const GPUREG_010C: u32 = 268;
pub const GPUREG_010D: u32 = 269;
pub const GPUREG_010E: u32 = 270;
pub const GPUREG_010F: u32 = 271;
pub const GPUREG_FRAMEBUFFER_INVALIDATE: u32 = 272;
pub const GPUREG_FRAMEBUFFER_FLUSH: u32 = 273;
pub const GPUREG_COLORBUFFER_READ: u32 = 274;
pub const GPUREG_COLORBUFFER_WRITE: u32 = 275;
pub const GPUREG_DEPTHBUFFER_READ: u32 = 276;
pub const GPUREG_DEPTHBUFFER_WRITE: u32 = 277;
pub const GPUREG_DEPTHBUFFER_FORMAT: u32 = 278;
pub const GPUREG_COLORBUFFER_FORMAT: u32 = 279;
pub const GPUREG_EARLYDEPTH_TEST2: u32 = 280;
pub const GPUREG_0119: u32 = 281;
pub const GPUREG_011A: u32 = 282;
pub const GPUREG_FRAMEBUFFER_BLOCK32: u32 = 283;
pub const GPUREG_DEPTHBUFFER_LOC: u32 = 284;
pub const GPUREG_COLORBUFFER_LOC: u32 = 285;
pub const GPUREG_FRAMEBUFFER_DIM: u32 = 286;
pub const GPUREG_011F: u32 = 287;
pub const GPUREG_GAS_LIGHT_XY: u32 = 288;
pub const GPUREG_GAS_LIGHT_Z: u32 = 289;
pub const GPUREG_GAS_LIGHT_Z_COLOR: u32 = 290;
pub const GPUREG_GAS_LUT_INDEX: u32 = 291;
pub const GPUREG_GAS_LUT_DATA: u32 = 292;
pub const GPUREG_GAS_ACCMAX_FEEDBACK: u32 = 293;
pub const GPUREG_GAS_DELTAZ_DEPTH: u32 = 294;
pub const GPUREG_0127: u32 = 295;
pub const GPUREG_0128: u32 = 296;
pub const GPUREG_0129: u32 = 297;
pub const GPUREG_012A: u32 = 298;
pub const GPUREG_012B: u32 = 299;
pub const GPUREG_012C: u32 = 300;
pub const GPUREG_012D: u32 = 301;
pub const GPUREG_012E: u32 = 302;
pub const GPUREG_012F: u32 = 303;
pub const GPUREG_FRAGOP_SHADOW: u32 = 304;
pub const GPUREG_0131: u32 = 305;
pub const GPUREG_0132: u32 = 306;
pub const GPUREG_0133: u32 = 307;
pub const GPUREG_0134: u32 = 308;
pub const GPUREG_0135: u32 = 309;
pub const GPUREG_0136: u32 = 310;
pub const GPUREG_0137: u32 = 311;
pub const GPUREG_0138: u32 = 312;
pub const GPUREG_0139: u32 = 313;
pub const GPUREG_013A: u32 = 314;
pub const GPUREG_013B: u32 = 315;
pub const GPUREG_013C: u32 = 316;
pub const GPUREG_013D: u32 = 317;
pub const GPUREG_013E: u32 = 318;
pub const GPUREG_013F: u32 = 319;
pub const GPUREG_LIGHT0_SPECULAR0: u32 = 320;
pub const GPUREG_LIGHT0_SPECULAR1: u32 = 321;
pub const GPUREG_LIGHT0_DIFFUSE: u32 = 322;
pub const GPUREG_LIGHT0_AMBIENT: u32 = 323;
pub const GPUREG_LIGHT0_XY: u32 = 324;
pub const GPUREG_LIGHT0_Z: u32 = 325;
pub const GPUREG_LIGHT0_SPOTDIR_XY: u32 = 326;
pub const GPUREG_LIGHT0_SPOTDIR_Z: u32 = 327;
pub const GPUREG_0148: u32 = 328;
pub const GPUREG_LIGHT0_CONFIG: u32 = 329;
pub const GPUREG_LIGHT0_ATTENUATION_BIAS: u32 = 330;
pub const GPUREG_LIGHT0_ATTENUATION_SCALE: u32 = 331;
pub const GPUREG_014C: u32 = 332;
pub const GPUREG_014D: u32 = 333;
pub const GPUREG_014E: u32 = 334;
pub const GPUREG_014F: u32 = 335;
pub const GPUREG_LIGHT1_SPECULAR0: u32 = 336;
pub const GPUREG_LIGHT1_SPECULAR1: u32 = 337;
pub const GPUREG_LIGHT1_DIFFUSE: u32 = 338;
pub const GPUREG_LIGHT1_AMBIENT: u32 = 339;
pub const GPUREG_LIGHT1_XY: u32 = 340;
pub const GPUREG_LIGHT1_Z: u32 = 341;
pub const GPUREG_LIGHT1_SPOTDIR_XY: u32 = 342;
pub const GPUREG_LIGHT1_SPOTDIR_Z: u32 = 343;
pub const GPUREG_0158: u32 = 344;
pub const GPUREG_LIGHT1_CONFIG: u32 = 345;
pub const GPUREG_LIGHT1_ATTENUATION_BIAS: u32 = 346;
pub const GPUREG_LIGHT1_ATTENUATION_SCALE: u32 = 347;
pub const GPUREG_015C: u32 = 348;
pub const GPUREG_015D: u32 = 349;
pub const GPUREG_015E: u32 = 350;
pub const GPUREG_015F: u32 = 351;
pub const GPUREG_LIGHT2_SPECULAR0: u32 = 352;
pub const GPUREG_LIGHT2_SPECULAR1: u32 = 353;
pub const GPUREG_LIGHT2_DIFFUSE: u32 = 354;
pub const GPUREG_LIGHT2_AMBIENT: u32 = 355;
pub const GPUREG_LIGHT2_XY: u32 = 356;
pub const GPUREG_LIGHT2_Z: u32 = 357;
pub const GPUREG_LIGHT2_SPOTDIR_XY: u32 = 358;
pub const GPUREG_LIGHT2_SPOTDIR_Z: u32 = 359;
pub const GPUREG_0168: u32 = 360;
pub const GPUREG_LIGHT2_CONFIG: u32 = 361;
pub const GPUREG_LIGHT2_ATTENUATION_BIAS: u32 = 362;
pub const GPUREG_LIGHT2_ATTENUATION_SCALE: u32 = 363;
pub const GPUREG_016C: u32 = 364;
pub const GPUREG_016D: u32 = 365;
pub const GPUREG_016E: u32 = 366;
pub const GPUREG_016F: u32 = 367;
pub const GPUREG_LIGHT3_SPECULAR0: u32 = 368;
pub const GPUREG_LIGHT3_SPECULAR1: u32 = 369;
pub const GPUREG_LIGHT3_DIFFUSE: u32 = 370;
pub const GPUREG_LIGHT3_AMBIENT: u32 = 371;
pub const GPUREG_LIGHT3_XY: u32 = 372;
pub const GPUREG_LIGHT3_Z: u32 = 373;
pub const GPUREG_LIGHT3_SPOTDIR_XY: u32 = 374;
pub const GPUREG_LIGHT3_SPOTDIR_Z: u32 = 375;
pub const GPUREG_0178: u32 = 376;
pub const GPUREG_LIGHT3_CONFIG: u32 = 377;
pub const GPUREG_LIGHT3_ATTENUATION_BIAS: u32 = 378;
pub const GPUREG_LIGHT3_ATTENUATION_SCALE: u32 = 379;
pub const GPUREG_017C: u32 = 380;
pub const GPUREG_017D: u32 = 381;
pub const GPUREG_017E: u32 = 382;
pub const GPUREG_017F: u32 = 383;
pub const GPUREG_LIGHT4_SPECULAR0: u32 = 384;
pub const GPUREG_LIGHT4_SPECULAR1: u32 = 385;
pub const GPUREG_LIGHT4_DIFFUSE: u32 = 386;
pub const GPUREG_LIGHT4_AMBIENT: u32 = 387;
pub const GPUREG_LIGHT4_XY: u32 = 388;
pub const GPUREG_LIGHT4_Z: u32 = 389;
pub const GPUREG_LIGHT4_SPOTDIR_XY: u32 = 390;
pub const GPUREG_LIGHT4_SPOTDIR_Z: u32 = 391;
pub const GPUREG_0188: u32 = 392;
pub const GPUREG_LIGHT4_CONFIG: u32 = 393;
pub const GPUREG_LIGHT4_ATTENUATION_BIAS: u32 = 394;
pub const GPUREG_LIGHT4_ATTENUATION_SCALE: u32 = 395;
pub const GPUREG_018C: u32 = 396;
pub const GPUREG_018D: u32 = 397;
pub const GPUREG_018E: u32 = 398;
pub const GPUREG_018F: u32 = 399;
pub const GPUREG_LIGHT5_SPECULAR0: u32 = 400;
pub const GPUREG_LIGHT5_SPECULAR1: u32 = 401;
pub const GPUREG_LIGHT5_DIFFUSE: u32 = 402;
pub const GPUREG_LIGHT5_AMBIENT: u32 = 403;
pub const GPUREG_LIGHT5_XY: u32 = 404;
pub const GPUREG_LIGHT5_Z: u32 = 405;
pub const GPUREG_LIGHT5_SPOTDIR_XY: u32 = 406;
pub const GPUREG_LIGHT5_SPOTDIR_Z: u32 = 407;
pub const GPUREG_0198: u32 = 408;
pub const GPUREG_LIGHT5_CONFIG: u32 = 409;
pub const GPUREG_LIGHT5_ATTENUATION_BIAS: u32 = 410;
pub const GPUREG_LIGHT5_ATTENUATION_SCALE: u32 = 411;
pub const GPUREG_019C: u32 = 412;
pub const GPUREG_019D: u32 = 413;
pub const GPUREG_019E: u32 = 414;
pub const GPUREG_019F: u32 = 415;
pub const GPUREG_LIGHT6_SPECULAR0: u32 = 416;
pub const GPUREG_LIGHT6_SPECULAR1: u32 = 417;
pub const GPUREG_LIGHT6_DIFFUSE: u32 = 418;
pub const GPUREG_LIGHT6_AMBIENT: u32 = 419;
pub const GPUREG_LIGHT6_XY: u32 = 420;
pub const GPUREG_LIGHT6_Z: u32 = 421;
pub const GPUREG_LIGHT6_SPOTDIR_XY: u32 = 422;
pub const GPUREG_LIGHT6_SPOTDIR_Z: u32 = 423;
pub const GPUREG_01A8: u32 = 424;
pub const GPUREG_LIGHT6_CONFIG: u32 = 425;
pub const GPUREG_LIGHT6_ATTENUATION_BIAS: u32 = 426;
pub const GPUREG_LIGHT6_ATTENUATION_SCALE: u32 = 427;
pub const GPUREG_01AC: u32 = 428;
pub const GPUREG_01AD: u32 = 429;
pub const GPUREG_01AE: u32 = 430;
pub const GPUREG_01AF: u32 = 431;
pub const GPUREG_LIGHT7_SPECULAR0: u32 = 432;
pub const GPUREG_LIGHT7_SPECULAR1: u32 = 433;
pub const GPUREG_LIGHT7_DIFFUSE: u32 = 434;
pub const GPUREG_LIGHT7_AMBIENT: u32 = 435;
pub const GPUREG_LIGHT7_XY: u32 = 436;
pub const GPUREG_LIGHT7_Z: u32 = 437;
pub const GPUREG_LIGHT7_SPOTDIR_XY: u32 = 438;
pub const GPUREG_LIGHT7_SPOTDIR_Z: u32 = 439;
pub const GPUREG_01B8: u32 = 440;
pub const GPUREG_LIGHT7_CONFIG: u32 = 441;
pub const GPUREG_LIGHT7_ATTENUATION_BIAS: u32 = 442;
pub const GPUREG_LIGHT7_ATTENUATION_SCALE: u32 = 443;
pub const GPUREG_01BC: u32 = 444;
pub const GPUREG_01BD: u32 = 445;
pub const GPUREG_01BE: u32 = 446;
pub const GPUREG_01BF: u32 = 447;
pub const GPUREG_LIGHTING_AMBIENT: u32 = 448;
pub const GPUREG_01C1: u32 = 449;
pub const GPUREG_LIGHTING_NUM_LIGHTS: u32 = 450;
pub const GPUREG_LIGHTING_CONFIG0: u32 = 451;
pub const GPUREG_LIGHTING_CONFIG1: u32 = 452;
pub const GPUREG_LIGHTING_LUT_INDEX: u32 = 453;
pub const GPUREG_LIGHTING_ENABLE1: u32 = 454;
pub const GPUREG_01C7: u32 = 455;
pub const GPUREG_LIGHTING_LUT_DATA0: u32 = 456;
pub const GPUREG_LIGHTING_LUT_DATA1: u32 = 457;
pub const GPUREG_LIGHTING_LUT_DATA2: u32 = 458;
pub const GPUREG_LIGHTING_LUT_DATA3: u32 = 459;
pub const GPUREG_LIGHTING_LUT_DATA4: u32 = 460;
pub const GPUREG_LIGHTING_LUT_DATA5: u32 = 461;
pub const GPUREG_LIGHTING_LUT_DATA6: u32 = 462;
pub const GPUREG_LIGHTING_LUT_DATA7: u32 = 463;
pub const GPUREG_LIGHTING_LUTINPUT_ABS: u32 = 464;
pub const GPUREG_LIGHTING_LUTINPUT_SELECT: u32 = 465;
pub const GPUREG_LIGHTING_LUTINPUT_SCALE: u32 = 466;
pub const GPUREG_01D3: u32 = 467;
pub const GPUREG_01D4: u32 = 468;
pub const GPUREG_01D5: u32 = 469;
pub const GPUREG_01D6: u32 = 470;
pub const GPUREG_01D7: u32 = 471;
pub const GPUREG_01D8: u32 = 472;
pub const GPUREG_LIGHTING_LIGHT_PERMUTATION: u32 = 473;
pub const GPUREG_01DA: u32 = 474;
pub const GPUREG_01DB: u32 = 475;
pub const GPUREG_01DC: u32 = 476;
pub const GPUREG_01DD: u32 = 477;
pub const GPUREG_01DE: u32 = 478;
pub const GPUREG_01DF: u32 = 479;
pub const GPUREG_01E0: u32 = 480;
pub const GPUREG_01E1: u32 = 481;
pub const GPUREG_01E2: u32 = 482;
pub const GPUREG_01E3: u32 = 483;
pub const GPUREG_01E4: u32 = 484;
pub const GPUREG_01E5: u32 = 485;
pub const GPUREG_01E6: u32 = 486;
pub const GPUREG_01E7: u32 = 487;
pub const GPUREG_01E8: u32 = 488;
pub const GPUREG_01E9: u32 = 489;
pub const GPUREG_01EA: u32 = 490;
pub const GPUREG_01EB: u32 = 491;
pub const GPUREG_01EC: u32 = 492;
pub const GPUREG_01ED: u32 = 493;
pub const GPUREG_01EE: u32 = 494;
pub const GPUREG_01EF: u32 = 495;
pub const GPUREG_01F0: u32 = 496;
pub const GPUREG_01F1: u32 = 497;
pub const GPUREG_01F2: u32 = 498;
pub const GPUREG_01F3: u32 = 499;
pub const GPUREG_01F4: u32 = 500;
pub const GPUREG_01F5: u32 = 501;
pub const GPUREG_01F6: u32 = 502;
pub const GPUREG_01F7: u32 = 503;
pub const GPUREG_01F8: u32 = 504;
pub const GPUREG_01F9: u32 = 505;
pub const GPUREG_01FA: u32 = 506;
pub const GPUREG_01FB: u32 = 507;
pub const GPUREG_01FC: u32 = 508;
pub const GPUREG_01FD: u32 = 509;
pub const GPUREG_01FE: u32 = 510;
pub const GPUREG_01FF: u32 = 511;
pub const GPUREG_ATTRIBBUFFERS_LOC: u32 = 512;
pub const GPUREG_ATTRIBBUFFERS_FORMAT_LOW: u32 = 513;
pub const GPUREG_ATTRIBBUFFERS_FORMAT_HIGH: u32 = 514;
pub const GPUREG_ATTRIBBUFFER0_OFFSET: u32 = 515;
pub const GPUREG_ATTRIBBUFFER0_CONFIG1: u32 = 516;
pub const GPUREG_ATTRIBBUFFER0_CONFIG2: u32 = 517;
pub const GPUREG_ATTRIBBUFFER1_OFFSET: u32 = 518;
pub const GPUREG_ATTRIBBUFFER1_CONFIG1: u32 = 519;
pub const GPUREG_ATTRIBBUFFER1_CONFIG2: u32 = 520;
pub const GPUREG_ATTRIBBUFFER2_OFFSET: u32 = 521;
pub const GPUREG_ATTRIBBUFFER2_CONFIG1: u32 = 522;
pub const GPUREG_ATTRIBBUFFER2_CONFIG2: u32 = 523;
pub const GPUREG_ATTRIBBUFFER3_OFFSET: u32 = 524;
pub const GPUREG_ATTRIBBUFFER3_CONFIG1: u32 = 525;
pub const GPUREG_ATTRIBBUFFER3_CONFIG2: u32 = 526;
pub const GPUREG_ATTRIBBUFFER4_OFFSET: u32 = 527;
pub const GPUREG_ATTRIBBUFFER4_CONFIG1: u32 = 528;
pub const GPUREG_ATTRIBBUFFER4_CONFIG2: u32 = 529;
pub const GPUREG_ATTRIBBUFFER5_OFFSET: u32 = 530;
pub const GPUREG_ATTRIBBUFFER5_CONFIG1: u32 = 531;
pub const GPUREG_ATTRIBBUFFER5_CONFIG2: u32 = 532;
pub const GPUREG_ATTRIBBUFFER6_OFFSET: u32 = 533;
pub const GPUREG_ATTRIBBUFFER6_CONFIG1: u32 = 534;
pub const GPUREG_ATTRIBBUFFER6_CONFIG2: u32 = 535;
pub const GPUREG_ATTRIBBUFFER7_OFFSET: u32 = 536;
pub const GPUREG_ATTRIBBUFFER7_CONFIG1: u32 = 537;
pub const GPUREG_ATTRIBBUFFER7_CONFIG2: u32 = 538;
pub const GPUREG_ATTRIBBUFFER8_OFFSET: u32 = 539;
pub const GPUREG_ATTRIBBUFFER8_CONFIG1: u32 = 540;
pub const GPUREG_ATTRIBBUFFER8_CONFIG2: u32 = 541;
pub const GPUREG_ATTRIBBUFFER9_OFFSET: u32 = 542;
pub const GPUREG_ATTRIBBUFFER9_CONFIG1: u32 = 543;
pub const GPUREG_ATTRIBBUFFER9_CONFIG2: u32 = 544;
pub const GPUREG_ATTRIBBUFFERA_OFFSET: u32 = 545;
pub const GPUREG_ATTRIBBUFFERA_CONFIG1: u32 = 546;
pub const GPUREG_ATTRIBBUFFERA_CONFIG2: u32 = 547;
pub const GPUREG_ATTRIBBUFFERB_OFFSET: u32 = 548;
pub const GPUREG_ATTRIBBUFFERB_CONFIG1: u32 = 549;
pub const GPUREG_ATTRIBBUFFERB_CONFIG2: u32 = 550;
pub const GPUREG_INDEXBUFFER_CONFIG: u32 = 551;
pub const GPUREG_NUMVERTICES: u32 = 552;
pub const GPUREG_GEOSTAGE_CONFIG: u32 = 553;
pub const GPUREG_VERTEX_OFFSET: u32 = 554;
pub const GPUREG_022B: u32 = 555;
pub const GPUREG_022C: u32 = 556;
pub const GPUREG_POST_VERTEX_CACHE_NUM: u32 = 557;
pub const GPUREG_DRAWARRAYS: u32 = 558;
pub const GPUREG_DRAWELEMENTS: u32 = 559;
pub const GPUREG_0230: u32 = 560;
pub const GPUREG_VTX_FUNC: u32 = 561;
pub const GPUREG_FIXEDATTRIB_INDEX: u32 = 562;
pub const GPUREG_FIXEDATTRIB_DATA0: u32 = 563;
pub const GPUREG_FIXEDATTRIB_DATA1: u32 = 564;
pub const GPUREG_FIXEDATTRIB_DATA2: u32 = 565;
pub const GPUREG_0236: u32 = 566;
pub const GPUREG_0237: u32 = 567;
pub const GPUREG_CMDBUF_SIZE0: u32 = 568;
pub const GPUREG_CMDBUF_SIZE1: u32 = 569;
pub const GPUREG_CMDBUF_ADDR0: u32 = 570;
pub const GPUREG_CMDBUF_ADDR1: u32 = 571;
pub const GPUREG_CMDBUF_JUMP0: u32 = 572;
pub const GPUREG_CMDBUF_JUMP1: u32 = 573;
pub const GPUREG_023E: u32 = 574;
pub const GPUREG_023F: u32 = 575;
pub const GPUREG_0240: u32 = 576;
pub const GPUREG_0241: u32 = 577;
pub const GPUREG_VSH_NUM_ATTR: u32 = 578;
pub const GPUREG_0243: u32 = 579;
pub const GPUREG_VSH_COM_MODE: u32 = 580;
pub const GPUREG_START_DRAW_FUNC0: u32 = 581;
pub const GPUREG_0246: u32 = 582;
pub const GPUREG_0247: u32 = 583;
pub const GPUREG_0248: u32 = 584;
pub const GPUREG_0249: u32 = 585;
pub const GPUREG_VSH_OUTMAP_TOTAL1: u32 = 586;
pub const GPUREG_024B: u32 = 587;
pub const GPUREG_024C: u32 = 588;
pub const GPUREG_024D: u32 = 589;
pub const GPUREG_024E: u32 = 590;
pub const GPUREG_024F: u32 = 591;
pub const GPUREG_0250: u32 = 592;
pub const GPUREG_VSH_OUTMAP_TOTAL2: u32 = 593;
pub const GPUREG_GSH_MISC0: u32 = 594;
pub const GPUREG_GEOSTAGE_CONFIG2: u32 = 595;
pub const GPUREG_GSH_MISC1: u32 = 596;
pub const GPUREG_0255: u32 = 597;
pub const GPUREG_0256: u32 = 598;
pub const GPUREG_0257: u32 = 599;
pub const GPUREG_0258: u32 = 600;
pub const GPUREG_0259: u32 = 601;
pub const GPUREG_025A: u32 = 602;
pub const GPUREG_025B: u32 = 603;
pub const GPUREG_025C: u32 = 604;
pub const GPUREG_025D: u32 = 605;
pub const GPUREG_PRIMITIVE_CONFIG: u32 = 606;
pub const GPUREG_RESTART_PRIMITIVE: u32 = 607;
pub const GPUREG_0260: u32 = 608;
pub const GPUREG_0261: u32 = 609;
pub const GPUREG_0262: u32 = 610;
pub const GPUREG_0263: u32 = 611;
pub const GPUREG_0264: u32 = 612;
pub const GPUREG_0265: u32 = 613;
pub const GPUREG_0266: u32 = 614;
pub const GPUREG_0267: u32 = 615;
pub const GPUREG_0268: u32 = 616;
pub const GPUREG_0269: u32 = 617;
pub const GPUREG_026A: u32 = 618;
pub const GPUREG_026B: u32 = 619;
pub const GPUREG_026C: u32 = 620;
pub const GPUREG_026D: u32 = 621;
pub const GPUREG_026E: u32 = 622;
pub const GPUREG_026F: u32 = 623;
pub const GPUREG_0270: u32 = 624;
pub const GPUREG_0271: u32 = 625;
pub const GPUREG_0272: u32 = 626;
pub const GPUREG_0273: u32 = 627;
pub const GPUREG_0274: u32 = 628;
pub const GPUREG_0275: u32 = 629;
pub const GPUREG_0276: u32 = 630;
pub const GPUREG_0277: u32 = 631;
pub const GPUREG_0278: u32 = 632;
pub const GPUREG_0279: u32 = 633;
pub const GPUREG_027A: u32 = 634;
pub const GPUREG_027B: u32 = 635;
pub const GPUREG_027C: u32 = 636;
pub const GPUREG_027D: u32 = 637;
pub const GPUREG_027E: u32 = 638;
pub const GPUREG_027F: u32 = 639;
pub const GPUREG_GSH_BOOLUNIFORM: u32 = 640;
pub const GPUREG_GSH_INTUNIFORM_I0: u32 = 641;
pub const GPUREG_GSH_INTUNIFORM_I1: u32 = 642;
pub const GPUREG_GSH_INTUNIFORM_I2: u32 = 643;
pub const GPUREG_GSH_INTUNIFORM_I3: u32 = 644;
pub const GPUREG_0285: u32 = 645;
pub const GPUREG_0286: u32 = 646;
pub const GPUREG_0287: u32 = 647;
pub const GPUREG_0288: u32 = 648;
pub const GPUREG_GSH_INPUTBUFFER_CONFIG: u32 = 649;
pub const GPUREG_GSH_ENTRYPOINT: u32 = 650;
pub const GPUREG_GSH_ATTRIBUTES_PERMUTATION_LOW: u32 = 651;
pub const GPUREG_GSH_ATTRIBUTES_PERMUTATION_HIGH: u32 = 652;
pub const GPUREG_GSH_OUTMAP_MASK: u32 = 653;
pub const GPUREG_028E: u32 = 654;
pub const GPUREG_GSH_CODETRANSFER_END: u32 = 655;
pub const GPUREG_GSH_FLOATUNIFORM_CONFIG: u32 = 656;
pub const GPUREG_GSH_FLOATUNIFORM_DATA: u32 = 657;
pub const GPUREG_0299: u32 = 665;
pub const GPUREG_029A: u32 = 666;
pub const GPUREG_GSH_CODETRANSFER_CONFIG: u32 = 667;
pub const GPUREG_GSH_CODETRANSFER_DATA: u32 = 668;
pub const GPUREG_02A4: u32 = 676;
pub const GPUREG_GSH_OPDESCS_CONFIG: u32 = 677;
pub const GPUREG_GSH_OPDESCS_DATA: u32 = 678;
pub const GPUREG_02AE: u32 = 686;
pub const GPUREG_02AF: u32 = 687;
pub const GPUREG_VSH_BOOLUNIFORM: u32 = 688;
pub const GPUREG_VSH_INTUNIFORM_I0: u32 = 689;
pub const GPUREG_VSH_INTUNIFORM_I1: u32 = 690;
pub const GPUREG_VSH_INTUNIFORM_I2: u32 = 691;
pub const GPUREG_VSH_INTUNIFORM_I3: u32 = 692;
pub const GPUREG_02B5: u32 = 693;
pub const GPUREG_02B6: u32 = 694;
pub const GPUREG_02B7: u32 = 695;
pub const GPUREG_02B8: u32 = 696;
pub const GPUREG_VSH_INPUTBUFFER_CONFIG: u32 = 697;
pub const GPUREG_VSH_ENTRYPOINT: u32 = 698;
pub const GPUREG_VSH_ATTRIBUTES_PERMUTATION_LOW: u32 = 699;
pub const GPUREG_VSH_ATTRIBUTES_PERMUTATION_HIGH: u32 = 700;
pub const GPUREG_VSH_OUTMAP_MASK: u32 = 701;
pub const GPUREG_02BE: u32 = 702;
pub const GPUREG_VSH_CODETRANSFER_END: u32 = 703;
pub const GPUREG_VSH_FLOATUNIFORM_CONFIG: u32 = 704;
pub const GPUREG_VSH_FLOATUNIFORM_DATA: u32 = 705;
pub const GPUREG_02C9: u32 = 713;
pub const GPUREG_02CA: u32 = 714;
pub const GPUREG_VSH_CODETRANSFER_CONFIG: u32 = 715;
pub const GPUREG_VSH_CODETRANSFER_DATA: u32 = 716;
pub const GPUREG_02D4: u32 = 724;
pub const GPUREG_VSH_OPDESCS_CONFIG: u32 = 725;
pub const GPUREG_VSH_OPDESCS_DATA: u32 = 726;
pub const GPUREG_02DE: u32 = 734;
pub const GPUREG_02DF: u32 = 735;
pub const GPUREG_02E0: u32 = 736;
pub const GPUREG_02E1: u32 = 737;
pub const GPUREG_02E2: u32 = 738;
pub const GPUREG_02E3: u32 = 739;
pub const GPUREG_02E4: u32 = 740;
pub const GPUREG_02E5: u32 = 741;
pub const GPUREG_02E6: u32 = 742;
pub const GPUREG_02E7: u32 = 743;
pub const GPUREG_02E8: u32 = 744;
pub const GPUREG_02E9: u32 = 745;
pub const GPUREG_02EA: u32 = 746;
pub const GPUREG_02EB: u32 = 747;
pub const GPUREG_02EC: u32 = 748;
pub const GPUREG_02ED: u32 = 749;
pub const GPUREG_02EE: u32 = 750;
pub const GPUREG_02EF: u32 = 751;
pub const GPUREG_02F0: u32 = 752;
pub const GPUREG_02F1: u32 = 753;
pub const GPUREG_02F2: u32 = 754;
pub const GPUREG_02F3: u32 = 755;
pub const GPUREG_02F4: u32 = 756;
pub const GPUREG_02F5: u32 = 757;
pub const GPUREG_02F6: u32 = 758;
pub const GPUREG_02F7: u32 = 759;
pub const GPUREG_02F8: u32 = 760;
pub const GPUREG_02F9: u32 = 761;
pub const GPUREG_02FA: u32 = 762;
pub const GPUREG_02FB: u32 = 763;
pub const GPUREG_02FC: u32 = 764;
pub const GPUREG_02FD: u32 = 765;
pub const GPUREG_02FE: u32 = 766;
pub const GPUREG_02FF: u32 = 767;
pub const NDSP_SAMPLE_RATE: f64 = 32728.498046875;
pub const SWKBD_MAX_WORD_LEN: u32 = 40;
pub const SWKBD_MAX_BUTTON_TEXT_LEN: u32 = 16;
pub const SWKBD_MAX_HINT_TEXT_LEN: u32 = 64;
pub const SWKBD_MAX_CALLBACK_MSG_LEN: u32 = 256;
pub const MIISELECTOR_MAGIC: u32 = 333326543;
pub const MIISELECTOR_TITLE_LEN: u32 = 64;
pub const MIISELECTOR_GUESTMII_SLOTS: u32 = 6;
pub const MIISELECTOR_USERMII_SLOTS: u32 = 100;
pub const MIISELECTOR_GUESTMII_NAME_LEN: u32 = 12;
pub const ARCHIVE_DIRITER_MAGIC: u32 = 1751347809;
pub const LINK3DS_COMM_PORT: u32 = 17491;
pub type __uint32_t = ::libc::c_uint;
pub type __int_least64_t = ::libc::c_longlong;
pub type u8_ = u8;
pub type u16_ = u16;
pub type u32_ = u32;
pub type u64_ = u64;
pub type s8 = i8;
pub type s16 = i16;
pub type s32 = i32;
pub type s64 = i64;
pub type vu8 = u8_;
pub type vu16 = u16_;
pub type vu32 = u32_;
pub type vu64 = u64_;
pub type vs8 = s8;
pub type vs16 = s16;
pub type vs32 = s32;
pub type vs64 = s64;
pub type Handle = u32_;
pub type Result = s32;
pub type ThreadFunc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>;
pub type voidfn = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "Structure representing CPU registers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CpuRegisters {
    #[doc = "< r0-r12."]
    pub r: [u32_; 13usize],
    #[doc = "< sp."]
    pub sp: u32_,
    #[doc = "< lr."]
    pub lr: u32_,
    #[doc = "< pc. May need to be adjusted."]
    pub pc: u32_,
    #[doc = "< cpsr."]
    pub cpsr: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CpuRegisters"][::core::mem::size_of::<CpuRegisters>() - 68usize];
    ["Alignment of CpuRegisters"][::core::mem::align_of::<CpuRegisters>() - 4usize];
    ["Offset of field: CpuRegisters::r"][::core::mem::offset_of!(CpuRegisters, r) - 0usize];
    ["Offset of field: CpuRegisters::sp"][::core::mem::offset_of!(CpuRegisters, sp) - 52usize];
    ["Offset of field: CpuRegisters::lr"][::core::mem::offset_of!(CpuRegisters, lr) - 56usize];
    ["Offset of field: CpuRegisters::pc"][::core::mem::offset_of!(CpuRegisters, pc) - 60usize];
    ["Offset of field: CpuRegisters::cpsr"][::core::mem::offset_of!(CpuRegisters, cpsr) - 64usize];
};
#[doc = "Structure representing FPU registers"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FpuRegisters {
    pub __bindgen_anon_1: FpuRegisters__bindgen_ty_1,
    #[doc = "< fpscr."]
    pub fpscr: u32_,
    #[doc = "< fpexc."]
    pub fpexc: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FpuRegisters__bindgen_ty_1 {
    pub __bindgen_anon_1: FpuRegisters__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< s0-s31."]
    pub s: [f32; 32usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FpuRegisters__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< d0-d15."]
    pub d: [f64; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FpuRegisters__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<FpuRegisters__bindgen_ty_1__bindgen_ty_1>() - 128usize];
    ["Alignment of FpuRegisters__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<FpuRegisters__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Offset of field: FpuRegisters__bindgen_ty_1__bindgen_ty_1::d"]
        [::core::mem::offset_of!(FpuRegisters__bindgen_ty_1__bindgen_ty_1, d) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FpuRegisters__bindgen_ty_1"]
        [::core::mem::size_of::<FpuRegisters__bindgen_ty_1>() - 128usize];
    ["Alignment of FpuRegisters__bindgen_ty_1"]
        [::core::mem::align_of::<FpuRegisters__bindgen_ty_1>() - 4usize];
    ["Offset of field: FpuRegisters__bindgen_ty_1::s"]
        [::core::mem::offset_of!(FpuRegisters__bindgen_ty_1, s) - 0usize];
};
impl Default for FpuRegisters__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FpuRegisters"][::core::mem::size_of::<FpuRegisters>() - 136usize];
    ["Alignment of FpuRegisters"][::core::mem::align_of::<FpuRegisters>() - 4usize];
    ["Offset of field: FpuRegisters::fpscr"]
        [::core::mem::offset_of!(FpuRegisters, fpscr) - 128usize];
    ["Offset of field: FpuRegisters::fpexc"]
        [::core::mem::offset_of!(FpuRegisters, fpexc) - 132usize];
};
impl Default for FpuRegisters {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RL_SUCCESS: _bindgen_ty_1 = 0;
pub const RL_INFO: _bindgen_ty_1 = 1;
pub const RL_FATAL: _bindgen_ty_1 = 31;
pub const RL_RESET: _bindgen_ty_1 = 30;
pub const RL_REINITIALIZE: _bindgen_ty_1 = 29;
pub const RL_USAGE: _bindgen_ty_1 = 28;
pub const RL_PERMANENT: _bindgen_ty_1 = 27;
pub const RL_TEMPORARY: _bindgen_ty_1 = 26;
pub const RL_STATUS: _bindgen_ty_1 = 25;
#[doc = "Result code level values."]
pub type _bindgen_ty_1 = ::libc::c_uchar;
pub const RS_SUCCESS: _bindgen_ty_2 = 0;
pub const RS_NOP: _bindgen_ty_2 = 1;
pub const RS_WOULDBLOCK: _bindgen_ty_2 = 2;
pub const RS_OUTOFRESOURCE: _bindgen_ty_2 = 3;
pub const RS_NOTFOUND: _bindgen_ty_2 = 4;
pub const RS_INVALIDSTATE: _bindgen_ty_2 = 5;
pub const RS_NOTSUPPORTED: _bindgen_ty_2 = 6;
pub const RS_INVALIDARG: _bindgen_ty_2 = 7;
pub const RS_WRONGARG: _bindgen_ty_2 = 8;
pub const RS_CANCELED: _bindgen_ty_2 = 9;
pub const RS_STATUSCHANGED: _bindgen_ty_2 = 10;
pub const RS_INTERNAL: _bindgen_ty_2 = 11;
pub const RS_INVALIDRESVAL: _bindgen_ty_2 = 63;
#[doc = "Result code summary values."]
pub type _bindgen_ty_2 = ::libc::c_uchar;
pub const RM_COMMON: _bindgen_ty_3 = 0;
pub const RM_KERNEL: _bindgen_ty_3 = 1;
pub const RM_UTIL: _bindgen_ty_3 = 2;
pub const RM_FILE_SERVER: _bindgen_ty_3 = 3;
pub const RM_LOADER_SERVER: _bindgen_ty_3 = 4;
pub const RM_TCB: _bindgen_ty_3 = 5;
pub const RM_OS: _bindgen_ty_3 = 6;
pub const RM_DBG: _bindgen_ty_3 = 7;
pub const RM_DMNT: _bindgen_ty_3 = 8;
pub const RM_PDN: _bindgen_ty_3 = 9;
pub const RM_GSP: _bindgen_ty_3 = 10;
pub const RM_I2C: _bindgen_ty_3 = 11;
pub const RM_GPIO: _bindgen_ty_3 = 12;
pub const RM_DD: _bindgen_ty_3 = 13;
pub const RM_CODEC: _bindgen_ty_3 = 14;
pub const RM_SPI: _bindgen_ty_3 = 15;
pub const RM_PXI: _bindgen_ty_3 = 16;
pub const RM_FS: _bindgen_ty_3 = 17;
pub const RM_DI: _bindgen_ty_3 = 18;
pub const RM_HID: _bindgen_ty_3 = 19;
pub const RM_CAM: _bindgen_ty_3 = 20;
pub const RM_PI: _bindgen_ty_3 = 21;
pub const RM_PM: _bindgen_ty_3 = 22;
pub const RM_PM_LOW: _bindgen_ty_3 = 23;
pub const RM_FSI: _bindgen_ty_3 = 24;
pub const RM_SRV: _bindgen_ty_3 = 25;
pub const RM_NDM: _bindgen_ty_3 = 26;
pub const RM_NWM: _bindgen_ty_3 = 27;
pub const RM_SOC: _bindgen_ty_3 = 28;
pub const RM_LDR: _bindgen_ty_3 = 29;
pub const RM_ACC: _bindgen_ty_3 = 30;
pub const RM_ROMFS: _bindgen_ty_3 = 31;
pub const RM_AM: _bindgen_ty_3 = 32;
pub const RM_HIO: _bindgen_ty_3 = 33;
pub const RM_UPDATER: _bindgen_ty_3 = 34;
pub const RM_MIC: _bindgen_ty_3 = 35;
pub const RM_FND: _bindgen_ty_3 = 36;
pub const RM_MP: _bindgen_ty_3 = 37;
pub const RM_MPWL: _bindgen_ty_3 = 38;
pub const RM_AC: _bindgen_ty_3 = 39;
pub const RM_HTTP: _bindgen_ty_3 = 40;
pub const RM_DSP: _bindgen_ty_3 = 41;
pub const RM_SND: _bindgen_ty_3 = 42;
pub const RM_DLP: _bindgen_ty_3 = 43;
pub const RM_HIO_LOW: _bindgen_ty_3 = 44;
pub const RM_CSND: _bindgen_ty_3 = 45;
pub const RM_SSL: _bindgen_ty_3 = 46;
pub const RM_AM_LOW: _bindgen_ty_3 = 47;
pub const RM_NEX: _bindgen_ty_3 = 48;
pub const RM_FRIENDS: _bindgen_ty_3 = 49;
pub const RM_RDT: _bindgen_ty_3 = 50;
pub const RM_APPLET: _bindgen_ty_3 = 51;
pub const RM_NIM: _bindgen_ty_3 = 52;
pub const RM_PTM: _bindgen_ty_3 = 53;
pub const RM_MIDI: _bindgen_ty_3 = 54;
pub const RM_MC: _bindgen_ty_3 = 55;
pub const RM_SWC: _bindgen_ty_3 = 56;
pub const RM_FATFS: _bindgen_ty_3 = 57;
pub const RM_NGC: _bindgen_ty_3 = 58;
pub const RM_CARD: _bindgen_ty_3 = 59;
pub const RM_CARDNOR: _bindgen_ty_3 = 60;
pub const RM_SDMC: _bindgen_ty_3 = 61;
pub const RM_BOSS: _bindgen_ty_3 = 62;
pub const RM_DBM: _bindgen_ty_3 = 63;
pub const RM_CONFIG: _bindgen_ty_3 = 64;
pub const RM_PS: _bindgen_ty_3 = 65;
pub const RM_CEC: _bindgen_ty_3 = 66;
pub const RM_IR: _bindgen_ty_3 = 67;
pub const RM_UDS: _bindgen_ty_3 = 68;
pub const RM_PL: _bindgen_ty_3 = 69;
pub const RM_CUP: _bindgen_ty_3 = 70;
pub const RM_GYROSCOPE: _bindgen_ty_3 = 71;
pub const RM_MCU: _bindgen_ty_3 = 72;
pub const RM_NS: _bindgen_ty_3 = 73;
pub const RM_NEWS: _bindgen_ty_3 = 74;
pub const RM_RO: _bindgen_ty_3 = 75;
pub const RM_GD: _bindgen_ty_3 = 76;
pub const RM_CARD_SPI: _bindgen_ty_3 = 77;
pub const RM_EC: _bindgen_ty_3 = 78;
pub const RM_WEB_BROWSER: _bindgen_ty_3 = 79;
pub const RM_TEST: _bindgen_ty_3 = 80;
pub const RM_ENC: _bindgen_ty_3 = 81;
pub const RM_PIA: _bindgen_ty_3 = 82;
pub const RM_ACT: _bindgen_ty_3 = 83;
pub const RM_VCTL: _bindgen_ty_3 = 84;
pub const RM_OLV: _bindgen_ty_3 = 85;
pub const RM_NEIA: _bindgen_ty_3 = 86;
pub const RM_NPNS: _bindgen_ty_3 = 87;
pub const RM_AVD: _bindgen_ty_3 = 90;
pub const RM_L2B: _bindgen_ty_3 = 91;
pub const RM_MVD: _bindgen_ty_3 = 92;
pub const RM_NFC: _bindgen_ty_3 = 93;
pub const RM_UART: _bindgen_ty_3 = 94;
pub const RM_SPM: _bindgen_ty_3 = 95;
pub const RM_QTM: _bindgen_ty_3 = 96;
pub const RM_NFP: _bindgen_ty_3 = 97;
pub const RM_APPLICATION: _bindgen_ty_3 = 254;
pub const RM_INVALIDRESVAL: _bindgen_ty_3 = 255;
#[doc = "Result code module values."]
pub type _bindgen_ty_3 = ::libc::c_uchar;
pub const RD_SUCCESS: _bindgen_ty_4 = 0;
pub const RD_INVALID_RESULT_VALUE: _bindgen_ty_4 = 1023;
pub const RD_TIMEOUT: _bindgen_ty_4 = 1022;
pub const RD_OUT_OF_RANGE: _bindgen_ty_4 = 1021;
pub const RD_ALREADY_EXISTS: _bindgen_ty_4 = 1020;
pub const RD_CANCEL_REQUESTED: _bindgen_ty_4 = 1019;
pub const RD_NOT_FOUND: _bindgen_ty_4 = 1018;
pub const RD_ALREADY_INITIALIZED: _bindgen_ty_4 = 1017;
pub const RD_NOT_INITIALIZED: _bindgen_ty_4 = 1016;
pub const RD_INVALID_HANDLE: _bindgen_ty_4 = 1015;
pub const RD_INVALID_POINTER: _bindgen_ty_4 = 1014;
pub const RD_INVALID_ADDRESS: _bindgen_ty_4 = 1013;
pub const RD_NOT_IMPLEMENTED: _bindgen_ty_4 = 1012;
pub const RD_OUT_OF_MEMORY: _bindgen_ty_4 = 1011;
pub const RD_MISALIGNED_SIZE: _bindgen_ty_4 = 1010;
pub const RD_MISALIGNED_ADDRESS: _bindgen_ty_4 = 1009;
pub const RD_BUSY: _bindgen_ty_4 = 1008;
pub const RD_NO_DATA: _bindgen_ty_4 = 1007;
pub const RD_INVALID_COMBINATION: _bindgen_ty_4 = 1006;
pub const RD_INVALID_ENUM_VALUE: _bindgen_ty_4 = 1005;
pub const RD_INVALID_SIZE: _bindgen_ty_4 = 1004;
pub const RD_ALREADY_DONE: _bindgen_ty_4 = 1003;
pub const RD_NOT_AUTHORIZED: _bindgen_ty_4 = 1002;
pub const RD_TOO_LARGE: _bindgen_ty_4 = 1001;
pub const RD_INVALID_SELECTION: _bindgen_ty_4 = 1000;
#[doc = "Result code generic description values."]
pub type _bindgen_ty_4 = ::libc::c_ushort;
#[doc = "< Readable"]
pub const IPC_BUFFER_R: IPC_BufferRights = 2;
#[doc = "< Writable"]
pub const IPC_BUFFER_W: IPC_BufferRights = 4;
#[doc = "< Readable and Writable"]
pub const IPC_BUFFER_RW: IPC_BufferRights = 6;
#[doc = "IPC buffer access rights."]
pub type IPC_BufferRights = ::libc::c_uchar;
unsafe extern "C" {
    #[doc = "Creates a command header to be used for IPC\n # Arguments\n\n* `command_id` - ID of the command to create a header for.\n * `normal_params` - Size of the normal parameters in words. Up to 63.\n * `translate_params` - Size of the translate parameters in words. Up to 63.\n # Returns\n\nThe created IPC header.\n\n Normal parameters are sent directly to the process while the translate parameters might go through modifications and checks by the kernel.\n The translate parameters are described by headers generated with the IPC_Desc_* functions.\n\n > **Note:** While #normal_params is equivalent to the number of normal parameters, #translate_params includes the size occupied by the translate parameters headers."]
    #[link_name = "IPC_MakeHeader__extern"]
    pub fn IPC_MakeHeader(
        command_id: u16_,
        normal_params: ::libc::c_uint,
        translate_params: ::libc::c_uint,
    ) -> u32_;
}
unsafe extern "C" {
    #[doc = "Creates a header to share handles\n # Arguments\n\n* `number` - The number of handles following this header. Max 64.\n # Returns\n\nThe created shared handles header.\n\n The #number next values are handles that will be shared between the two processes.\n\n > **Note:** Zero values will have no effect."]
    #[link_name = "IPC_Desc_SharedHandles__extern"]
    pub fn IPC_Desc_SharedHandles(number: ::libc::c_uint) -> u32_;
}
unsafe extern "C" {
    #[doc = "Creates the header to transfer handle ownership\n # Arguments\n\n* `number` - The number of handles following this header. Max 64.\n # Returns\n\nThe created handle transfer header.\n\n The #number next values are handles that will be duplicated and closed by the other process.\n\n > **Note:** Zero values will have no effect."]
    #[link_name = "IPC_Desc_MoveHandles__extern"]
    pub fn IPC_Desc_MoveHandles(number: ::libc::c_uint) -> u32_;
}
unsafe extern "C" {
    #[doc = "Returns the code to ask the kernel to fill the handle with the current process ID.\n # Returns\n\nThe code to request the current process ID.\n\n The next value is a placeholder that will be replaced by the current process ID by the kernel."]
    #[link_name = "IPC_Desc_CurProcessId__extern"]
    pub fn IPC_Desc_CurProcessId() -> u32_;
}
unsafe extern "C" {
    #[link_name = "IPC_Desc_CurProcessHandle__extern"]
    pub fn IPC_Desc_CurProcessHandle() -> u32_;
}
unsafe extern "C" {
    #[doc = "Creates a header describing a static buffer.\n # Arguments\n\n* `size` - Size of the buffer. Max ?0x03FFFF?.\n * `buffer_id` - The Id of the buffer. Max 0xF.\n # Returns\n\nThe created static buffer header.\n\n The next value is a pointer to the buffer. It will be copied to TLS offset 0x180 + static_buffer_id*8."]
    #[link_name = "IPC_Desc_StaticBuffer__extern"]
    pub fn IPC_Desc_StaticBuffer(size: usize, buffer_id: ::libc::c_uint) -> u32_;
}
unsafe extern "C" {
    #[doc = "Creates a header describing a buffer to be sent over PXI.\n # Arguments\n\n* `size` - Size of the buffer. Max 0x00FFFFFF.\n * `buffer_id` - The Id of the buffer. Max 0xF.\n * `is_read_only` - true if the buffer is read-only. If false, the buffer is considered to have read-write access.\n # Returns\n\nThe created PXI buffer header.\n\n The next value is a phys-address of a table located in the BASE memregion."]
    #[link_name = "IPC_Desc_PXIBuffer__extern"]
    pub fn IPC_Desc_PXIBuffer(size: usize, buffer_id: ::libc::c_uint, is_read_only: bool) -> u32_;
}
unsafe extern "C" {
    #[doc = "Creates a header describing a buffer from the main memory.\n # Arguments\n\n* `size` - Size of the buffer. Max 0x0FFFFFFF.\n * `rights` - The rights of the buffer for the destination process.\n # Returns\n\nThe created buffer header.\n\n The next value is a pointer to the buffer."]
    #[link_name = "IPC_Desc_Buffer__extern"]
    pub fn IPC_Desc_Buffer(size: usize, rights: IPC_BufferRights) -> u32_;
}
#[doc = "< Memory un-mapping"]
pub const MEMOP_FREE: MemOp = 1;
#[doc = "< Reserve memory"]
pub const MEMOP_RESERVE: MemOp = 2;
#[doc = "< Memory mapping"]
pub const MEMOP_ALLOC: MemOp = 3;
#[doc = "< Mirror mapping"]
pub const MEMOP_MAP: MemOp = 4;
#[doc = "< Mirror unmapping"]
pub const MEMOP_UNMAP: MemOp = 5;
#[doc = "< Change protection"]
pub const MEMOP_PROT: MemOp = 6;
#[doc = "< APPLICATION memory region."]
pub const MEMOP_REGION_APP: MemOp = 256;
#[doc = "< SYSTEM memory region."]
pub const MEMOP_REGION_SYSTEM: MemOp = 512;
#[doc = "< BASE memory region."]
pub const MEMOP_REGION_BASE: MemOp = 768;
#[doc = "< Operation bitmask."]
pub const MEMOP_OP_MASK: MemOp = 255;
#[doc = "< Region bitmask."]
pub const MEMOP_REGION_MASK: MemOp = 3840;
#[doc = "< Flag for linear memory operations"]
pub const MEMOP_LINEAR_FLAG: MemOp = 65536;
#[doc = "< Allocates linear memory."]
pub const MEMOP_ALLOC_LINEAR: MemOp = 65539;
#[doc = "svcControlMemory operation flags\n\n The lowest 8 bits are the operation"]
pub type MemOp = ::libc::c_uint;
#[doc = "< Free memory"]
pub const MEMSTATE_FREE: MemState = 0;
#[doc = "< Reserved memory"]
pub const MEMSTATE_RESERVED: MemState = 1;
#[doc = "< I/O memory"]
pub const MEMSTATE_IO: MemState = 2;
#[doc = "< Static memory"]
pub const MEMSTATE_STATIC: MemState = 3;
#[doc = "< Code memory"]
pub const MEMSTATE_CODE: MemState = 4;
#[doc = "< Private memory"]
pub const MEMSTATE_PRIVATE: MemState = 5;
#[doc = "< Shared memory"]
pub const MEMSTATE_SHARED: MemState = 6;
#[doc = "< Continuous memory"]
pub const MEMSTATE_CONTINUOUS: MemState = 7;
#[doc = "< Aliased memory"]
pub const MEMSTATE_ALIASED: MemState = 8;
#[doc = "< Alias memory"]
pub const MEMSTATE_ALIAS: MemState = 9;
#[doc = "< Aliased code memory"]
pub const MEMSTATE_ALIASCODE: MemState = 10;
#[doc = "< Locked memory"]
pub const MEMSTATE_LOCKED: MemState = 11;
#[doc = "The state of a memory block."]
pub type MemState = ::libc::c_uchar;
#[doc = "< Readable"]
pub const MEMPERM_READ: MemPerm = 1;
#[doc = "< Writable"]
pub const MEMPERM_WRITE: MemPerm = 2;
#[doc = "< Executable"]
pub const MEMPERM_EXECUTE: MemPerm = 4;
#[doc = "< Readable and writable"]
pub const MEMPERM_READWRITE: MemPerm = 3;
#[doc = "< Readable and executable"]
pub const MEMPERM_READEXECUTE: MemPerm = 5;
#[doc = "< Don't care"]
pub const MEMPERM_DONTCARE: MemPerm = 268435456;
#[doc = "Memory permission flags"]
pub type MemPerm = ::libc::c_uint;
#[doc = "< All regions."]
pub const MEMREGION_ALL: MemRegion = 0;
#[doc = "< APPLICATION memory."]
pub const MEMREGION_APPLICATION: MemRegion = 1;
#[doc = "< SYSTEM memory."]
pub const MEMREGION_SYSTEM: MemRegion = 2;
#[doc = "< BASE memory."]
pub const MEMREGION_BASE: MemRegion = 3;
#[doc = "Memory regions."]
pub type MemRegion = ::libc::c_uchar;
#[doc = "Memory information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemInfo {
    #[doc = "< Base address."]
    pub base_addr: u32_,
    #[doc = "< Size."]
    pub size: u32_,
    #[doc = "< Memory permissions. See MemPerm"]
    pub perm: u32_,
    #[doc = "< Memory state. See MemState"]
    pub state: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemInfo"][::core::mem::size_of::<MemInfo>() - 16usize];
    ["Alignment of MemInfo"][::core::mem::align_of::<MemInfo>() - 4usize];
    ["Offset of field: MemInfo::base_addr"][::core::mem::offset_of!(MemInfo, base_addr) - 0usize];
    ["Offset of field: MemInfo::size"][::core::mem::offset_of!(MemInfo, size) - 4usize];
    ["Offset of field: MemInfo::perm"][::core::mem::offset_of!(MemInfo, perm) - 8usize];
    ["Offset of field: MemInfo::state"][::core::mem::offset_of!(MemInfo, state) - 12usize];
};
#[doc = "Memory page information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PageInfo {
    #[doc = "< Page flags."]
    pub flags: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PageInfo"][::core::mem::size_of::<PageInfo>() - 4usize];
    ["Alignment of PageInfo"][::core::mem::align_of::<PageInfo>() - 4usize];
    ["Offset of field: PageInfo::flags"][::core::mem::offset_of!(PageInfo, flags) - 0usize];
};
#[doc = "< Signal #value threads for wake-up."]
pub const ARBITRATION_SIGNAL: ArbitrationType = 0;
#[doc = "< If the memory at the address is strictly lower than #value, then wait for signal."]
pub const ARBITRATION_WAIT_IF_LESS_THAN: ArbitrationType = 1;
#[doc = "< If the memory at the address is strictly lower than #value, then decrement it and wait for signal."]
pub const ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN: ArbitrationType = 2;
#[doc = "< If the memory at the address is strictly lower than #value, then wait for signal or timeout."]
pub const ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT: ArbitrationType = 3;
#[doc = "< If the memory at the address is strictly lower than #value, then decrement it and wait for signal or timeout."]
pub const ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN_TIMEOUT: ArbitrationType = 4;
#[doc = "Arbitration modes."]
pub type ArbitrationType = ::libc::c_uchar;
#[doc = "< When the primitive is signaled, it will wake up exactly one thread and will clear itself automatically."]
pub const RESET_ONESHOT: ResetType = 0;
#[doc = "< When the primitive is signaled, it will wake up all threads and it won't clear itself automatically."]
pub const RESET_STICKY: ResetType = 1;
#[doc = "< Only meaningful for timers: same as ONESHOT but it will periodically signal the timer instead of just once."]
pub const RESET_PULSE: ResetType = 2;
#[doc = "Reset types (for use with events and timers)"]
pub type ResetType = ::libc::c_uchar;
#[doc = "< Unknown."]
pub const THREADINFO_TYPE_UNKNOWN: ThreadInfoType = 0;
#[doc = "Types of thread info."]
pub type ThreadInfoType = ::libc::c_uchar;
#[doc = "< Thread priority"]
pub const RESLIMIT_PRIORITY: ResourceLimitType = 0;
#[doc = "< Quantity of allocatable memory"]
pub const RESLIMIT_COMMIT: ResourceLimitType = 1;
#[doc = "< Number of threads"]
pub const RESLIMIT_THREAD: ResourceLimitType = 2;
#[doc = "< Number of events"]
pub const RESLIMIT_EVENT: ResourceLimitType = 3;
#[doc = "< Number of mutexes"]
pub const RESLIMIT_MUTEX: ResourceLimitType = 4;
#[doc = "< Number of semaphores"]
pub const RESLIMIT_SEMAPHORE: ResourceLimitType = 5;
#[doc = "< Number of timers"]
pub const RESLIMIT_TIMER: ResourceLimitType = 6;
#[doc = "< Number of shared memory objects, see svcCreateMemoryBlock"]
pub const RESLIMIT_SHAREDMEMORY: ResourceLimitType = 7;
#[doc = "< Number of address arbiters"]
pub const RESLIMIT_ADDRESSARBITER: ResourceLimitType = 8;
#[doc = "< CPU time. Value expressed in percentage regular until it reaches 90."]
pub const RESLIMIT_CPUTIME: ResourceLimitType = 9;
#[doc = "< Forces enum size to be 32 bits"]
pub const RESLIMIT_BIT: ResourceLimitType = 2147483648;
#[doc = "Types of resource limit"]
pub type ResourceLimitType = ::libc::c_uint;
#[doc = "< DMA transfer involving at least one device is starting and has not reached DMAWFP yet."]
pub const DMASTATE_STARTING: DmaState = 0;
#[doc = "< DMA channel is in WFP state for the destination device (2nd loop iteration onwards)."]
pub const DMASTATE_WFP_DST: DmaState = 1;
#[doc = "< DMA channel is in WFP state for the source device (2nd loop iteration onwards)."]
pub const DMASTATE_WFP_SRC: DmaState = 2;
#[doc = "< DMA transfer is running."]
pub const DMASTATE_RUNNING: DmaState = 3;
#[doc = "< DMA transfer is done."]
pub const DMASTATE_DONE: DmaState = 4;
#[doc = "DMA transfer state."]
pub type DmaState = ::libc::c_uchar;
#[doc = "< DMA source is a device/peripheral. Address will not auto-increment."]
pub const DMACFG_SRC_IS_DEVICE: _bindgen_ty_5 = 1;
#[doc = "< DMA destination is a device/peripheral. Address will not auto-increment."]
pub const DMACFG_DST_IS_DEVICE: _bindgen_ty_5 = 2;
#[doc = "< Make svcStartInterProcessDma wait for the channel to be unlocked."]
pub const DMACFG_WAIT_AVAILABLE: _bindgen_ty_5 = 4;
#[doc = "< Keep the channel locked after the transfer. Required for svcRestartDma."]
pub const DMACFG_KEEP_LOCKED: _bindgen_ty_5 = 8;
#[doc = "< Use the provided source device configuration even if the DMA source is not a device."]
pub const DMACFG_USE_SRC_CONFIG: _bindgen_ty_5 = 64;
#[doc = "< Use the provided destination device configuration even if the DMA destination is not a device."]
pub const DMACFG_USE_DST_CONFIG: _bindgen_ty_5 = 128;
#[doc = "Configuration flags for DmaConfig."]
pub type _bindgen_ty_5 = ::libc::c_uchar;
#[doc = "< Unlock the channel after transfer."]
pub const DMARST_UNLOCK: _bindgen_ty_6 = 1;
#[doc = "< Replace DMAFLUSHP instructions by NOP (they may not be regenerated even if this flag is not set)."]
pub const DMARST_RESUME_DEVICE: _bindgen_ty_6 = 2;
#[doc = "Configuration flags for svcRestartDma."]
pub type _bindgen_ty_6 = ::libc::c_uchar;
#[doc = "Device configuration structure, part of DmaConfig.\n > **Note:** - if (and only if) src/dst is a device, then src/dst won't be auto-incremented.\n - the kernel uses DMAMOV instead of DMAADNH, when having to decrement (possibly working around an erratum);\n this forces all loops to be unrolled -- you need to keep that in mind when using negative increments, as the kernel\n uses a limit of 100 DMA instruction bytes per channel."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DmaDeviceConfig {
    #[doc = "< DMA device ID."]
    pub deviceId: s8,
    #[doc = "< Mask of allowed access alignments (8, 4, 2, 1)."]
    pub allowedAlignments: s8,
    #[doc = "< Number of bytes transferred in a burst loop. Can be 0 (in which case the max allowed alignment is used as unit)."]
    pub burstSize: s16,
    #[doc = "< Number of bytes transferred in a \"transfer\" loop (made of burst loops)."]
    pub transferSize: s16,
    #[doc = "< Burst loop stride, can be <= 0."]
    pub burstStride: s16,
    #[doc = "< \"Transfer\" loop stride, can be <= 0."]
    pub transferStride: s16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DmaDeviceConfig"][::core::mem::size_of::<DmaDeviceConfig>() - 10usize];
    ["Alignment of DmaDeviceConfig"][::core::mem::align_of::<DmaDeviceConfig>() - 2usize];
    ["Offset of field: DmaDeviceConfig::deviceId"]
        [::core::mem::offset_of!(DmaDeviceConfig, deviceId) - 0usize];
    ["Offset of field: DmaDeviceConfig::allowedAlignments"]
        [::core::mem::offset_of!(DmaDeviceConfig, allowedAlignments) - 1usize];
    ["Offset of field: DmaDeviceConfig::burstSize"]
        [::core::mem::offset_of!(DmaDeviceConfig, burstSize) - 2usize];
    ["Offset of field: DmaDeviceConfig::transferSize"]
        [::core::mem::offset_of!(DmaDeviceConfig, transferSize) - 4usize];
    ["Offset of field: DmaDeviceConfig::burstStride"]
        [::core::mem::offset_of!(DmaDeviceConfig, burstStride) - 6usize];
    ["Offset of field: DmaDeviceConfig::transferStride"]
        [::core::mem::offset_of!(DmaDeviceConfig, transferStride) - 8usize];
};
#[doc = "Configuration stucture for svcStartInterProcessDma."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DmaConfig {
    #[doc = "< Channel ID (Arm11: 0-7, Arm9: 0-1). Use -1 to auto-assign to a free channel (Arm11: 3-7, Arm9: 0-1)."]
    pub channelId: s8,
    #[doc = "< Endian swap size (can be 0)."]
    pub endianSwapSize: s8,
    #[doc = "< DMACFG_* flags."]
    pub flags: u8_,
    pub _padding: u8_,
    #[doc = "< Source device configuration, read if DMACFG_SRC_IS_DEVICE and/or DMACFG_USE_SRC_CONFIG are set."]
    pub srcCfg: DmaDeviceConfig,
    #[doc = "< Destination device configuration, read if DMACFG_SRC_IS_DEVICE and/or DMACFG_USE_SRC_CONFIG are set."]
    pub dstCfg: DmaDeviceConfig,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DmaConfig"][::core::mem::size_of::<DmaConfig>() - 24usize];
    ["Alignment of DmaConfig"][::core::mem::align_of::<DmaConfig>() - 2usize];
    ["Offset of field: DmaConfig::channelId"]
        [::core::mem::offset_of!(DmaConfig, channelId) - 0usize];
    ["Offset of field: DmaConfig::endianSwapSize"]
        [::core::mem::offset_of!(DmaConfig, endianSwapSize) - 1usize];
    ["Offset of field: DmaConfig::flags"][::core::mem::offset_of!(DmaConfig, flags) - 2usize];
    ["Offset of field: DmaConfig::_padding"][::core::mem::offset_of!(DmaConfig, _padding) - 3usize];
    ["Offset of field: DmaConfig::srcCfg"][::core::mem::offset_of!(DmaConfig, srcCfg) - 4usize];
    ["Offset of field: DmaConfig::dstCfg"][::core::mem::offset_of!(DmaConfig, dstCfg) - 14usize];
};
#[doc = "< Enable and lock perfmon. functionality."]
pub const PERFCOUNTEROP_ENABLE: PerfCounterOperation = 0;
#[doc = "< Disable and forcibly unlock perfmon. functionality."]
pub const PERFCOUNTEROP_DISABLE: PerfCounterOperation = 1;
#[doc = "< Get the value of a counter register."]
pub const PERFCOUNTEROP_GET_VALUE: PerfCounterOperation = 2;
#[doc = "< Set the value of a counter register."]
pub const PERFCOUNTEROP_SET_VALUE: PerfCounterOperation = 3;
#[doc = "< Get the overflow flags for all CP15 and SCU counters."]
pub const PERFCOUNTEROP_GET_OVERFLOW_FLAGS: PerfCounterOperation = 4;
#[doc = "< Reset the value and/or overflow flags of selected counters."]
pub const PERFCOUNTEROP_RESET: PerfCounterOperation = 5;
#[doc = "< Get the event ID associated to a particular counter."]
pub const PERFCOUNTEROP_GET_EVENT: PerfCounterOperation = 6;
#[doc = "< Set the event ID associated to a paritcular counter."]
pub const PERFCOUNTEROP_SET_EVENT: PerfCounterOperation = 7;
#[doc = "< (Dis)allow the kernel to track counter overflows and to use 64-bit counter values."]
pub const PERFCOUNTEROP_SET_VIRTUAL_COUNTER_ENABLED: PerfCounterOperation = 8;
#[doc = "Operations for svcControlPerformanceCounter"]
pub type PerfCounterOperation = ::libc::c_uchar;
pub const PERFCOUNTERREG_CORE_BASE: PerfCounterRegister = 0;
#[doc = "< CP15 PMN0."]
pub const PERFCOUNTERREG_CORE_COUNT_REG_0: PerfCounterRegister = 0;
#[doc = "< CP15 PMN1."]
pub const PERFCOUNTERREG_CORE_COUNT_REG_1: PerfCounterRegister = 1;
#[doc = "< CP15 CCNT."]
pub const PERFCOUNTERREG_CORE_CYCLE_COUNTER: PerfCounterRegister = 2;
pub const PERFCOUNTERREG_SCU_BASE: PerfCounterRegister = 16;
#[doc = "< SCU MN0."]
pub const PERFCOUNTERREG_SCU_0: PerfCounterRegister = 16;
#[doc = "< SCU MN1."]
pub const PERFCOUNTERREG_SCU_1: PerfCounterRegister = 17;
#[doc = "< SCU MN2."]
pub const PERFCOUNTERREG_SCU_2: PerfCounterRegister = 18;
#[doc = "< SCU MN3."]
pub const PERFCOUNTERREG_SCU_3: PerfCounterRegister = 19;
#[doc = "< SCU MN4. Prod-N3DS only. IRQ line missing."]
pub const PERFCOUNTERREG_SCU_4: PerfCounterRegister = 20;
#[doc = "< SCU MN5. Prod-N3DS only. IRQ line missing."]
pub const PERFCOUNTERREG_SCU_5: PerfCounterRegister = 21;
#[doc = "< SCU MN6. Prod-N3DS only. IRQ line missing."]
pub const PERFCOUNTERREG_SCU_6: PerfCounterRegister = 22;
#[doc = "< SCU MN7. Prod-N3DS only. IRQ line missing."]
pub const PERFCOUNTERREG_SCU_7: PerfCounterRegister = 23;
#[doc = "Performance counter register IDs (CP15 and SCU)."]
pub type PerfCounterRegister = ::libc::c_uchar;
pub const PERFCOUNTEREVT_CORE_BASE: PerfCounterEvent = 0;
pub const PERFCOUNTEREVT_CORE_INST_CACHE_MISS: PerfCounterEvent = 0;
pub const PERFCOUNTEREVT_CORE_STALL_BY_LACK_OF_INST: PerfCounterEvent = 1;
pub const PERFCOUNTEREVT_CORE_STALL_BY_DATA_HAZARD: PerfCounterEvent = 2;
pub const PERFCOUNTEREVT_CORE_INST_MICRO_TLB_MISS: PerfCounterEvent = 3;
pub const PERFCOUNTEREVT_CORE_DATA_MICRO_TLB_MISS: PerfCounterEvent = 4;
pub const PERFCOUNTEREVT_CORE_BRANCH_INST: PerfCounterEvent = 5;
pub const PERFCOUNTEREVT_CORE_BRANCH_NOT_PREDICTED: PerfCounterEvent = 6;
pub const PERFCOUNTEREVT_CORE_BRANCH_MISS_PREDICTED: PerfCounterEvent = 7;
pub const PERFCOUNTEREVT_CORE_INST_EXECUTED: PerfCounterEvent = 8;
pub const PERFCOUNTEREVT_CORE_FOLDED_INST_EXECUTED: PerfCounterEvent = 9;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_READ: PerfCounterEvent = 10;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_READ_MISS: PerfCounterEvent = 11;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_WRITE: PerfCounterEvent = 12;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_WRITE_MISS: PerfCounterEvent = 13;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_LINE_EVICTION: PerfCounterEvent = 14;
pub const PERFCOUNTEREVT_CORE_PC_CHANGED: PerfCounterEvent = 15;
pub const PERFCOUNTEREVT_CORE_MAIN_TLB_MISS: PerfCounterEvent = 16;
pub const PERFCOUNTEREVT_CORE_EXTERNAL_REQUEST: PerfCounterEvent = 17;
pub const PERFCOUNTEREVT_CORE_STALL_BY_LSU_FULL: PerfCounterEvent = 18;
pub const PERFCOUNTEREVT_CORE_STORE_BUFFER_DRAIN: PerfCounterEvent = 19;
pub const PERFCOUNTEREVT_CORE_MERGE_IN_STORE_BUFFER: PerfCounterEvent = 20;
#[doc = "< One cycle elapsed."]
pub const PERFCOUNTEREVT_CORE_CYCLE_COUNT: PerfCounterEvent = 255;
#[doc = "< 64 cycles elapsed."]
pub const PERFCOUNTEREVT_CORE_CYCLE_COUNT_64: PerfCounterEvent = 4095;
pub const PERFCOUNTEREVT_SCU_BASE: PerfCounterEvent = 4096;
pub const PERFCOUNTEREVT_SCU_DISABLED: PerfCounterEvent = 4096;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE0: PerfCounterEvent = 4097;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE1: PerfCounterEvent = 4098;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE2: PerfCounterEvent = 4099;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE3: PerfCounterEvent = 4100;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE0: PerfCounterEvent = 4101;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE1: PerfCounterEvent = 4102;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE2: PerfCounterEvent = 4103;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE3: PerfCounterEvent = 4104;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE0: PerfCounterEvent = 4105;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE1: PerfCounterEvent = 4106;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE2: PerfCounterEvent = 4107;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE3: PerfCounterEvent = 4108;
pub const PERFCOUNTEREVT_SCU_LINE_MIGRATION: PerfCounterEvent = 4109;
pub const PERFCOUNTEREVT_SCU_READ_BUSY_PORT0: PerfCounterEvent = 4110;
pub const PERFCOUNTEREVT_SCU_READ_BUSY_PORT1: PerfCounterEvent = 4111;
pub const PERFCOUNTEREVT_SCU_WRITE_BUSY_PORT0: PerfCounterEvent = 4112;
pub const PERFCOUNTEREVT_SCU_WRITE_BUSY_PORT1: PerfCounterEvent = 4113;
pub const PERFCOUNTEREVT_SCU_EXTERNAL_READ: PerfCounterEvent = 4114;
pub const PERFCOUNTEREVT_SCU_EXTERNAL_WRITE: PerfCounterEvent = 4115;
pub const PERFCOUNTEREVT_SCU_CYCLE_COUNT: PerfCounterEvent = 4127;
#[doc = "Performance counter event IDs (CP15 or SCU).\n\n > **Note:** Refer to:\n - CP15: https://developer.arm.com/documentation/ddi0360/e/control-coprocessor-cp15/register-descriptions/c15--performance-monitor-control-register--pmnc-\n - SCU: https://developer.arm.com/documentation/ddi0360/e/mpcore-private-memory-region/about-the-mpcore-private-memory-region/performance-monitor-event-registers"]
pub type PerfCounterEvent = ::libc::c_ushort;
#[doc = "Event relating to the attachment of a process."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AttachProcessEvent {
    #[doc = "< ID of the program."]
    pub program_id: u64_,
    #[doc = "< Name of the process."]
    pub process_name: [::libc::c_char; 8usize],
    #[doc = "< ID of the process."]
    pub process_id: u32_,
    #[doc = "< Always 0"]
    pub other_flags: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AttachProcessEvent"][::core::mem::size_of::<AttachProcessEvent>() - 24usize];
    ["Alignment of AttachProcessEvent"][::core::mem::align_of::<AttachProcessEvent>() - 8usize];
    ["Offset of field: AttachProcessEvent::program_id"]
        [::core::mem::offset_of!(AttachProcessEvent, program_id) - 0usize];
    ["Offset of field: AttachProcessEvent::process_name"]
        [::core::mem::offset_of!(AttachProcessEvent, process_name) - 8usize];
    ["Offset of field: AttachProcessEvent::process_id"]
        [::core::mem::offset_of!(AttachProcessEvent, process_id) - 16usize];
    ["Offset of field: AttachProcessEvent::other_flags"]
        [::core::mem::offset_of!(AttachProcessEvent, other_flags) - 20usize];
};
#[doc = "< Process exited either normally or due to an uncaught exception."]
pub const EXITPROCESS_EVENT_EXIT: ExitProcessEventReason = 0;
#[doc = "< Process has been terminated by svcTerminateProcess."]
pub const EXITPROCESS_EVENT_TERMINATE: ExitProcessEventReason = 1;
#[doc = "< Process has been terminated by svcTerminateDebugProcess."]
pub const EXITPROCESS_EVENT_DEBUG_TERMINATE: ExitProcessEventReason = 2;
#[doc = "Reasons for an exit process event."]
pub type ExitProcessEventReason = ::libc::c_uchar;
#[doc = "Event relating to the exiting of a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExitProcessEvent {
    #[doc = "< Reason for exiting. See ExitProcessEventReason"]
    pub reason: ExitProcessEventReason,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExitProcessEvent"][::core::mem::size_of::<ExitProcessEvent>() - 1usize];
    ["Alignment of ExitProcessEvent"][::core::mem::align_of::<ExitProcessEvent>() - 1usize];
    ["Offset of field: ExitProcessEvent::reason"]
        [::core::mem::offset_of!(ExitProcessEvent, reason) - 0usize];
};
impl Default for ExitProcessEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Event relating to the attachment of a thread."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AttachThreadEvent {
    #[doc = "< ID of the creating thread."]
    pub creator_thread_id: u32_,
    #[doc = "< Thread local storage."]
    pub thread_local_storage: u32_,
    #[doc = "< Entry point of the thread."]
    pub entry_point: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AttachThreadEvent"][::core::mem::size_of::<AttachThreadEvent>() - 12usize];
    ["Alignment of AttachThreadEvent"][::core::mem::align_of::<AttachThreadEvent>() - 4usize];
    ["Offset of field: AttachThreadEvent::creator_thread_id"]
        [::core::mem::offset_of!(AttachThreadEvent, creator_thread_id) - 0usize];
    ["Offset of field: AttachThreadEvent::thread_local_storage"]
        [::core::mem::offset_of!(AttachThreadEvent, thread_local_storage) - 4usize];
    ["Offset of field: AttachThreadEvent::entry_point"]
        [::core::mem::offset_of!(AttachThreadEvent, entry_point) - 8usize];
};
#[doc = "< Thread exited."]
pub const EXITTHREAD_EVENT_EXIT: ExitThreadEventReason = 0;
#[doc = "< Thread terminated."]
pub const EXITTHREAD_EVENT_TERMINATE: ExitThreadEventReason = 1;
#[doc = "< Process exited either normally or due to an uncaught exception."]
pub const EXITTHREAD_EVENT_EXIT_PROCESS: ExitThreadEventReason = 2;
#[doc = "< Process has been terminated by svcTerminateProcess."]
pub const EXITTHREAD_EVENT_TERMINATE_PROCESS: ExitThreadEventReason = 3;
#[doc = "Reasons for an exit thread event."]
pub type ExitThreadEventReason = ::libc::c_uchar;
#[doc = "Event relating to the exiting of a thread."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExitThreadEvent {
    #[doc = "< Reason for exiting. See ExitThreadEventReason"]
    pub reason: ExitThreadEventReason,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExitThreadEvent"][::core::mem::size_of::<ExitThreadEvent>() - 1usize];
    ["Alignment of ExitThreadEvent"][::core::mem::align_of::<ExitThreadEvent>() - 1usize];
    ["Offset of field: ExitThreadEvent::reason"]
        [::core::mem::offset_of!(ExitThreadEvent, reason) - 0usize];
};
impl Default for ExitThreadEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Panic."]
pub const USERBREAK_PANIC: UserBreakType = 0;
#[doc = "< Assertion failed."]
pub const USERBREAK_ASSERT: UserBreakType = 1;
#[doc = "< User related."]
pub const USERBREAK_USER: UserBreakType = 2;
#[doc = "< Load RO."]
pub const USERBREAK_LOAD_RO: UserBreakType = 3;
#[doc = "< Unload RO."]
pub const USERBREAK_UNLOAD_RO: UserBreakType = 4;
#[doc = "Reasons for a user break."]
pub type UserBreakType = ::libc::c_uchar;
#[doc = "< Undefined instruction."]
pub const EXCEVENT_UNDEFINED_INSTRUCTION: ExceptionEventType = 0;
#[doc = "< Prefetch abort."]
pub const EXCEVENT_PREFETCH_ABORT: ExceptionEventType = 1;
#[doc = "< Data abort (other than the below kind)."]
pub const EXCEVENT_DATA_ABORT: ExceptionEventType = 2;
#[doc = "< Unaligned data access."]
pub const EXCEVENT_UNALIGNED_DATA_ACCESS: ExceptionEventType = 3;
#[doc = "< Attached break."]
pub const EXCEVENT_ATTACH_BREAK: ExceptionEventType = 4;
#[doc = "< Stop point reached."]
pub const EXCEVENT_STOP_POINT: ExceptionEventType = 5;
#[doc = "< User break occurred."]
pub const EXCEVENT_USER_BREAK: ExceptionEventType = 6;
#[doc = "< Debugger break occurred."]
pub const EXCEVENT_DEBUGGER_BREAK: ExceptionEventType = 7;
#[doc = "< Undefined syscall."]
pub const EXCEVENT_UNDEFINED_SYSCALL: ExceptionEventType = 8;
#[doc = "Reasons for an exception event."]
pub type ExceptionEventType = ::libc::c_uchar;
#[doc = "Event relating to fault exceptions (CPU exceptions other than stop points and undefined syscalls)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FaultExceptionEvent {
    #[doc = "< FAR (for DATA ABORT / UNALIGNED DATA ACCESS), attempted syscall or 0"]
    pub fault_information: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FaultExceptionEvent"][::core::mem::size_of::<FaultExceptionEvent>() - 4usize];
    ["Alignment of FaultExceptionEvent"][::core::mem::align_of::<FaultExceptionEvent>() - 4usize];
    ["Offset of field: FaultExceptionEvent::fault_information"]
        [::core::mem::offset_of!(FaultExceptionEvent, fault_information) - 0usize];
};
#[doc = "< See SVC_STOP_POINT."]
pub const STOPPOINT_SVC_FF: StopPointType = 0;
#[doc = "< Breakpoint."]
pub const STOPPOINT_BREAKPOINT: StopPointType = 1;
#[doc = "< Watchpoint."]
pub const STOPPOINT_WATCHPOINT: StopPointType = 2;
#[doc = "Stop point types"]
pub type StopPointType = ::libc::c_uchar;
#[doc = "Event relating to stop points"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StopPointExceptionEvent {
    #[doc = "< Stop point type, see StopPointType."]
    pub type_: StopPointType,
    #[doc = "< FAR for Watchpoints, otherwise 0."]
    pub fault_information: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of StopPointExceptionEvent"][::core::mem::size_of::<StopPointExceptionEvent>() - 8usize];
    ["Alignment of StopPointExceptionEvent"]
        [::core::mem::align_of::<StopPointExceptionEvent>() - 4usize];
    ["Offset of field: StopPointExceptionEvent::type_"]
        [::core::mem::offset_of!(StopPointExceptionEvent, type_) - 0usize];
    ["Offset of field: StopPointExceptionEvent::fault_information"]
        [::core::mem::offset_of!(StopPointExceptionEvent, fault_information) - 4usize];
};
impl Default for StopPointExceptionEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Event relating to svcBreak"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserBreakExceptionEvent {
    #[doc = "< User break type, see UserBreakType."]
    pub type_: UserBreakType,
    #[doc = "< For LOAD_RO and UNLOAD_RO."]
    pub croInfo: u32_,
    #[doc = "< For LOAD_RO and UNLOAD_RO."]
    pub croInfoSize: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of UserBreakExceptionEvent"]
        [::core::mem::size_of::<UserBreakExceptionEvent>() - 12usize];
    ["Alignment of UserBreakExceptionEvent"]
        [::core::mem::align_of::<UserBreakExceptionEvent>() - 4usize];
    ["Offset of field: UserBreakExceptionEvent::type_"]
        [::core::mem::offset_of!(UserBreakExceptionEvent, type_) - 0usize];
    ["Offset of field: UserBreakExceptionEvent::croInfo"]
        [::core::mem::offset_of!(UserBreakExceptionEvent, croInfo) - 4usize];
    ["Offset of field: UserBreakExceptionEvent::croInfoSize"]
        [::core::mem::offset_of!(UserBreakExceptionEvent, croInfoSize) - 8usize];
};
impl Default for UserBreakExceptionEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Event relating to svcBreakDebugProcess"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DebuggerBreakExceptionEvent {
    #[doc = "< IDs of the attached process's threads that were running on each core at the time of the svcBreakDebugProcess call, or -1 (only the first 2 values are meaningful on O3DS)."]
    pub thread_ids: [s32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DebuggerBreakExceptionEvent"]
        [::core::mem::size_of::<DebuggerBreakExceptionEvent>() - 16usize];
    ["Alignment of DebuggerBreakExceptionEvent"]
        [::core::mem::align_of::<DebuggerBreakExceptionEvent>() - 4usize];
    ["Offset of field: DebuggerBreakExceptionEvent::thread_ids"]
        [::core::mem::offset_of!(DebuggerBreakExceptionEvent, thread_ids) - 0usize];
};
#[doc = "Event relating to exceptions."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExceptionEvent {
    #[doc = "< Type of event. See ExceptionEventType."]
    pub type_: ExceptionEventType,
    #[doc = "< Address of the exception."]
    pub address: u32_,
    pub __bindgen_anon_1: ExceptionEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ExceptionEvent__bindgen_ty_1 {
    #[doc = "< Fault exception event data."]
    pub fault: FaultExceptionEvent,
    #[doc = "< Stop point exception event data."]
    pub stop_point: StopPointExceptionEvent,
    #[doc = "< User break exception event data."]
    pub user_break: UserBreakExceptionEvent,
    #[doc = "< Debugger break exception event data"]
    pub debugger_break: DebuggerBreakExceptionEvent,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExceptionEvent__bindgen_ty_1"]
        [::core::mem::size_of::<ExceptionEvent__bindgen_ty_1>() - 16usize];
    ["Alignment of ExceptionEvent__bindgen_ty_1"]
        [::core::mem::align_of::<ExceptionEvent__bindgen_ty_1>() - 4usize];
    ["Offset of field: ExceptionEvent__bindgen_ty_1::fault"]
        [::core::mem::offset_of!(ExceptionEvent__bindgen_ty_1, fault) - 0usize];
    ["Offset of field: ExceptionEvent__bindgen_ty_1::stop_point"]
        [::core::mem::offset_of!(ExceptionEvent__bindgen_ty_1, stop_point) - 0usize];
    ["Offset of field: ExceptionEvent__bindgen_ty_1::user_break"]
        [::core::mem::offset_of!(ExceptionEvent__bindgen_ty_1, user_break) - 0usize];
    ["Offset of field: ExceptionEvent__bindgen_ty_1::debugger_break"]
        [::core::mem::offset_of!(ExceptionEvent__bindgen_ty_1, debugger_break) - 0usize];
};
impl Default for ExceptionEvent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExceptionEvent"][::core::mem::size_of::<ExceptionEvent>() - 24usize];
    ["Alignment of ExceptionEvent"][::core::mem::align_of::<ExceptionEvent>() - 4usize];
    ["Offset of field: ExceptionEvent::type_"]
        [::core::mem::offset_of!(ExceptionEvent, type_) - 0usize];
    ["Offset of field: ExceptionEvent::address"]
        [::core::mem::offset_of!(ExceptionEvent, address) - 4usize];
};
impl Default for ExceptionEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Event relating to the scheduler."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScheduleInOutEvent {
    #[doc = "< Clock tick that the event occurred."]
    pub clock_tick: u64_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScheduleInOutEvent"][::core::mem::size_of::<ScheduleInOutEvent>() - 8usize];
    ["Alignment of ScheduleInOutEvent"][::core::mem::align_of::<ScheduleInOutEvent>() - 8usize];
    ["Offset of field: ScheduleInOutEvent::clock_tick"]
        [::core::mem::offset_of!(ScheduleInOutEvent, clock_tick) - 0usize];
};
#[doc = "Event relating to syscalls."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SyscallInOutEvent {
    #[doc = "< Clock tick that the event occurred."]
    pub clock_tick: u64_,
    #[doc = "< Syscall sent/received."]
    pub syscall: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SyscallInOutEvent"][::core::mem::size_of::<SyscallInOutEvent>() - 16usize];
    ["Alignment of SyscallInOutEvent"][::core::mem::align_of::<SyscallInOutEvent>() - 8usize];
    ["Offset of field: SyscallInOutEvent::clock_tick"]
        [::core::mem::offset_of!(SyscallInOutEvent, clock_tick) - 0usize];
    ["Offset of field: SyscallInOutEvent::syscall"]
        [::core::mem::offset_of!(SyscallInOutEvent, syscall) - 8usize];
};
#[doc = "Event relating to debug output."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OutputStringEvent {
    #[doc = "< Address of the outputted string."]
    pub string_addr: u32_,
    #[doc = "< Size of the outputted string."]
    pub string_size: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OutputStringEvent"][::core::mem::size_of::<OutputStringEvent>() - 8usize];
    ["Alignment of OutputStringEvent"][::core::mem::align_of::<OutputStringEvent>() - 4usize];
    ["Offset of field: OutputStringEvent::string_addr"]
        [::core::mem::offset_of!(OutputStringEvent, string_addr) - 0usize];
    ["Offset of field: OutputStringEvent::string_size"]
        [::core::mem::offset_of!(OutputStringEvent, string_size) - 4usize];
};
#[doc = "Event relating to the mapping of memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MapEvent {
    #[doc = "< Mapped address."]
    pub mapped_addr: u32_,
    #[doc = "< Mapped size."]
    pub mapped_size: u32_,
    #[doc = "< Memory permissions. See MemPerm."]
    pub memperm: MemPerm,
    #[doc = "< Memory state. See MemState."]
    pub memstate: MemState,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MapEvent"][::core::mem::size_of::<MapEvent>() - 16usize];
    ["Alignment of MapEvent"][::core::mem::align_of::<MapEvent>() - 4usize];
    ["Offset of field: MapEvent::mapped_addr"]
        [::core::mem::offset_of!(MapEvent, mapped_addr) - 0usize];
    ["Offset of field: MapEvent::mapped_size"]
        [::core::mem::offset_of!(MapEvent, mapped_size) - 4usize];
    ["Offset of field: MapEvent::memperm"][::core::mem::offset_of!(MapEvent, memperm) - 8usize];
    ["Offset of field: MapEvent::memstate"][::core::mem::offset_of!(MapEvent, memstate) - 12usize];
};
impl Default for MapEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Process attached event."]
pub const DBGEVENT_ATTACH_PROCESS: DebugEventType = 0;
#[doc = "< Thread attached event."]
pub const DBGEVENT_ATTACH_THREAD: DebugEventType = 1;
#[doc = "< Thread exit event."]
pub const DBGEVENT_EXIT_THREAD: DebugEventType = 2;
#[doc = "< Process exit event."]
pub const DBGEVENT_EXIT_PROCESS: DebugEventType = 3;
#[doc = "< Exception event."]
pub const DBGEVENT_EXCEPTION: DebugEventType = 4;
#[doc = "< DLL load event."]
pub const DBGEVENT_DLL_LOAD: DebugEventType = 5;
#[doc = "< DLL unload event."]
pub const DBGEVENT_DLL_UNLOAD: DebugEventType = 6;
#[doc = "< Schedule in event."]
pub const DBGEVENT_SCHEDULE_IN: DebugEventType = 7;
#[doc = "< Schedule out event."]
pub const DBGEVENT_SCHEDULE_OUT: DebugEventType = 8;
#[doc = "< Syscall in event."]
pub const DBGEVENT_SYSCALL_IN: DebugEventType = 9;
#[doc = "< Syscall out event."]
pub const DBGEVENT_SYSCALL_OUT: DebugEventType = 10;
#[doc = "< Output string event."]
pub const DBGEVENT_OUTPUT_STRING: DebugEventType = 11;
#[doc = "< Map event."]
pub const DBGEVENT_MAP: DebugEventType = 12;
#[doc = "Debug event type."]
pub type DebugEventType = ::libc::c_uchar;
#[doc = "Information about a debug event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugEventInfo {
    #[doc = "< Type of event. See DebugEventType"]
    pub type_: DebugEventType,
    #[doc = "< ID of the thread."]
    pub thread_id: u32_,
    #[doc = "< Flags. Bit0 means that svcContinueDebugEvent needs to be called for this event (except for EXIT PROCESS events, where this flag is disregarded)."]
    pub flags: u32_,
    #[doc = "< Always 0."]
    pub remnants: [u8_; 4usize],
    pub __bindgen_anon_1: DebugEventInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DebugEventInfo__bindgen_ty_1 {
    #[doc = "< Process attachment event data."]
    pub attach_process: AttachProcessEvent,
    #[doc = "< Thread attachment event data."]
    pub attach_thread: AttachThreadEvent,
    #[doc = "< Thread exit event data."]
    pub exit_thread: ExitThreadEvent,
    #[doc = "< Process exit event data."]
    pub exit_process: ExitProcessEvent,
    #[doc = "< Exception event data."]
    pub exception: ExceptionEvent,
    #[doc = "< Schedule in/out event data."]
    pub scheduler: ScheduleInOutEvent,
    #[doc = "< Syscall in/out event data."]
    pub syscall: SyscallInOutEvent,
    #[doc = "< Output string event data."]
    pub output_string: OutputStringEvent,
    #[doc = "< Map event data."]
    pub map: MapEvent,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DebugEventInfo__bindgen_ty_1"]
        [::core::mem::size_of::<DebugEventInfo__bindgen_ty_1>() - 24usize];
    ["Alignment of DebugEventInfo__bindgen_ty_1"]
        [::core::mem::align_of::<DebugEventInfo__bindgen_ty_1>() - 8usize];
    ["Offset of field: DebugEventInfo__bindgen_ty_1::attach_process"]
        [::core::mem::offset_of!(DebugEventInfo__bindgen_ty_1, attach_process) - 0usize];
    ["Offset of field: DebugEventInfo__bindgen_ty_1::attach_thread"]
        [::core::mem::offset_of!(DebugEventInfo__bindgen_ty_1, attach_thread) - 0usize];
    ["Offset of field: DebugEventInfo__bindgen_ty_1::exit_thread"]
        [::core::mem::offset_of!(DebugEventInfo__bindgen_ty_1, exit_thread) - 0usize];
    ["Offset of field: DebugEventInfo__bindgen_ty_1::exit_process"]
        [::core::mem::offset_of!(DebugEventInfo__bindgen_ty_1, exit_process) - 0usize];
    ["Offset of field: DebugEventInfo__bindgen_ty_1::exception"]
        [::core::mem::offset_of!(DebugEventInfo__bindgen_ty_1, exception) - 0usize];
    ["Offset of field: DebugEventInfo__bindgen_ty_1::scheduler"]
        [::core::mem::offset_of!(DebugEventInfo__bindgen_ty_1, scheduler) - 0usize];
    ["Offset of field: DebugEventInfo__bindgen_ty_1::syscall"]
        [::core::mem::offset_of!(DebugEventInfo__bindgen_ty_1, syscall) - 0usize];
    ["Offset of field: DebugEventInfo__bindgen_ty_1::output_string"]
        [::core::mem::offset_of!(DebugEventInfo__bindgen_ty_1, output_string) - 0usize];
    ["Offset of field: DebugEventInfo__bindgen_ty_1::map"]
        [::core::mem::offset_of!(DebugEventInfo__bindgen_ty_1, map) - 0usize];
};
impl Default for DebugEventInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DebugEventInfo"][::core::mem::size_of::<DebugEventInfo>() - 40usize];
    ["Alignment of DebugEventInfo"][::core::mem::align_of::<DebugEventInfo>() - 8usize];
    ["Offset of field: DebugEventInfo::type_"]
        [::core::mem::offset_of!(DebugEventInfo, type_) - 0usize];
    ["Offset of field: DebugEventInfo::thread_id"]
        [::core::mem::offset_of!(DebugEventInfo, thread_id) - 4usize];
    ["Offset of field: DebugEventInfo::flags"]
        [::core::mem::offset_of!(DebugEventInfo, flags) - 8usize];
    ["Offset of field: DebugEventInfo::remnants"]
        [::core::mem::offset_of!(DebugEventInfo, remnants) - 12usize];
};
impl Default for DebugEventInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Inhibit user-defined CPU exception handlers (including watchpoints and breakpoints, regardless of any svcKernelSetState call)."]
pub const DBG_INHIBIT_USER_CPU_EXCEPTION_HANDLERS: DebugFlags = 1;
#[doc = "< Signal fault exception events. See FaultExceptionEvent."]
pub const DBG_SIGNAL_FAULT_EXCEPTION_EVENTS: DebugFlags = 2;
#[doc = "< Signal schedule in/out events. See ScheduleInOutEvent."]
pub const DBG_SIGNAL_SCHEDULE_EVENTS: DebugFlags = 4;
#[doc = "< Signal syscall in/out events. See SyscallInOutEvent."]
pub const DBG_SIGNAL_SYSCALL_EVENTS: DebugFlags = 8;
#[doc = "< Signal map events. See MapEvent."]
pub const DBG_SIGNAL_MAP_EVENTS: DebugFlags = 16;
#[doc = "Debug flags for an attached process, set by svcContinueDebugEvent"]
pub type DebugFlags = ::libc::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ThreadContext {
    #[doc = "< CPU registers."]
    pub cpu_registers: CpuRegisters,
    #[doc = "< FPU registers."]
    pub fpu_registers: FpuRegisters,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ThreadContext"][::core::mem::size_of::<ThreadContext>() - 204usize];
    ["Alignment of ThreadContext"][::core::mem::align_of::<ThreadContext>() - 4usize];
    ["Offset of field: ThreadContext::cpu_registers"]
        [::core::mem::offset_of!(ThreadContext, cpu_registers) - 0usize];
    ["Offset of field: ThreadContext::fpu_registers"]
        [::core::mem::offset_of!(ThreadContext, fpu_registers) - 68usize];
};
impl Default for ThreadContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Control r0-r12."]
pub const THREADCONTEXT_CONTROL_CPU_GPRS: ThreadContextControlFlags = 1;
#[doc = "< Control sp, lr, pc, cpsr."]
pub const THREADCONTEXT_CONTROL_CPU_SPRS: ThreadContextControlFlags = 2;
#[doc = "< Control d0-d15 (or s0-s31)."]
pub const THREADCONTEXT_CONTROL_FPU_GPRS: ThreadContextControlFlags = 4;
#[doc = "< Control fpscr, fpexc."]
pub const THREADCONTEXT_CONTROL_FPU_SPRS: ThreadContextControlFlags = 8;
#[doc = "< Control r0-r12, sp, lr, pc, cpsr."]
pub const THREADCONTEXT_CONTROL_CPU_REGS: ThreadContextControlFlags = 3;
#[doc = "< Control d0-d15, fpscr, fpexc."]
pub const THREADCONTEXT_CONTROL_FPU_REGS: ThreadContextControlFlags = 12;
#[doc = "< Control all of the above."]
pub const THREADCONTEXT_CONTROL_ALL: ThreadContextControlFlags = 15;
#[doc = "Control flags for svcGetDebugThreadContext and svcSetDebugThreadContext"]
pub type ThreadContextControlFlags = ::libc::c_uchar;
#[doc = "< Thread priority."]
pub const DBGTHREAD_PARAMETER_PRIORITY: DebugThreadParameter = 0;
#[doc = "< Low scheduling mask."]
pub const DBGTHREAD_PARAMETER_SCHEDULING_MASK_LOW: DebugThreadParameter = 1;
#[doc = "< Ideal processor."]
pub const DBGTHREAD_PARAMETER_CPU_IDEAL: DebugThreadParameter = 2;
#[doc = "< Processor that created the threod."]
pub const DBGTHREAD_PARAMETER_CPU_CREATOR: DebugThreadParameter = 3;
#[doc = "Thread parameter field for svcGetDebugThreadParameter"]
pub type DebugThreadParameter = ::libc::c_uchar;
#[doc = "Information on address space for process. All sizes are in pages (0x1000 bytes)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CodeSetHeader {
    #[doc = "< ASCII name of codeset"]
    pub name: [u8_; 8usize],
    #[doc = "< Version field of codeset (unused)"]
    pub version: u16_,
    #[doc = "< Padding"]
    pub padding: [u16_; 3usize],
    #[doc = "< .text start address"]
    pub text_addr: u32_,
    #[doc = "< .text number of pages"]
    pub text_size: u32_,
    #[doc = "< .rodata start address"]
    pub ro_addr: u32_,
    #[doc = "< .rodata number of pages"]
    pub ro_size: u32_,
    #[doc = "< .data, .bss start address"]
    pub rw_addr: u32_,
    #[doc = "< .data number of pages"]
    pub rw_size: u32_,
    #[doc = "< total pages for .text (aligned)"]
    pub text_size_total: u32_,
    #[doc = "< total pages for .rodata (aligned)"]
    pub ro_size_total: u32_,
    #[doc = "< total pages for .data, .bss (aligned)"]
    pub rw_size_total: u32_,
    #[doc = "< Padding"]
    pub padding2: u32_,
    #[doc = "< Program ID"]
    pub program_id: u64_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CodeSetHeader"][::core::mem::size_of::<CodeSetHeader>() - 64usize];
    ["Alignment of CodeSetHeader"][::core::mem::align_of::<CodeSetHeader>() - 8usize];
    ["Offset of field: CodeSetHeader::name"][::core::mem::offset_of!(CodeSetHeader, name) - 0usize];
    ["Offset of field: CodeSetHeader::version"]
        [::core::mem::offset_of!(CodeSetHeader, version) - 8usize];
    ["Offset of field: CodeSetHeader::padding"]
        [::core::mem::offset_of!(CodeSetHeader, padding) - 10usize];
    ["Offset of field: CodeSetHeader::text_addr"]
        [::core::mem::offset_of!(CodeSetHeader, text_addr) - 16usize];
    ["Offset of field: CodeSetHeader::text_size"]
        [::core::mem::offset_of!(CodeSetHeader, text_size) - 20usize];
    ["Offset of field: CodeSetHeader::ro_addr"]
        [::core::mem::offset_of!(CodeSetHeader, ro_addr) - 24usize];
    ["Offset of field: CodeSetHeader::ro_size"]
        [::core::mem::offset_of!(CodeSetHeader, ro_size) - 28usize];
    ["Offset of field: CodeSetHeader::rw_addr"]
        [::core::mem::offset_of!(CodeSetHeader, rw_addr) - 32usize];
    ["Offset of field: CodeSetHeader::rw_size"]
        [::core::mem::offset_of!(CodeSetHeader, rw_size) - 36usize];
    ["Offset of field: CodeSetHeader::text_size_total"]
        [::core::mem::offset_of!(CodeSetHeader, text_size_total) - 40usize];
    ["Offset of field: CodeSetHeader::ro_size_total"]
        [::core::mem::offset_of!(CodeSetHeader, ro_size_total) - 44usize];
    ["Offset of field: CodeSetHeader::rw_size_total"]
        [::core::mem::offset_of!(CodeSetHeader, rw_size_total) - 48usize];
    ["Offset of field: CodeSetHeader::padding2"]
        [::core::mem::offset_of!(CodeSetHeader, padding2) - 52usize];
    ["Offset of field: CodeSetHeader::program_id"]
        [::core::mem::offset_of!(CodeSetHeader, program_id) - 56usize];
};
#[doc = "Information for the main thread of a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StartupInfo {
    #[doc = "< Priority of the main thread."]
    pub priority: ::libc::c_int,
    #[doc = "< Size of the stack of the main thread."]
    pub stack_size: u32_,
    #[doc = "< Unused on retail kernel."]
    pub argc: ::libc::c_int,
    #[doc = "< Unused on retail kernel."]
    pub argv: *mut u16_,
    #[doc = "< Unused on retail kernel."]
    pub envp: *mut u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of StartupInfo"][::core::mem::size_of::<StartupInfo>() - 20usize];
    ["Alignment of StartupInfo"][::core::mem::align_of::<StartupInfo>() - 4usize];
    ["Offset of field: StartupInfo::priority"]
        [::core::mem::offset_of!(StartupInfo, priority) - 0usize];
    ["Offset of field: StartupInfo::stack_size"]
        [::core::mem::offset_of!(StartupInfo, stack_size) - 4usize];
    ["Offset of field: StartupInfo::argc"][::core::mem::offset_of!(StartupInfo, argc) - 8usize];
    ["Offset of field: StartupInfo::argv"][::core::mem::offset_of!(StartupInfo, argv) - 12usize];
    ["Offset of field: StartupInfo::envp"][::core::mem::offset_of!(StartupInfo, envp) - 16usize];
};
impl Default for StartupInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = "Gets the thread local storage buffer.\n # Returns\n\nThe thread local storage buffer."]
    #[link_name = "getThreadLocalStorage__extern"]
    pub fn getThreadLocalStorage() -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[doc = "Gets the thread command buffer.\n # Returns\n\nThe thread command buffer."]
    #[link_name = "getThreadCommandBuffer__extern"]
    pub fn getThreadCommandBuffer() -> *mut u32_;
}
unsafe extern "C" {
    #[doc = "Gets the thread static buffer.\n # Returns\n\nThe thread static buffer."]
    #[link_name = "getThreadStaticBuffers__extern"]
    pub fn getThreadStaticBuffers() -> *mut u32_;
}
unsafe extern "C" {
    #[doc = "Writes the default DMA device config that the kernel uses when DMACFG_*_IS_DEVICE and DMACFG_*_USE_CFG are not set"]
    #[link_name = "dmaDeviceConfigInitDefault__extern"]
    pub fn dmaDeviceConfigInitDefault(cfg: *mut DmaDeviceConfig);
}
unsafe extern "C" {
    #[doc = "Initializes a DmaConfig instance with sane defaults for RAM<>RAM tranfers"]
    #[link_name = "dmaConfigInitDefault__extern"]
    pub fn dmaConfigInitDefault(cfg: *mut DmaConfig);
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Memory management\n# *\n* Controls memory mapping\n # Arguments\n\n* `addr_out` (direction out) - The virtual address resulting from the operation. Usually the same as addr0.\n * `addr0` - The virtual address to be used for the operation.\n * `addr1` - The virtual address to be (un)mirrored by `addr0` when using MEMOP_MAP or MEMOP_UNMAP.\n It has to be pointing to a RW memory.\n* Use NULL if the operation is MEMOP_FREE or MEMOP_ALLOC.\n * `size` - The requested size for MEMOP_ALLOC and MEMOP_ALLOC_LINEAR.\n * `op` - Operation flags. See MemOp.\n * `perm` - A combination of MEMPERM_READ and MEMPERM_WRITE. Using MEMPERM_EXECUTE will return an error.\n Value 0 is used when unmapping memory.\n*\n* If a memory is mapped for two or more addresses, you have to use MEMOP_UNMAP before being able to MEMOP_FREE it.\n* MEMOP_MAP will fail if `addr1` was already mapped to another address.\n\n* More information is available at http://3dbrew.org/wiki/SVC#Memory_Mapping.\n*\n* [`svcControlProcessMemory`]\n/"]
    pub fn svcControlMemory(
        addr_out: *mut u32_,
        addr0: u32_,
        addr1: u32_,
        size: u32_,
        op: MemOp,
        perm: MemPerm,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Controls the memory mapping of a process\n # Arguments\n\n* `addr0` - The virtual address to map\n * `addr1` - The virtual address to be mapped by `addr0`\n * `type` - Only operations MEMOP_MAP, MEMOP_UNMAP and MEMOP_PROT are allowed.\n\n This is the only SVC which allows mapping executable memory.\n Using MEMOP_PROT will change the memory permissions of an already mapped memory.\n\n > **Note:** The pseudo handle for the current process is not supported by this service call.\n [`svcControlProcess`]"]
    pub fn svcControlProcessMemory(
        process: Handle,
        addr0: u32_,
        addr1: u32_,
        size: u32_,
        type_: u32_,
        perm: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a block of shared memory\n # Arguments\n\n* `memblock` (direction out) - Pointer to store the handle of the block\n * `addr` - Address of the memory to map, page-aligned. So its alignment must be 0x1000.\n * `size` - Size of the memory to map, a multiple of 0x1000.\n * `my_perm` - Memory permissions for the current process\n * `other_perm` - Memory permissions for the other processes\n\n > **Note:** The shared memory block, and its rights, are destroyed when the handle is closed."]
    pub fn svcCreateMemoryBlock(
        memblock: *mut Handle,
        addr: u32_,
        size: u32_,
        my_perm: MemPerm,
        other_perm: MemPerm,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Maps a block of shared memory\n # Arguments\n\n* `memblock` - Handle of the block\n * `addr` - Address of the memory to map, page-aligned. So its alignment must be 0x1000.\n * `my_perm` - Memory permissions for the current process\n * `other_perm` - Memory permissions for the other processes\n\n > **Note:** The shared memory block, and its rights, are destroyed when the handle is closed."]
    pub fn svcMapMemoryBlock(
        memblock: Handle,
        addr: u32_,
        my_perm: MemPerm,
        other_perm: MemPerm,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Maps a block of process memory, starting from address 0x00100000.\n # Arguments\n\n* `process` - Handle of the process.\n * `destAddress` - Address of the block of memory to map, in the current (destination) process.\n * `size` - Size of the block of memory to map (truncated to a multiple of 0x1000 bytes)."]
    pub fn svcMapProcessMemory(process: Handle, destAddress: u32_, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unmaps a block of process memory, starting from address 0x00100000.\n # Arguments\n\n* `process` - Handle of the process.\n * `destAddress` - Address of the block of memory to unmap, in the current (destination) process.\n * `size` - Size of the block of memory to unmap (truncated to a multiple of 0x1000 bytes)."]
    pub fn svcUnmapProcessMemory(process: Handle, destAddress: u32_, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unmaps a block of shared memory\n # Arguments\n\n* `memblock` - Handle of the block\n * `addr` - Address of the memory to unmap, page-aligned. So its alignment must be 0x1000."]
    pub fn svcUnmapMemoryBlock(memblock: Handle, addr: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Queries memory information.\n # Arguments\n\n* `info` (direction out) - Pointer to output memory info to.\n * `out` - Pointer to output page info to.\n * `addr` - Virtual memory address to query."]
    pub fn svcQueryMemory(info: *mut MemInfo, out: *mut PageInfo, addr: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Queries process memory information.\n # Arguments\n\n* `info` (direction out) - Pointer to output memory info to.\n * `out` (direction out) - Pointer to output page info to.\n * `process` - Process to query memory from.\n * `addr` - Virtual memory address to query."]
    pub fn svcQueryProcessMemory(
        info: *mut MemInfo,
        out: *mut PageInfo,
        process: Handle,
        addr: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Process management\n# *\n* Gets the handle of a process.\n # Arguments\n\n* `process` (direction out) - The handle of the process\n * `processId` - The ID of the process to open\n/"]
    pub fn svcOpenProcess(process: *mut Handle, processId: u32_) -> Result;
}
unsafe extern "C" {
    #[doc = "Exits the current process."]
    pub fn svcExitProcess() -> !;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Terminates a process.\n # Arguments\n\n* `process` - Handle of the process to terminate."]
    pub fn svcTerminateProcess(process: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets information about a process.\n # Arguments\n\n* `out` (direction out) - Pointer to output process info to.\n * `process` - Handle of the process to get information about.\n * `type` - Type of information to retreieve."]
    pub fn svcGetProcessInfo(out: *mut s64, process: Handle, type_: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the ID of a process.\n # Arguments\n\n* `out` (direction out) - Pointer to output the process ID to.\n * `handle` - Handle of the process to get the ID of."]
    pub fn svcGetProcessId(out: *mut u32_, handle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a list of running processes.\n # Arguments\n\n* `processCount` (direction out) - Pointer to output the process count to.\n * `processIds` (direction out) - Pointer to output the process IDs to.\n * `processIdMaxCount` - Maximum number of process IDs."]
    pub fn svcGetProcessList(
        processCount: *mut s32,
        processIds: *mut u32_,
        processIdMaxCount: s32,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a list of the threads of a process.\n # Arguments\n\n* `threadCount` (direction out) - Pointer to output the thread count to.\n * `threadIds` (direction out) - Pointer to output the thread IDs to.\n * `threadIdMaxCount` - Maximum number of thread IDs.\n * `process` - Process handle to list the threads of."]
    pub fn svcGetThreadList(
        threadCount: *mut s32,
        threadIds: *mut u32_,
        threadIdMaxCount: s32,
        process: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a port.\n # Arguments\n\n* `portServer` (direction out) - Pointer to output the port server handle to.\n * `portClient` (direction out) - Pointer to output the port client handle to.\n * `name` - Name of the port.\n * `maxSessions` - Maximum number of sessions that can connect to the port."]
    pub fn svcCreatePort(
        portServer: *mut Handle,
        portClient: *mut Handle,
        name: *const ::libc::c_char,
        maxSessions: s32,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Connects to a port.\n # Arguments\n\n* `out` (direction out) - Pointer to output the port handle to.\n * `portName` - Name of the port."]
    pub fn svcConnectToPort(out: *mut Handle, portName: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets up virtual address space for a new process.\n # Arguments\n\n* `out` (direction out) - Pointer to output the codeset handle to.\n * `info` - Codeset header, contains process name, titleId and segment info.\n * `textSegmentLma` - Address of executable segment in caller's address space.\n * `roSegmentLma` - Address of read-only segment in caller's address space.\n * `dataSegmentLma` - Address of read-write segment in caller's address space.\n > **Note:** On success, the provided segments are unmapped from the caller's address space."]
    pub fn svcCreateCodeSet(
        out: *mut Handle,
        info: *const CodeSetHeader,
        textSegmentLma: u32_,
        roSegmentLma: u32_,
        dataSegmentLma: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Create a new process.\n # Arguments\n\n* `out` (direction out) - Pointer to output the process handle to.\n * `codeset` - Codeset created for this process.\n * `arm11KernelCaps` - Arm11 Kernel Capabilities from exheader.\n * `numArm11KernelCaps` - Number of kernel capabilities."]
    pub fn svcCreateProcess(
        out: *mut Handle,
        codeset: Handle,
        arm11KernelCaps: *const u32_,
        numArm11KernelCaps: s32,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a process's affinity mask.\n # Arguments\n\n* `affinitymask` (direction out) - Pointer to store the affinity masks.\n * `process` - Handle of the process.\n * `processorcount` - Number of processors."]
    pub fn svcGetProcessAffinityMask(
        affinitymask: *mut u8_,
        process: Handle,
        processorcount: s32,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets a process's affinity mask.\n # Arguments\n\n* `process` - Handle of the process.\n * `affinitymask` - Pointer to retrieve the affinity masks from.\n * `processorcount` - Number of processors."]
    pub fn svcSetProcessAffinityMask(
        process: Handle,
        affinitymask: *const u8_,
        processorcount: s32,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a process's ideal processor.\n # Arguments\n\n* `processorid` (direction out) - Pointer to store the ID of the process's ideal processor.\n * `process` - Handle of the process."]
    pub fn svcGetProcessIdealProcessor(processorid: *mut s32, process: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets a process's ideal processor.\n # Arguments\n\n* `process` - Handle of the process.\n * `processorid` - ID of the process's ideal processor."]
    pub fn svcSetProcessIdealProcessor(process: Handle, processorid: s32) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Launches the main thread of the process.\n # Arguments\n\n* `process` - Handle of the process.\n * `info` - Pointer to a StartupInfo structure describing information for the main thread."]
    pub fn svcRun(process: Handle, info: *const StartupInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Multithreading\n# *\n* Creates a new thread.\n # Arguments\n\n* `thread` (direction out) - The thread handle\n * `entrypoint` - The function that will be called first upon thread creation\n * `arg` - The argument passed to `entrypoint`\n * `stack_top` - The top of the thread's stack. Must be 0x8 bytes mem-aligned.\n * `thread_priority` - Low values gives the thread higher priority.\n For userland apps, this has to be within the range [0x18;0x3F]\n* * `processor_id` - The id of the processor the thread should be ran on. Those are labelled starting from 0.\n For old 3ds it has to be <2, and for new 3DS <4.\n* Value -1 means all CPUs and -2 read from the Exheader.\n*\n* The processor with ID 1 is the system processor.\n* To enable multi-threading on this core you need to call APT_SetAppCpuTimeLimit at least once with a non-zero value.\n*\n* Since a thread is considered as a waitable object, you can use svcWaitSynchronization\n and svcWaitSynchronizationN to join with it.\n\n* > **Note:** The kernel will clear the `stack_top's` address low 3 bits to make sure it is 0x8-bytes aligned.\n/"]
    pub fn svcCreateThread(
        thread: *mut Handle,
        entrypoint: ThreadFunc,
        arg: u32_,
        stack_top: *mut u32_,
        thread_priority: s32,
        processor_id: s32,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the handle of a thread.\n # Arguments\n\n* `thread` (direction out) - The handle of the thread\n * `process` - The ID of the process linked to the thread"]
    pub fn svcOpenThread(thread: *mut Handle, process: Handle, threadId: u32_) -> Result;
}
unsafe extern "C" {
    #[doc = "Exits the current thread.\n\n This will trigger a state change and hence release all svcWaitSynchronization operations.\n It means that you can join a thread by calling svcWaitSynchronization(threadHandle,yourtimeout); "]
    pub fn svcExitThread() -> !;
}
unsafe extern "C" {
    #[doc = "Puts the current thread to sleep.\n # Arguments\n\n* `ns` - The minimum number of nanoseconds to sleep for."]
    pub fn svcSleepThread(ns: s64);
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrieves the priority of a thread."]
    pub fn svcGetThreadPriority(out: *mut s32, handle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Changes the priority of a thread\n # Arguments\n\n* `prio` - For userland apps, this has to be within the range [0x18;0x3F]\n\n Low values gives the thread higher priority."]
    pub fn svcSetThreadPriority(thread: Handle, prio: s32) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a thread's affinity mask.\n # Arguments\n\n* `affinitymask` (direction out) - Pointer to output the affinity masks to.\n * `thread` - Handle of the thread.\n * `processorcount` - Number of processors."]
    pub fn svcGetThreadAffinityMask(
        affinitymask: *mut u8_,
        thread: Handle,
        processorcount: s32,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets a thread's affinity mask.\n # Arguments\n\n* `thread` - Handle of the thread.\n * `affinitymask` - Pointer to retrieve the affinity masks from.\n * `processorcount` - Number of processors."]
    pub fn svcSetThreadAffinityMask(
        thread: Handle,
        affinitymask: *const u8_,
        processorcount: s32,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a thread's ideal processor.\n # Arguments\n\n* `processorid` (direction out) - Pointer to output the ID of the thread's ideal processor to.\n * `thread` - Handle of the thread."]
    pub fn svcGetThreadIdealProcessor(processorid: *mut s32, thread: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets a thread's ideal processor.\n # Arguments\n\n* `thread` - Handle of the thread.\n * `processorid` - ID of the thread's ideal processor."]
    pub fn svcSetThreadIdealProcessor(thread: Handle, processorid: s32) -> Result;
}
unsafe extern "C" {
    #[doc = "Returns the ID of the processor the current thread is running on.\n [`svcCreateThread`]"]
    pub fn svcGetProcessorID() -> s32;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the ID of a thread.\n # Arguments\n\n* `out` (direction out) - Pointer to output the thread ID of the thread `handle` to.\n * `handle` - Handle of the thread."]
    pub fn svcGetThreadId(out: *mut u32_, handle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the resource limit set of a process.\n # Arguments\n\n* `resourceLimit` (direction out) - Pointer to output the resource limit set handle to.\n * `process` - Process to get the resource limits of."]
    pub fn svcGetResourceLimit(resourceLimit: *mut Handle, process: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the value limits of a resource limit set.\n # Arguments\n\n* `values` (direction out) - Pointer to output the value limits to.\n * `resourceLimit` - Resource limit set to use.\n * `names` - Resource limit names to get the limits of.\n * `nameCount` - Number of resource limit names."]
    pub fn svcGetResourceLimitLimitValues(
        values: *mut s64,
        resourceLimit: Handle,
        names: *mut ResourceLimitType,
        nameCount: s32,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the values of a resource limit set.\n # Arguments\n\n* `values` (direction out) - Pointer to output the values to.\n * `resourceLimit` - Resource limit set to use.\n * `names` - Resource limit names to get the values of.\n * `nameCount` - Number of resource limit names."]
    pub fn svcGetResourceLimitCurrentValues(
        values: *mut s64,
        resourceLimit: Handle,
        names: *mut ResourceLimitType,
        nameCount: s32,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the resource limit set of a process.\n # Arguments\n\n* `process` - Process to set the resource limit set to.\n * `resourceLimit` - Resource limit set handle."]
    pub fn svcSetProcessResourceLimits(process: Handle, resourceLimit: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a resource limit set.\n # Arguments\n\n* `resourceLimit` (direction out) - Pointer to output the resource limit set handle to."]
    pub fn svcCreateResourceLimit(resourceLimit: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the value limits of a resource limit set.\n # Arguments\n\n* `resourceLimit` - Resource limit set to use.\n * `names` - Resource limit names to set the limits of.\n * `values` - Value limits to set. The high 32 bits of RESLIMIT_COMMIT are used to\nset APPMEMALLOC in configuration memory, otherwise those bits are unused.\n * `nameCount` - Number of resource limit names."]
    pub fn svcSetResourceLimitValues(
        resourceLimit: Handle,
        names: *const ResourceLimitType,
        values: *const s64,
        nameCount: s32,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the process ID of a thread.\n # Arguments\n\n* `out` (direction out) - Pointer to output the process ID of the thread `handle` to.\n * `handle` - Handle of the thread.\n [`svcOpenProcess`]"]
    pub fn svcGetProcessIdOfThread(out: *mut u32_, handle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if a thread handle is valid.\n This requests always return an error when called, it only checks if the handle is a thread or not.\n # Returns\n\n0xD8E007ED (BAD_ENUM) if the Handle is a Thread Handle\n 0xD8E007F7 (BAD_HANDLE) if it isn't."]
    pub fn svcGetThreadInfo(out: *mut s64, thread: Handle, type_: ThreadInfoType) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Synchronization\n# *\n* Creates a mutex.\n # Arguments\n\n* `mutex` (direction out) - Pointer to output the handle of the created mutex to.\n * `initially_locked` - Whether the mutex should be initially locked.\n/"]
    pub fn svcCreateMutex(mutex: *mut Handle, initially_locked: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Releases a mutex.\n # Arguments\n\n* `handle` - Handle of the mutex."]
    pub fn svcReleaseMutex(handle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a semaphore.\n # Arguments\n\n* `semaphore` (direction out) - Pointer to output the handle of the created semaphore to.\n * `initial_count` - Initial count of the semaphore.\n * `max_count` - Maximum count of the semaphore."]
    pub fn svcCreateSemaphore(semaphore: *mut Handle, initial_count: s32, max_count: s32)
    -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Releases a semaphore.\n # Arguments\n\n* `count` (direction out) - Pointer to output the current count of the semaphore to.\n * `semaphore` - Handle of the semaphore.\n * `release_count` - Number to increase the semaphore count by."]
    pub fn svcReleaseSemaphore(count: *mut s32, semaphore: Handle, release_count: s32) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates an event handle.\n # Arguments\n\n* `event` (direction out) - Pointer to output the created event handle to.\n * `reset_type` - Type of reset the event uses (RESET_ONESHOT/RESET_STICKY)."]
    pub fn svcCreateEvent(event: *mut Handle, reset_type: ResetType) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Signals an event.\n # Arguments\n\n* `handle` - Handle of the event to signal."]
    pub fn svcSignalEvent(handle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Clears an event.\n # Arguments\n\n* `handle` - Handle of the event to clear."]
    pub fn svcClearEvent(handle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Waits for synchronization on a handle.\n # Arguments\n\n* `handle` - Handle to wait on.\n * `nanoseconds` - Maximum nanoseconds to wait for."]
    pub fn svcWaitSynchronization(handle: Handle, nanoseconds: s64) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Waits for synchronization on multiple handles.\n # Arguments\n\n* `out` (direction out) - Pointer to output the index of the synchronized handle to.\n * `handles` - Handles to wait on.\n * `handles_num` - Number of handles.\n * `wait_all` - Whether to wait for synchronization on all handles.\n * `nanoseconds` - Maximum nanoseconds to wait for."]
    pub fn svcWaitSynchronizationN(
        out: *mut s32,
        handles: *const Handle,
        handles_num: s32,
        wait_all: bool,
        nanoseconds: s64,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates an address arbiter\n # Arguments\n\n* `mutex` (direction out) - Pointer to output the handle of the created address arbiter to.\n [`svcArbitrateAddress`]"]
    pub fn svcCreateAddressArbiter(arbiter: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Arbitrate an address, can be used for synchronization\n # Arguments\n\n* `arbiter` - Handle of the arbiter\n * `addr` - A pointer to a s32 value.\n * `type` - Type of action to be performed by the arbiter\n * `value` - Number of threads to signal if using ARBITRATION_SIGNAL, or the value used for comparison.\n * `timeout_ns` - Optional timeout in nanoseconds when using TIMEOUT actions, ignored otherwise. If not needed, use svcArbitrateAddressNoTimeout instead.\n > **Note:** Usage of this syscall entails an implicit Data Memory Barrier (dmb).\n Please use syncArbitrateAddressWithTimeout instead."]
    pub fn svcArbitrateAddress(
        arbiter: Handle,
        addr: u32_,
        type_: ArbitrationType,
        value: s32,
        timeout_ns: s64,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Same as svcArbitrateAddress but with the timeout_ns parameter undefined.\n # Arguments\n\n* `arbiter` - Handle of the arbiter\n * `addr` - A pointer to a s32 value.\n * `type` - Type of action to be performed by the arbiter\n * `value` - Number of threads to signal if using ARBITRATION_SIGNAL, or the value used for comparison.\n > **Note:** Usage of this syscall entails an implicit Data Memory Barrier (dmb).\n Please use syncArbitrateAddress instead."]
    pub fn svcArbitrateAddressNoTimeout(
        arbiter: Handle,
        addr: u32_,
        type_: ArbitrationType,
        value: s32,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sends a synchronized request to a session handle.\n # Arguments\n\n* `session` - Handle of the session."]
    pub fn svcSendSyncRequest(session: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Connects to a port via a handle.\n # Arguments\n\n* `clientSession` (direction out) - Pointer to output the client session handle to.\n * `clientPort` - Port client endpoint to connect to."]
    pub fn svcCreateSessionToPort(clientSession: *mut Handle, clientPort: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a linked pair of session endpoints.\n # Arguments\n\n* `serverSession` (direction out) - Pointer to output the created server endpoint handle to.\n * `clientSession` (direction out) - Pointer to output the created client endpoint handle to."]
    pub fn svcCreateSession(serverSession: *mut Handle, clientSession: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Accepts a session.\n # Arguments\n\n* `session` (direction out) - Pointer to output the created session handle to.\n * `port` - Handle of the port to accept a session from."]
    pub fn svcAcceptSession(session: *mut Handle, port: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Replies to and receives a new request.\n # Arguments\n\n* `index` - Pointer to the index of the request.\n * `handles` - Session handles to receive requests from.\n * `handleCount` - Number of handles.\n * `replyTarget` - Handle of the session to reply to."]
    pub fn svcReplyAndReceive(
        index: *mut s32,
        handles: *const Handle,
        handleCount: s32,
        replyTarget: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Time\n# *\n* Creates a timer.\n # Arguments\n\n* `timer` (direction out) - Pointer to output the handle of the created timer to.\n * `reset_type` - Type of reset to perform on the timer.\n/"]
    pub fn svcCreateTimer(timer: *mut Handle, reset_type: ResetType) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets a timer.\n # Arguments\n\n* `timer` - Handle of the timer to set.\n * `initial` - Initial value of the timer.\n * `interval` - Interval of the timer."]
    pub fn svcSetTimer(timer: Handle, initial: s64, interval: s64) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Cancels a timer.\n # Arguments\n\n* `timer` - Handle of the timer to cancel."]
    pub fn svcCancelTimer(timer: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Clears a timer.\n # Arguments\n\n* `timer` - Handle of the timer to clear."]
    pub fn svcClearTimer(timer: Handle) -> Result;
}
unsafe extern "C" {
    #[doc = "Gets the current system tick.\n # Returns\n\nThe current system tick."]
    pub fn svcGetSystemTick() -> u64_;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "System\n# *\n* Closes a handle.\n # Arguments\n\n* `handle` - Handle to close.\n/"]
    pub fn svcCloseHandle(handle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Duplicates a handle.\n # Arguments\n\n* `out` (direction out) - Pointer to output the duplicated handle to.\n * `original` - Handle to duplicate."]
    pub fn svcDuplicateHandle(out: *mut Handle, original: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a handle info.\n # Arguments\n\n* `out` (direction out) - Pointer to output the handle info to.\n * `handle` - Handle to get the info for.\n * `param` - Parameter clarifying the handle info type."]
    pub fn svcGetHandleInfo(out: *mut s64, handle: Handle, param: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the system info.\n # Arguments\n\n* `out` (direction out) - Pointer to output the system info to.\n * `type` - Type of system info to retrieve.\n * `param` - Parameter clarifying the system info type."]
    pub fn svcGetSystemInfo(out: *mut s64, type_: u32_, param: s32) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the current kernel state.\n # Arguments\n\n* `type` - Type of state to set (the other parameters depend on it)."]
    pub fn svcKernelSetState(type_: u32_, ...) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Binds an event or semaphore handle to an ARM11 interrupt.\n # Arguments\n\n* `interruptId` - Interrupt identfier (see https://www.3dbrew.org/wiki/ARM11_Interrupts).\n * `eventOrSemaphore` - Event or semaphore handle to bind to the given interrupt.\n * `priority` - Priority of the interrupt for the current process.\n * `isManualClear` - Indicates whether the interrupt has to be manually cleared or not (= level-high active)."]
    pub fn svcBindInterrupt(
        interruptId: u32_,
        eventOrSemaphore: Handle,
        priority: s32,
        isManualClear: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unbinds an event or semaphore handle from an ARM11 interrupt.\n # Arguments\n\n* `interruptId` - Interrupt identfier, see (see https://www.3dbrew.org/wiki/ARM11_Interrupts).\n * `eventOrSemaphore` - Event or semaphore handle to unbind from the given interrupt."]
    pub fn svcUnbindInterrupt(interruptId: u32_, eventOrSemaphore: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Invalidates a process's data cache.\n # Arguments\n\n* `process` - Handle of the process.\n * `addr` - Address to invalidate.\n * `size` - Size of the memory to invalidate."]
    pub fn svcInvalidateProcessDataCache(process: Handle, addr: u32_, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Cleans a process's data cache.\n # Arguments\n\n* `process` - Handle of the process.\n * `addr` - Address to clean.\n * `size` - Size of the memory to clean."]
    pub fn svcStoreProcessDataCache(process: Handle, addr: u32_, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Flushes (cleans and invalidates) a process's data cache.\n # Arguments\n\n* `process` - Handle of the process.\n * `addr` - Address to flush.\n * `size` - Size of the memory to flush."]
    pub fn svcFlushProcessDataCache(process: Handle, addr: u32_, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Begins an inter-process DMA transfer.\n # Arguments\n\n* `dma` (direction out) - Pointer to output the handle of the DMA channel object to.\n * `dstProcess` - Destination process handle.\n * `dstAddr` - Address in the destination process to write data to.\n * `srcProcess` - Source process handle.\n * `srcAddr` - Address in the source to read data from.\n * `size` - Size of the data to transfer.\n * `cfg` - Configuration structure.\n > **Note:** The handle is signaled when the transfer finishes."]
    pub fn svcStartInterProcessDma(
        dma: *mut Handle,
        dstProcess: Handle,
        dstAddr: u32_,
        srcProcess: Handle,
        srcAddr: u32_,
        size: u32_,
        cfg: *const DmaConfig,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Stops an inter-process DMA transfer.\n # Arguments\n\n* `dma` - Handle of the DMA channel object."]
    pub fn svcStopDma(dma: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the state of an inter-process DMA transfer.\n # Arguments\n\n* `state` (direction out) - Pointer to output the state of the DMA transfer to.\n * `dma` - Handle of the DMA channel object."]
    pub fn svcGetDmaState(state: *mut DmaState, dma: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Restarts a DMA transfer, using the same configuration as before.\n # Arguments\n\n* `state` (direction out) - Pointer to output the state of the DMA transfer to.\n * `dma` - Handle of the DMA channel object.\n * `dstAddr` - Address in the destination process to write data to.\n * `srcAddr` - Address in the source to read data from.\n * `size` - Size of the data to transfer.\n * `flags` - Restart flags, DMARST_UNLOCK and/or DMARST_RESUME_DEVICE.\n > **Note:** The first transfer has to be configured with DMACFG_KEEP_LOCKED."]
    pub fn svcRestartDma(
        dma: Handle,
        dstAddr: u32_,
        srcAddr: u32_,
        size: u32_,
        flags: s8,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the GPU protection register to restrict the range of the GPU DMA. 11.3+ only.\n # Arguments\n\n* `useApplicationRestriction` - Whether to use the register value used for APPLICATION titles."]
    pub fn svcSetGpuProt(useApplicationRestriction: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Enables or disables Wi-Fi. 11.4+ only.\n # Arguments\n\n* `enabled` - Whether to enable or disable Wi-Fi."]
    pub fn svcSetWifiEnabled(enabled: bool) -> Result;
}
unsafe extern "C" {
    #[doc = "Debugging\n# *\n* Breaks execution.\n # Arguments\n\n* `breakReason` - Reason for breaking.\n/"]
    pub fn svcBreak(breakReason: UserBreakType);
}
unsafe extern "C" {
    #[doc = "Breaks execution (LOAD_RO and UNLOAD_RO).\n # Arguments\n\n* `breakReason` - Debug reason for breaking.\n * `croInfo` - Library information.\n * `croInfoSize` - Size of the above structure."]
    pub fn svcBreakRO(
        breakReason: UserBreakType,
        croInfo: *const ::libc::c_void,
        croInfoSize: u32_,
    );
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Outputs a debug string.\n # Arguments\n\n* `str` - String to output.\n * `length` - Length of the string to output, needs to be positive."]
    pub fn svcOutputDebugString(str_: *const ::libc::c_char, length: s32) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Controls performance monitoring on the CP15 interface and the SCU.\n The meaning of the parameters depend on the operation.\n # Arguments\n\n* `out` (direction out) - Output.\n * `op` - Operation, see details.\n * `param1` - First parameter.\n * `param2` - Second parameter.\n \n\nThe operations are the following:\n - PERFCOUNTEROP_ENABLE (void) -> void, tries to enable and lock perfmon. functionality.\n - PERFCOUNTEROP_DISABLE (void) -> void, disable and forcibly unlocks perfmon. functionality.\n - PERFCOUNTEROP_GET_VALUE (PerfCounterRegister reg) -> u64, gets the value of a particular counter register.\n - PERFCOUNTEROP_SET_VALUE (PerfCounterRegister reg, u64 value) -> void, sets the value of a particular counter register.\n - PERFCOUNTEROP_GET_OVERFLOW_FLAGS (void) -> u32, gets the overflow flags of all CP15 and SCU registers.\n - Format is a bitfield of PerfCounterRegister.\n - PERFCOUNTEROP_RESET (u32 valueResetMask, u32 overflowFlagResetMask) -> void, resets the value and/or\n overflow flags of selected registers.\n - Format is two bitfields of PerfCounterRegister.\n - PERFCOUNTEROP_GET_EVENT (PerfCounterRegister reg) -> PerfCounterEvent, gets the event associated\n to a particular counter register.\n - PERFCOUNTEROP_SET_EVENT (PerfCounterRegister reg, PerfCounterEvent) -> void, sets the event associated\n to a particular counter register.\n - PERFCOUNTEROP_SET_VIRTUAL_COUNTER_ENABLED (bool enabled) -> void, (dis)allows the kernel to track counter overflows\n and to use 64-bit counter values."]
    pub fn svcControlPerformanceCounter(
        out: *mut u64_,
        op: PerfCounterOperation,
        param1: u32_,
        param2: u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a debug handle for an active process.\n # Arguments\n\n* `debug` (direction out) - Pointer to output the created debug handle to.\n * `processId` - ID of the process to debug."]
    pub fn svcDebugActiveProcess(debug: *mut Handle, processId: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Breaks a debugged process.\n # Arguments\n\n* `debug` - Debug handle of the process."]
    pub fn svcBreakDebugProcess(debug: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Terminates a debugged process.\n # Arguments\n\n* `debug` - Debug handle of the process."]
    pub fn svcTerminateDebugProcess(debug: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current debug event of a debugged process.\n # Arguments\n\n* `info` (direction out) - Pointer to output the debug event information to.\n * `debug` - Debug handle of the process."]
    pub fn svcGetProcessDebugEvent(info: *mut DebugEventInfo, debug: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Continues the current debug event of a debugged process (not necessarily the same as svcGetProcessDebugEvent).\n # Arguments\n\n* `debug` - Debug handle of the process.\n * `flags` - Flags to continue with, see DebugFlags."]
    pub fn svcContinueDebugEvent(debug: Handle, flags: DebugFlags) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Fetches the saved registers of a thread, either inactive or awaiting svcContinueDebugEvent, belonging to a debugged process.\n # Arguments\n\n* `context` (direction out) - Values of the registers to fetch, see ThreadContext.\n * `debug` - Debug handle of the parent process.\n * `threadId` - ID of the thread to fetch the saved registers of.\n * `controlFlags` - Which registers to fetch, see ThreadContextControlFlags."]
    pub fn svcGetDebugThreadContext(
        context: *mut ThreadContext,
        debug: Handle,
        threadId: u32_,
        controlFlags: ThreadContextControlFlags,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates the saved registers of a thread, either inactive or awaiting svcContinueDebugEvent, belonging to a debugged process.\n # Arguments\n\n* `debug` - Debug handle of the parent process.\n * `threadId` - ID of the thread to update the saved registers of.\n * `context` - Values of the registers to update, see ThreadContext.\n * `controlFlags` - Which registers to update, see ThreadContextControlFlags."]
    pub fn svcSetDebugThreadContext(
        debug: Handle,
        threadId: u32_,
        context: *mut ThreadContext,
        controlFlags: ThreadContextControlFlags,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Queries memory information of a debugged process.\n # Arguments\n\n* `info` (direction out) - Pointer to output memory info to.\n * `out` (direction out) - Pointer to output page info to.\n * `debug` - Debug handle of the process to query memory from.\n * `addr` - Virtual memory address to query."]
    pub fn svcQueryDebugProcessMemory(
        info: *mut MemInfo,
        out: *mut PageInfo,
        debug: Handle,
        addr: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads from a debugged process's memory.\n # Arguments\n\n* `buffer` - Buffer to read data to.\n * `debug` - Debug handle of the process.\n * `addr` - Address to read from.\n * `size` - Size of the memory to read."]
    pub fn svcReadProcessMemory(
        buffer: *mut ::libc::c_void,
        debug: Handle,
        addr: u32_,
        size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes to a debugged process's memory.\n # Arguments\n\n* `debug` - Debug handle of the process.\n * `buffer` - Buffer to write data from.\n * `addr` - Address to write to.\n * `size` - Size of the memory to write."]
    pub fn svcWriteProcessMemory(
        debug: Handle,
        buffer: *const ::libc::c_void,
        addr: u32_,
        size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets an hardware breakpoint or watchpoint. This is an interface to the BRP/WRP registers, see http://infocenter.arm.com/help/topic/com.arm.doc.ddi0360f/CEGEBGFC.html .\n # Arguments\n\n* `registerId` - range 0..5 = breakpoints (BRP0-5), 0x100..0x101 = watchpoints (WRP0-1). The previous stop point for the register is disabled.\n * `control` - Value of the control regiser.\n * `value` - Value of the value register: either and address (if bit21 of control is clear) or the debug handle of a process to fetch the context ID of."]
    pub fn svcSetHardwareBreakPoint(registerId: s32, control: u32_, value: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a debugged thread's parameter.\n # Arguments\n\n* `unused` (direction out) - Unused.\n * `out` (direction out) - Output value.\n * `debug` - Debug handle of the process.\n * `threadId` - ID of the thread\n * `parameter` - Parameter to fetch, see DebugThreadParameter."]
    pub fn svcGetDebugThreadParam(
        unused: *mut s64,
        out: *mut u32_,
        debug: Handle,
        threadId: u32_,
        parameter: DebugThreadParameter,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a function in supervisor mode.\n # Arguments\n\n* `callback` - Function to execute."]
    pub fn svcBackdoor(callback: ::core::option::Option<unsafe extern "C" fn() -> s32>) -> Result;
}
#[doc = "< Mount \"nand:/\""]
pub const ARM9DESC_MOUNT_NAND: _bindgen_ty_7 = 1;
#[doc = "< Mount nand:/ro/ as read-write"]
pub const ARM9DESC_MOUNT_NANDRO_RW: _bindgen_ty_7 = 2;
#[doc = "< Mount \"twln:/\""]
pub const ARM9DESC_MOUNT_TWLN: _bindgen_ty_7 = 4;
#[doc = "< Mount \"wnand:/\""]
pub const ARM9DESC_MOUNT_WNAND: _bindgen_ty_7 = 8;
#[doc = "< Mount \"cardspi:/\""]
pub const ARM9DESC_MOUNT_CARDSPI: _bindgen_ty_7 = 16;
#[doc = "< Use SDIF3"]
pub const ARM9DESC_USE_SDIF3: _bindgen_ty_7 = 32;
#[doc = "< Create seed (movable.sed)"]
pub const ARM9DESC_CREATE_SEED: _bindgen_ty_7 = 64;
#[doc = "< Use card SPI, required by multiple pxi:dev commands"]
pub const ARM9DESC_USE_CARD_SPI: _bindgen_ty_7 = 128;
#[doc = "< SD application (not checked)"]
pub const ARM9DESC_SD_APPLICATION: _bindgen_ty_7 = 256;
#[doc = "< Mount \"sdmc:/\" as read-write"]
pub const ARM9DESC_MOUNT_SDMC_RW: _bindgen_ty_7 = 512;
#[doc = "ARM9 descriptor flags"]
pub type _bindgen_ty_7 = ::libc::c_ushort;
#[doc = "< Category \"system application\""]
pub const FSACCESS_CATEGORY_SYSTEM_APPLICATION: _bindgen_ty_8 = 1;
#[doc = "< Category \"hardware check\""]
pub const FSACCESS_CATEGORY_HARDWARE_CHECK: _bindgen_ty_8 = 2;
#[doc = "< Category \"filesystem tool\""]
pub const FSACCESS_CATEGORY_FILESYSTEM_TOOL: _bindgen_ty_8 = 4;
#[doc = "< Debug"]
pub const FSACCESS_DEBUG: _bindgen_ty_8 = 8;
#[doc = "< TWLCARD backup"]
pub const FSACCESS_TWLCARD_BACKUP: _bindgen_ty_8 = 16;
#[doc = "< TWLNAND data"]
pub const FSACCESS_TWLNAND_DATA: _bindgen_ty_8 = 32;
#[doc = "< BOSS (SpotPass)"]
pub const FSACCESS_BOSS: _bindgen_ty_8 = 64;
#[doc = "< SDMC (read-write)"]
pub const FSACCESS_SDMC_RW: _bindgen_ty_8 = 128;
#[doc = "< Core"]
pub const FSACCESS_CORE: _bindgen_ty_8 = 256;
#[doc = "< nand:/ro/ (read-only)"]
pub const FSACCESS_NANDRO_RO: _bindgen_ty_8 = 512;
#[doc = "< nand:/rw/"]
pub const FSACCESS_NANDRW: _bindgen_ty_8 = 1024;
#[doc = "< nand:/ro/ (read-write)"]
pub const FSACCESS_NANDRO_RW: _bindgen_ty_8 = 2048;
#[doc = "< Category \"System Settings\""]
pub const FSACCESS_CATEGORY_SYSTEM_SETTINGS: _bindgen_ty_8 = 4096;
#[doc = "< Cardboard (System Transfer)"]
pub const FSACCESS_CARDBOARD: _bindgen_ty_8 = 8192;
#[doc = "< Export/Import IVs (movable.sed)"]
pub const FSACCESS_EXPORT_IMPORT_IVS: _bindgen_ty_8 = 16384;
#[doc = "< SDMC (write-only)"]
pub const FSACCESS_SDMC_WO: _bindgen_ty_8 = 32768;
#[doc = "< \"Switch cleanup\" (3.0+)"]
pub const FSACCESS_SWITCH_CLEANUP: _bindgen_ty_8 = 65536;
#[doc = "< Savedata move (5.0+)"]
pub const FSACCESS_SAVEDATA_MOVE: _bindgen_ty_8 = 131072;
#[doc = "< Shop (5.0+)"]
pub const FSACCESS_SHOP: _bindgen_ty_8 = 262144;
#[doc = "< Shop (5.0+)"]
pub const FSACCESS_SHELL: _bindgen_ty_8 = 524288;
#[doc = "< Category \"Home Menu\" (6.0+)"]
pub const FSACCESS_CATEGORY_HOME_MENU: _bindgen_ty_8 = 1048576;
#[doc = "< Seed DB (9.6+)"]
pub const FSACCESS_SEEDDB: _bindgen_ty_8 = 2097152;
#[doc = "Filesystem access flags"]
pub type _bindgen_ty_8 = ::libc::c_uint;
#[doc = "< Regular application"]
pub const RESLIMIT_CATEGORY_APPLICATION: ResourceLimitCategory = 0;
#[doc = "< System applet"]
pub const RESLIMIT_CATEGORY_SYS_APPLET: ResourceLimitCategory = 1;
#[doc = "< Library applet"]
pub const RESLIMIT_CATEGORY_LIB_APPLET: ResourceLimitCategory = 2;
#[doc = "< System modules running inside the BASE memregion"]
pub const RESLIMIT_CATEGORY_OTHER: ResourceLimitCategory = 3;
#[doc = "The resource limit category of a title"]
pub type ResourceLimitCategory = ::libc::c_uchar;
#[doc = "< 64MB of usable application memory"]
pub const SYSMODE_O3DS_PROD: SystemMode = 0;
#[doc = "< 124MB of usable application memory. Unusable on O3DS"]
pub const SYSMODE_N3DS_PROD: SystemMode = 1;
#[doc = "< 97MB/178MB of usable application memory"]
pub const SYSMODE_DEV1: SystemMode = 2;
#[doc = "< 80MB/124MB of usable application memory"]
pub const SYSMODE_DEV2: SystemMode = 3;
#[doc = "< 72MB of usable application memory. Same as \"Prod\" on N3DS"]
pub const SYSMODE_DEV3: SystemMode = 4;
#[doc = "< 32MB of usable application memory. Same as \"Prod\" on N3DS"]
pub const SYSMODE_DEV4: SystemMode = 5;
#[doc = "The system mode a title should be launched under"]
pub type SystemMode = ::libc::c_uchar;
#[doc = "The system info flags and remaster version of a title"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_SystemInfoFlags {
    #[doc = "< Reserved"]
    pub reserved: [u8_; 5usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Remaster version"]
    pub remaster_version: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExHeader_SystemInfoFlags"]
        [::core::mem::size_of::<ExHeader_SystemInfoFlags>() - 8usize];
    ["Alignment of ExHeader_SystemInfoFlags"]
        [::core::mem::align_of::<ExHeader_SystemInfoFlags>() - 2usize];
    ["Offset of field: ExHeader_SystemInfoFlags::reserved"]
        [::core::mem::offset_of!(ExHeader_SystemInfoFlags, reserved) - 0usize];
    ["Offset of field: ExHeader_SystemInfoFlags::remaster_version"]
        [::core::mem::offset_of!(ExHeader_SystemInfoFlags, remaster_version) - 6usize];
};
impl ExHeader_SystemInfoFlags {
    #[inline]
    pub fn compress_exefs_code(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_compress_exefs_code(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn compress_exefs_code_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_compress_exefs_code_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_sd_application(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_sd_application(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_sd_application_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_sd_application_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compress_exefs_code: bool,
        is_sd_application: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let compress_exefs_code: u8 = unsafe { ::core::mem::transmute(compress_exefs_code) };
            compress_exefs_code as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_sd_application: u8 = unsafe { ::core::mem::transmute(is_sd_application) };
            is_sd_application as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Information about a title's section"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_CodeSectionInfo {
    #[doc = "< The address of the section"]
    pub address: u32_,
    #[doc = "< The number of pages the section occupies"]
    pub num_pages: u32_,
    #[doc = "< The size of the section"]
    pub size: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExHeader_CodeSectionInfo"]
        [::core::mem::size_of::<ExHeader_CodeSectionInfo>() - 12usize];
    ["Alignment of ExHeader_CodeSectionInfo"]
        [::core::mem::align_of::<ExHeader_CodeSectionInfo>() - 4usize];
    ["Offset of field: ExHeader_CodeSectionInfo::address"]
        [::core::mem::offset_of!(ExHeader_CodeSectionInfo, address) - 0usize];
    ["Offset of field: ExHeader_CodeSectionInfo::num_pages"]
        [::core::mem::offset_of!(ExHeader_CodeSectionInfo, num_pages) - 4usize];
    ["Offset of field: ExHeader_CodeSectionInfo::size"]
        [::core::mem::offset_of!(ExHeader_CodeSectionInfo, size) - 8usize];
};
#[doc = "The name of a title and infomation about its section"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_CodeSetInfo {
    #[doc = "< Title name"]
    pub name: [::libc::c_char; 8usize],
    #[doc = "< System info flags, see ExHeader_SystemInfoFlags"]
    pub flags: ExHeader_SystemInfoFlags,
    #[doc = "< .text section info, see ExHeader_CodeSectionInfo"]
    pub text: ExHeader_CodeSectionInfo,
    #[doc = "< Stack size"]
    pub stack_size: u32_,
    #[doc = "< .rodata section info, see ExHeader_CodeSectionInfo"]
    pub rodata: ExHeader_CodeSectionInfo,
    #[doc = "< Reserved"]
    pub reserved: u32_,
    #[doc = "< .data section info, see ExHeader_CodeSectionInfo"]
    pub data: ExHeader_CodeSectionInfo,
    #[doc = "< .bss section size"]
    pub bss_size: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExHeader_CodeSetInfo"][::core::mem::size_of::<ExHeader_CodeSetInfo>() - 64usize];
    ["Alignment of ExHeader_CodeSetInfo"][::core::mem::align_of::<ExHeader_CodeSetInfo>() - 4usize];
    ["Offset of field: ExHeader_CodeSetInfo::name"]
        [::core::mem::offset_of!(ExHeader_CodeSetInfo, name) - 0usize];
    ["Offset of field: ExHeader_CodeSetInfo::flags"]
        [::core::mem::offset_of!(ExHeader_CodeSetInfo, flags) - 8usize];
    ["Offset of field: ExHeader_CodeSetInfo::text"]
        [::core::mem::offset_of!(ExHeader_CodeSetInfo, text) - 16usize];
    ["Offset of field: ExHeader_CodeSetInfo::stack_size"]
        [::core::mem::offset_of!(ExHeader_CodeSetInfo, stack_size) - 28usize];
    ["Offset of field: ExHeader_CodeSetInfo::rodata"]
        [::core::mem::offset_of!(ExHeader_CodeSetInfo, rodata) - 32usize];
    ["Offset of field: ExHeader_CodeSetInfo::reserved"]
        [::core::mem::offset_of!(ExHeader_CodeSetInfo, reserved) - 44usize];
    ["Offset of field: ExHeader_CodeSetInfo::data"]
        [::core::mem::offset_of!(ExHeader_CodeSetInfo, data) - 48usize];
    ["Offset of field: ExHeader_CodeSetInfo::bss_size"]
        [::core::mem::offset_of!(ExHeader_CodeSetInfo, bss_size) - 60usize];
};
#[doc = "The savedata size and jump ID of a title"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_SystemInfo {
    #[doc = "< Savedata size"]
    pub savedata_size: u64_,
    #[doc = "< Jump ID"]
    pub jump_id: u64_,
    #[doc = "< Reserved"]
    pub reserved: [u8_; 48usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExHeader_SystemInfo"][::core::mem::size_of::<ExHeader_SystemInfo>() - 64usize];
    ["Alignment of ExHeader_SystemInfo"][::core::mem::align_of::<ExHeader_SystemInfo>() - 8usize];
    ["Offset of field: ExHeader_SystemInfo::savedata_size"]
        [::core::mem::offset_of!(ExHeader_SystemInfo, savedata_size) - 0usize];
    ["Offset of field: ExHeader_SystemInfo::jump_id"]
        [::core::mem::offset_of!(ExHeader_SystemInfo, jump_id) - 8usize];
    ["Offset of field: ExHeader_SystemInfo::reserved"]
        [::core::mem::offset_of!(ExHeader_SystemInfo, reserved) - 16usize];
};
impl Default for ExHeader_SystemInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "The code set info, dependencies and system info of a title (SCI)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_SystemControlInfo {
    #[doc = "< Code set info, see ExHeader_CodeSetInfo"]
    pub codeset_info: ExHeader_CodeSetInfo,
    #[doc = "< Title IDs of the titles that this program depends on"]
    pub dependencies: [u64_; 48usize],
    #[doc = "< System info, see ExHeader_SystemInfo"]
    pub system_info: ExHeader_SystemInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExHeader_SystemControlInfo"]
        [::core::mem::size_of::<ExHeader_SystemControlInfo>() - 512usize];
    ["Alignment of ExHeader_SystemControlInfo"]
        [::core::mem::align_of::<ExHeader_SystemControlInfo>() - 8usize];
    ["Offset of field: ExHeader_SystemControlInfo::codeset_info"]
        [::core::mem::offset_of!(ExHeader_SystemControlInfo, codeset_info) - 0usize];
    ["Offset of field: ExHeader_SystemControlInfo::dependencies"]
        [::core::mem::offset_of!(ExHeader_SystemControlInfo, dependencies) - 64usize];
    ["Offset of field: ExHeader_SystemControlInfo::system_info"]
        [::core::mem::offset_of!(ExHeader_SystemControlInfo, system_info) - 448usize];
};
impl Default for ExHeader_SystemControlInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "The ARM11 filesystem info of a title"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_Arm11StorageInfo {
    #[doc = "< Extdata ID"]
    pub extdata_id: u64_,
    #[doc = "< IDs of the system savedata accessible by the title"]
    pub system_savedata_ids: [u32_; 2usize],
    #[doc = "< IDs of the savedata accessible by the title, 20 bits each, followed by \"Use other variation savedata\""]
    pub accessible_savedata_ids: u64_,
    #[doc = "< FS access flags"]
    pub fs_access_info: u32_,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExHeader_Arm11StorageInfo"]
        [::core::mem::size_of::<ExHeader_Arm11StorageInfo>() - 32usize];
    ["Alignment of ExHeader_Arm11StorageInfo"]
        [::core::mem::align_of::<ExHeader_Arm11StorageInfo>() - 8usize];
    ["Offset of field: ExHeader_Arm11StorageInfo::extdata_id"]
        [::core::mem::offset_of!(ExHeader_Arm11StorageInfo, extdata_id) - 0usize];
    ["Offset of field: ExHeader_Arm11StorageInfo::system_savedata_ids"]
        [::core::mem::offset_of!(ExHeader_Arm11StorageInfo, system_savedata_ids) - 8usize];
    ["Offset of field: ExHeader_Arm11StorageInfo::accessible_savedata_ids"]
        [::core::mem::offset_of!(ExHeader_Arm11StorageInfo, accessible_savedata_ids) - 16usize];
    ["Offset of field: ExHeader_Arm11StorageInfo::fs_access_info"]
        [::core::mem::offset_of!(ExHeader_Arm11StorageInfo, fs_access_info) - 24usize];
};
impl ExHeader_Arm11StorageInfo {
    #[inline]
    pub fn reserved(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_romfs(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_romfs(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_romfs_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_romfs_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_extended_savedata_access(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_extended_savedata_access(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_extended_savedata_access_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_use_extended_savedata_access_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: u32_,
        no_romfs: bool,
        use_extended_savedata_access: bool,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let no_romfs: u8 = unsafe { ::core::mem::transmute(no_romfs) };
            no_romfs as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let use_extended_savedata_access: u8 =
                unsafe { ::core::mem::transmute(use_extended_savedata_access) };
            use_extended_savedata_access as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "The CPU-related and memory-layout-related info of a title"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Arm11CoreInfo {
    #[doc = "< The low title ID of the target firmware"]
    pub core_version: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    #[doc = "< The priority of the title's main thread"]
    pub priority: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExHeader_Arm11CoreInfo"][::core::mem::size_of::<ExHeader_Arm11CoreInfo>() - 8usize];
    ["Alignment of ExHeader_Arm11CoreInfo"]
        [::core::mem::align_of::<ExHeader_Arm11CoreInfo>() - 4usize];
    ["Offset of field: ExHeader_Arm11CoreInfo::core_version"]
        [::core::mem::offset_of!(ExHeader_Arm11CoreInfo, core_version) - 0usize];
    ["Offset of field: ExHeader_Arm11CoreInfo::priority"]
        [::core::mem::offset_of!(ExHeader_Arm11CoreInfo, priority) - 7usize];
};
impl Default for ExHeader_Arm11CoreInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ExHeader_Arm11CoreInfo {
    #[inline]
    pub fn use_cpu_clockrate_804MHz(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_cpu_clockrate_804MHz(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_cpu_clockrate_804MHz_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_use_cpu_clockrate_804MHz_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable_l2c(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_l2c(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_l2c_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enable_l2c_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flag1_unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_flag1_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flag1_unused_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                6u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flag1_unused_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn n3ds_system_mode(&self) -> SystemMode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_n3ds_system_mode(&mut self, val: SystemMode) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn n3ds_system_mode_raw(this: *const Self) -> SystemMode {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_n3ds_system_mode_raw(this: *mut Self, val: SystemMode) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flag2_unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_flag2_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flag2_unused_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_flag2_unused_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ideal_processor(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ideal_processor(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ideal_processor_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ideal_processor_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn affinity_mask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_affinity_mask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn affinity_mask_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_affinity_mask_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn o3ds_system_mode(&self) -> SystemMode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_o3ds_system_mode(&mut self, val: SystemMode) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn o3ds_system_mode_raw(this: *const Self) -> SystemMode {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_o3ds_system_mode_raw(this: *mut Self, val: SystemMode) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_cpu_clockrate_804MHz: bool,
        enable_l2c: bool,
        flag1_unused: u8_,
        n3ds_system_mode: SystemMode,
        flag2_unused: u8_,
        ideal_processor: u8_,
        affinity_mask: u8_,
        o3ds_system_mode: SystemMode,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_cpu_clockrate_804MHz: u8 =
                unsafe { ::core::mem::transmute(use_cpu_clockrate_804MHz) };
            use_cpu_clockrate_804MHz as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable_l2c: u8 = unsafe { ::core::mem::transmute(enable_l2c) };
            enable_l2c as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let flag1_unused: u8 = unsafe { ::core::mem::transmute(flag1_unused) };
            flag1_unused as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let n3ds_system_mode: u8 = unsafe { ::core::mem::transmute(n3ds_system_mode) };
            n3ds_system_mode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let flag2_unused: u8 = unsafe { ::core::mem::transmute(flag2_unused) };
            flag2_unused as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let ideal_processor: u8 = unsafe { ::core::mem::transmute(ideal_processor) };
            ideal_processor as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let affinity_mask: u8 = unsafe { ::core::mem::transmute(affinity_mask) };
            affinity_mask as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let o3ds_system_mode: u8 = unsafe { ::core::mem::transmute(o3ds_system_mode) };
            o3ds_system_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "The ARM11 system-local capabilities of a title"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Arm11SystemLocalCapabilities {
    #[doc = "< Title ID"]
    pub title_id: u64_,
    #[doc = "< Core info, see ExHeader_Arm11CoreInfo"]
    pub core_info: ExHeader_Arm11CoreInfo,
    #[doc = "< Resource limit descriptors, only \"CpuTime\" (first byte) sems to be used"]
    pub reslimits: [u16_; 16usize],
    #[doc = "< Storage info, see ExHeader_Arm11StorageInfo"]
    pub storage_info: ExHeader_Arm11StorageInfo,
    #[doc = "< List of the services the title has access to. Limited to 32 prior to system version 9.3"]
    pub service_access: [[::libc::c_char; 8usize]; 34usize],
    #[doc = "< Reserved"]
    pub reserved: [u8_; 15usize],
    #[doc = "< Resource limit category, see ExHeader_Arm11SystemLocalCapabilities"]
    pub reslimit_category: ResourceLimitCategory,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExHeader_Arm11SystemLocalCapabilities"]
        [::core::mem::size_of::<ExHeader_Arm11SystemLocalCapabilities>() - 368usize];
    ["Alignment of ExHeader_Arm11SystemLocalCapabilities"]
        [::core::mem::align_of::<ExHeader_Arm11SystemLocalCapabilities>() - 8usize];
    ["Offset of field: ExHeader_Arm11SystemLocalCapabilities::title_id"]
        [::core::mem::offset_of!(ExHeader_Arm11SystemLocalCapabilities, title_id) - 0usize];
    ["Offset of field: ExHeader_Arm11SystemLocalCapabilities::core_info"]
        [::core::mem::offset_of!(ExHeader_Arm11SystemLocalCapabilities, core_info) - 8usize];
    ["Offset of field: ExHeader_Arm11SystemLocalCapabilities::reslimits"]
        [::core::mem::offset_of!(ExHeader_Arm11SystemLocalCapabilities, reslimits) - 16usize];
    ["Offset of field: ExHeader_Arm11SystemLocalCapabilities::storage_info"]
        [::core::mem::offset_of!(ExHeader_Arm11SystemLocalCapabilities, storage_info) - 48usize];
    ["Offset of field: ExHeader_Arm11SystemLocalCapabilities::service_access"]
        [::core::mem::offset_of!(ExHeader_Arm11SystemLocalCapabilities, service_access) - 80usize];
    ["Offset of field: ExHeader_Arm11SystemLocalCapabilities::reserved"]
        [::core::mem::offset_of!(ExHeader_Arm11SystemLocalCapabilities, reserved) - 352usize];
    ["Offset of field: ExHeader_Arm11SystemLocalCapabilities::reslimit_category"][::core::mem::offset_of!(
        ExHeader_Arm11SystemLocalCapabilities,
        reslimit_category
    ) - 367usize];
};
impl Default for ExHeader_Arm11SystemLocalCapabilities {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "The ARM11 kernel capabilities of a title"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_Arm11KernelCapabilities {
    #[doc = "< ARM11 kernel descriptors, see 3dbrew"]
    pub descriptors: [u32_; 28usize],
    #[doc = "< Reserved"]
    pub reserved: [u8_; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExHeader_Arm11KernelCapabilities"]
        [::core::mem::size_of::<ExHeader_Arm11KernelCapabilities>() - 128usize];
    ["Alignment of ExHeader_Arm11KernelCapabilities"]
        [::core::mem::align_of::<ExHeader_Arm11KernelCapabilities>() - 4usize];
    ["Offset of field: ExHeader_Arm11KernelCapabilities::descriptors"]
        [::core::mem::offset_of!(ExHeader_Arm11KernelCapabilities, descriptors) - 0usize];
    ["Offset of field: ExHeader_Arm11KernelCapabilities::reserved"]
        [::core::mem::offset_of!(ExHeader_Arm11KernelCapabilities, reserved) - 112usize];
};
#[doc = "The ARM9 access control of a title"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_Arm9AccessControl {
    #[doc = "< Process9 FS descriptors, see 3dbrew"]
    pub descriptors: [u8_; 15usize],
    #[doc = "< Descriptor version"]
    pub descriptor_version: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExHeader_Arm9AccessControl"]
        [::core::mem::size_of::<ExHeader_Arm9AccessControl>() - 16usize];
    ["Alignment of ExHeader_Arm9AccessControl"]
        [::core::mem::align_of::<ExHeader_Arm9AccessControl>() - 1usize];
    ["Offset of field: ExHeader_Arm9AccessControl::descriptors"]
        [::core::mem::offset_of!(ExHeader_Arm9AccessControl, descriptors) - 0usize];
    ["Offset of field: ExHeader_Arm9AccessControl::descriptor_version"]
        [::core::mem::offset_of!(ExHeader_Arm9AccessControl, descriptor_version) - 15usize];
};
#[doc = "The access control information of a title"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_AccessControlInfo {
    #[doc = "< ARM11 system-local capabilities, see ExHeader_Arm11SystemLocalCapabilities"]
    pub local_caps: ExHeader_Arm11SystemLocalCapabilities,
    #[doc = "< ARM11 kernel capabilities, see ExHeader_Arm11SystemLocalCapabilities"]
    pub kernel_caps: ExHeader_Arm11KernelCapabilities,
    #[doc = "< ARM9 access control, see ExHeader_Arm9AccessControl"]
    pub access_control: ExHeader_Arm9AccessControl,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExHeader_AccessControlInfo"]
        [::core::mem::size_of::<ExHeader_AccessControlInfo>() - 512usize];
    ["Alignment of ExHeader_AccessControlInfo"]
        [::core::mem::align_of::<ExHeader_AccessControlInfo>() - 8usize];
    ["Offset of field: ExHeader_AccessControlInfo::local_caps"]
        [::core::mem::offset_of!(ExHeader_AccessControlInfo, local_caps) - 0usize];
    ["Offset of field: ExHeader_AccessControlInfo::kernel_caps"]
        [::core::mem::offset_of!(ExHeader_AccessControlInfo, kernel_caps) - 368usize];
    ["Offset of field: ExHeader_AccessControlInfo::access_control"]
        [::core::mem::offset_of!(ExHeader_AccessControlInfo, access_control) - 496usize];
};
impl Default for ExHeader_AccessControlInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Main extended header data, as returned by PXIPM, Loader and FSREG service commands"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Info {
    #[doc = "< System control info, see ExHeader_SystemControlInfo"]
    pub sci: ExHeader_SystemControlInfo,
    #[doc = "< Access control info, see ExHeader_AccessControlInfo"]
    pub aci: ExHeader_AccessControlInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExHeader_Info"][::core::mem::size_of::<ExHeader_Info>() - 1024usize];
    ["Alignment of ExHeader_Info"][::core::mem::align_of::<ExHeader_Info>() - 8usize];
    ["Offset of field: ExHeader_Info::sci"][::core::mem::offset_of!(ExHeader_Info, sci) - 0usize];
    ["Offset of field: ExHeader_Info::aci"][::core::mem::offset_of!(ExHeader_Info, aci) - 512usize];
};
impl Default for ExHeader_Info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Extended header access descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_AccessDescriptor {
    #[doc = "< The signature of the access descriptor (RSA-2048-SHA256)"]
    pub signature: [u8_; 256usize],
    #[doc = "< The modulus used for the above signature, with 65537 as public exponent"]
    pub ncchModulus: [u8_; 256usize],
    #[doc = "< This is compared for equality with the first ACI by Process9, see ExHeader_AccessControlInfo"]
    pub acli: ExHeader_AccessControlInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExHeader_AccessDescriptor"]
        [::core::mem::size_of::<ExHeader_AccessDescriptor>() - 1024usize];
    ["Alignment of ExHeader_AccessDescriptor"]
        [::core::mem::align_of::<ExHeader_AccessDescriptor>() - 8usize];
    ["Offset of field: ExHeader_AccessDescriptor::signature"]
        [::core::mem::offset_of!(ExHeader_AccessDescriptor, signature) - 0usize];
    ["Offset of field: ExHeader_AccessDescriptor::ncchModulus"]
        [::core::mem::offset_of!(ExHeader_AccessDescriptor, ncchModulus) - 256usize];
    ["Offset of field: ExHeader_AccessDescriptor::acli"]
        [::core::mem::offset_of!(ExHeader_AccessDescriptor, acli) - 512usize];
};
impl Default for ExHeader_AccessDescriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "The NCCH Extended Header of a title"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader {
    #[doc = "< Main extended header data, see ExHeader_Info"]
    pub info: ExHeader_Info,
    #[doc = "< Access descriptor, see ExHeader_AccessDescriptor"]
    pub access_descriptor: ExHeader_AccessDescriptor,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExHeader"][::core::mem::size_of::<ExHeader>() - 2048usize];
    ["Alignment of ExHeader"][::core::mem::align_of::<ExHeader>() - 8usize];
    ["Offset of field: ExHeader::info"][::core::mem::offset_of!(ExHeader, info) - 0usize];
    ["Offset of field: ExHeader::access_descriptor"]
        [::core::mem::offset_of!(ExHeader, access_descriptor) - 1024usize];
};
impl Default for ExHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the service API."]
    pub fn srvInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits the service API."]
    pub fn srvExit();
}
unsafe extern "C" {
    #[doc = "Makes srvGetServiceHandle non-blocking for the current thread (or blocking, the default), in case of unavailable (full) requested services.\n # Arguments\n\n* `blocking` - Whether srvGetServiceHandle should be non-blocking.\n srvGetServiceHandle will always block if the service hasn't been registered yet,\n use srvIsServiceRegistered to check whether that is the case or not."]
    pub fn srvSetBlockingPolicy(nonBlocking: bool);
}
unsafe extern "C" {
    #[doc = "Gets the current service API session handle.\n # Returns\n\nThe current service API session handle."]
    pub fn srvGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrieves a service handle, retrieving from the environment handle list if possible.\n # Arguments\n\n* `out` - Pointer to write the handle to.\n * `name` - Name of the service.\n # Returns\n\n0 if no error occured,\n 0xD8E06406 if the caller has no right to access the service,\n 0xD0401834 if the requested service port is full and srvGetServiceHandle is non-blocking (see srvSetBlockingPolicy)."]
    pub fn srvGetServiceHandle(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Registers the current process as a client to the service API."]
    pub fn srvRegisterClient() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Enables service notificatios, returning a notification semaphore.\n # Arguments\n\n* `semaphoreOut` - Pointer to output the notification semaphore to."]
    pub fn srvEnableNotification(semaphoreOut: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Registers the current process as a service.\n # Arguments\n\n* `out` - Pointer to write the service handle to.\n * `name` - Name of the service.\n * `maxSessions` - Maximum number of sessions the service can handle."]
    pub fn srvRegisterService(
        out: *mut Handle,
        name: *const ::libc::c_char,
        maxSessions: ::libc::c_int,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unregisters the current process as a service.\n # Arguments\n\n* `name` - Name of the service."]
    pub fn srvUnregisterService(name: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrieves a service handle.\n # Arguments\n\n* `out` - Pointer to output the handle to.\n * `name` - Name of the service.\n * # Returns\n\n0 if no error occured,\n 0xD8E06406 if the caller has no right to access the service,\n 0xD0401834 if the requested service port is full and srvGetServiceHandle is non-blocking (see srvSetBlockingPolicy)."]
    pub fn srvGetServiceHandleDirect(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Registers a port.\n # Arguments\n\n* `name` - Name of the port.\n * `clientHandle` - Client handle of the port."]
    pub fn srvRegisterPort(name: *const ::libc::c_char, clientHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unregisters a port.\n # Arguments\n\n* `name` - Name of the port."]
    pub fn srvUnregisterPort(name: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrieves a port handle.\n # Arguments\n\n* `out` - Pointer to output the handle to.\n * `name` - Name of the port."]
    pub fn srvGetPort(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Waits for a port to be registered.\n # Arguments\n\n* `name` - Name of the port to wait for registration."]
    pub fn srvWaitForPortRegistered(name: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Subscribes to a notification.\n # Arguments\n\n* `notificationId` - ID of the notification."]
    pub fn srvSubscribe(notificationId: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unsubscribes from a notification.\n # Arguments\n\n* `notificationId` - ID of the notification."]
    pub fn srvUnsubscribe(notificationId: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Receives a notification.\n # Arguments\n\n* `notificationIdOut` - Pointer to output the ID of the received notification to."]
    pub fn srvReceiveNotification(notificationIdOut: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Publishes a notification to subscribers.\n # Arguments\n\n* `notificationId` - ID of the notification.\n * `flags` - Flags to publish with. (bit 0 = only fire if not fired, bit 1 = do not report an error if there are more than 16 pending notifications)"]
    pub fn srvPublishToSubscriber(notificationId: u32_, flags: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Publishes a notification to subscribers and retrieves a list of all processes that were notified.\n # Arguments\n\n* `processIdCountOut` - Pointer to output the number of process IDs to.\n * `processIdsOut` - Pointer to output the process IDs to. Should have size \"60 * sizeof(u32)\".\n * `notificationId` - ID of the notification."]
    pub fn srvPublishAndGetSubscriber(
        processIdCountOut: *mut u32_,
        processIdsOut: *mut u32_,
        notificationId: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks whether a service is registered.\n # Arguments\n\n* `registeredOut` - Pointer to output the registration status to.\n * `name` - Name of the service to check."]
    pub fn srvIsServiceRegistered(registeredOut: *mut bool, name: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks whether a port is registered.\n # Arguments\n\n* `registeredOut` - Pointer to output the registration status to.\n * `name` - Name of the port to check."]
    pub fn srvIsPortRegistered(registeredOut: *mut bool, name: *const ::libc::c_char) -> Result;
}
#[doc = "< Generic fatal error. Shows miscellaneous info, including the address of the caller"]
pub const ERRF_ERRTYPE_GENERIC: ERRF_ErrType = 0;
#[doc = "< Damaged NAND (CC_ERROR after reading CSR)"]
pub const ERRF_ERRTYPE_NAND_DAMAGED: ERRF_ErrType = 1;
#[doc = "< Game content storage medium (cartridge and/or SD card) ejected. Not logged"]
pub const ERRF_ERRTYPE_CARD_REMOVED: ERRF_ErrType = 2;
#[doc = "< CPU or VFP exception"]
pub const ERRF_ERRTYPE_EXCEPTION: ERRF_ErrType = 3;
#[doc = "< Fatal error with a message instead of the caller's address"]
pub const ERRF_ERRTYPE_FAILURE: ERRF_ErrType = 4;
#[doc = "< Log-level failure. Does not display the exception and does not force the system to reboot"]
pub const ERRF_ERRTYPE_LOG_ONLY: ERRF_ErrType = 5;
#[doc = "Types of errors that can be thrown by err:f."]
pub type ERRF_ErrType = ::libc::c_uchar;
#[doc = "< Prefetch Abort"]
pub const ERRF_EXCEPTION_PREFETCH_ABORT: ERRF_ExceptionType = 0;
#[doc = "< Data abort"]
pub const ERRF_EXCEPTION_DATA_ABORT: ERRF_ExceptionType = 1;
#[doc = "< Undefined instruction"]
pub const ERRF_EXCEPTION_UNDEFINED: ERRF_ExceptionType = 2;
#[doc = "< VFP (floating point) exception."]
pub const ERRF_EXCEPTION_VFP: ERRF_ExceptionType = 3;
#[doc = "Types of 'Exceptions' thrown for ERRF_ERRTYPE_EXCEPTION"]
pub type ERRF_ExceptionType = ::libc::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ERRF_ExceptionInfo {
    #[doc = "< Type of the exception. One of the ERRF_EXCEPTION_* values."]
    pub type_: ERRF_ExceptionType,
    pub reserved: [u8_; 3usize],
    #[doc = "< ifsr (prefetch abort) / dfsr (data abort)"]
    pub fsr: u32_,
    #[doc = "< pc = ifar (prefetch abort) / dfar (data abort)"]
    pub far: u32_,
    pub fpexc: u32_,
    pub fpinst: u32_,
    pub fpinst2: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ERRF_ExceptionInfo"][::core::mem::size_of::<ERRF_ExceptionInfo>() - 24usize];
    ["Alignment of ERRF_ExceptionInfo"][::core::mem::align_of::<ERRF_ExceptionInfo>() - 4usize];
    ["Offset of field: ERRF_ExceptionInfo::type_"]
        [::core::mem::offset_of!(ERRF_ExceptionInfo, type_) - 0usize];
    ["Offset of field: ERRF_ExceptionInfo::reserved"]
        [::core::mem::offset_of!(ERRF_ExceptionInfo, reserved) - 1usize];
    ["Offset of field: ERRF_ExceptionInfo::fsr"]
        [::core::mem::offset_of!(ERRF_ExceptionInfo, fsr) - 4usize];
    ["Offset of field: ERRF_ExceptionInfo::far"]
        [::core::mem::offset_of!(ERRF_ExceptionInfo, far) - 8usize];
    ["Offset of field: ERRF_ExceptionInfo::fpexc"]
        [::core::mem::offset_of!(ERRF_ExceptionInfo, fpexc) - 12usize];
    ["Offset of field: ERRF_ExceptionInfo::fpinst"]
        [::core::mem::offset_of!(ERRF_ExceptionInfo, fpinst) - 16usize];
    ["Offset of field: ERRF_ExceptionInfo::fpinst2"]
        [::core::mem::offset_of!(ERRF_ExceptionInfo, fpinst2) - 20usize];
};
impl Default for ERRF_ExceptionInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ERRF_ExceptionData {
    #[doc = "< Exception info struct"]
    pub excep: ERRF_ExceptionInfo,
    #[doc = "< CPU register dump."]
    pub regs: CpuRegisters,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ERRF_ExceptionData"][::core::mem::size_of::<ERRF_ExceptionData>() - 92usize];
    ["Alignment of ERRF_ExceptionData"][::core::mem::align_of::<ERRF_ExceptionData>() - 4usize];
    ["Offset of field: ERRF_ExceptionData::excep"]
        [::core::mem::offset_of!(ERRF_ExceptionData, excep) - 0usize];
    ["Offset of field: ERRF_ExceptionData::regs"]
        [::core::mem::offset_of!(ERRF_ExceptionData, regs) - 24usize];
};
impl Default for ERRF_ExceptionData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ERRF_FatalErrInfo {
    #[doc = "< Type, one of the ERRF_ERRTYPE_* enum"]
    pub type_: ERRF_ErrType,
    #[doc = "< High revison ID"]
    pub revHigh: u8_,
    #[doc = "< Low revision ID"]
    pub revLow: u16_,
    #[doc = "< Result code"]
    pub resCode: u32_,
    #[doc = "< PC address at exception"]
    pub pcAddr: u32_,
    #[doc = "< Process ID of the caller"]
    pub procId: u32_,
    #[doc = "< Title ID of the caller"]
    pub titleId: u64_,
    #[doc = "< Title ID of the running application"]
    pub appTitleId: u64_,
    #[doc = "< The different types of data for errors."]
    pub data: ERRF_FatalErrInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ERRF_FatalErrInfo__bindgen_ty_1 {
    #[doc = "< Data for when type is ERRF_ERRTYPE_EXCEPTION"]
    pub exception_data: ERRF_ExceptionData,
    #[doc = "< String for when type is ERRF_ERRTYPE_FAILURE"]
    pub failure_mesg: [::libc::c_char; 96usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ERRF_FatalErrInfo__bindgen_ty_1"]
        [::core::mem::size_of::<ERRF_FatalErrInfo__bindgen_ty_1>() - 96usize];
    ["Alignment of ERRF_FatalErrInfo__bindgen_ty_1"]
        [::core::mem::align_of::<ERRF_FatalErrInfo__bindgen_ty_1>() - 4usize];
    ["Offset of field: ERRF_FatalErrInfo__bindgen_ty_1::exception_data"]
        [::core::mem::offset_of!(ERRF_FatalErrInfo__bindgen_ty_1, exception_data) - 0usize];
    ["Offset of field: ERRF_FatalErrInfo__bindgen_ty_1::failure_mesg"]
        [::core::mem::offset_of!(ERRF_FatalErrInfo__bindgen_ty_1, failure_mesg) - 0usize];
};
impl Default for ERRF_FatalErrInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ERRF_FatalErrInfo"][::core::mem::size_of::<ERRF_FatalErrInfo>() - 128usize];
    ["Alignment of ERRF_FatalErrInfo"][::core::mem::align_of::<ERRF_FatalErrInfo>() - 8usize];
    ["Offset of field: ERRF_FatalErrInfo::type_"]
        [::core::mem::offset_of!(ERRF_FatalErrInfo, type_) - 0usize];
    ["Offset of field: ERRF_FatalErrInfo::revHigh"]
        [::core::mem::offset_of!(ERRF_FatalErrInfo, revHigh) - 1usize];
    ["Offset of field: ERRF_FatalErrInfo::revLow"]
        [::core::mem::offset_of!(ERRF_FatalErrInfo, revLow) - 2usize];
    ["Offset of field: ERRF_FatalErrInfo::resCode"]
        [::core::mem::offset_of!(ERRF_FatalErrInfo, resCode) - 4usize];
    ["Offset of field: ERRF_FatalErrInfo::pcAddr"]
        [::core::mem::offset_of!(ERRF_FatalErrInfo, pcAddr) - 8usize];
    ["Offset of field: ERRF_FatalErrInfo::procId"]
        [::core::mem::offset_of!(ERRF_FatalErrInfo, procId) - 12usize];
    ["Offset of field: ERRF_FatalErrInfo::titleId"]
        [::core::mem::offset_of!(ERRF_FatalErrInfo, titleId) - 16usize];
    ["Offset of field: ERRF_FatalErrInfo::appTitleId"]
        [::core::mem::offset_of!(ERRF_FatalErrInfo, appTitleId) - 24usize];
    ["Offset of field: ERRF_FatalErrInfo::data"]
        [::core::mem::offset_of!(ERRF_FatalErrInfo, data) - 32usize];
};
impl Default for ERRF_FatalErrInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes ERR:f. Unless you plan to call ERRF_Throw yourself, do not use this."]
    pub fn errfInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits ERR:f. Unless you plan to call ERRF_Throw yourself, do not use this."]
    pub fn errfExit();
}
unsafe extern "C" {
    #[doc = "Gets the current err:f API session handle.\n # Returns\n\nThe current err:f API session handle."]
    pub fn errfGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Throws a system error and possibly logs it.\n # Arguments\n\n* `error` (direction in) - Error to throw.\n\n ErrDisp may convert the error info to ERRF_ERRTYPE_NAND_DAMAGED or ERRF_ERRTYPE_CARD_REMOVED\n depending on the error code.\n\n Except with ERRF_ERRTYPE_LOG_ONLY, the system will panic and will need to be rebooted.\n Fatal error information will also be logged into a file, unless the type either ERRF_ERRTYPE_NAND_DAMAGED\n or ERRF_ERRTYPE_CARD_REMOVED.\n\n No error will be shown if the system is asleep.\n\n On retail units with vanilla firmware, no detailed information will be displayed on screen.\n\n You may wish to use ERRF_ThrowResult() or ERRF_ThrowResultWithMessage() instead of\n constructing the ERRF_FatalErrInfo struct yourself."]
    pub fn ERRF_Throw(error: *const ERRF_FatalErrInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Throws (and logs) a system error with the given Result code.\n # Arguments\n\n* `failure` (direction in) - Result code to throw.\n\n This calls ERRF_Throw with error type ERRF_ERRTYPE_GENERIC and fills in the required data.\n\n This function _does_ fill in the address where this function was called from."]
    pub fn ERRF_ThrowResult(failure: Result) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Logs a system error with the given Result code.\n # Arguments\n\n* `failure` (direction in) - Result code to log.\n\n Similar to ERRF_Throw, except that it does not display anything on the screen,\n nor does it force the system to reboot.\n\n This function _does_ fill in the address where this function was called from."]
    pub fn ERRF_LogResult(failure: Result) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Throws a system error with the given Result code and message.\n # Arguments\n\n* `failure` (direction in) - Result code to throw.\n * `message` (direction in) - The message to display.\n\n This calls ERRF_Throw with error type ERRF_ERRTYPE_FAILURE and fills in the required data.\n\n This function does _not_ fill in the address where this function was called from because it\n would not be displayed."]
    pub fn ERRF_ThrowResultWithMessage(failure: Result, message: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Specify an additional user string to use for error reporting.\n # Arguments\n\n* `user_string` (direction in) - User string (up to 256 bytes, not including NUL byte)"]
    pub fn ERRF_SetUserString(user_string: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[doc = "Handles an exception using ErrDisp.\n # Arguments\n\n* `excep` - Exception information\n * `regs` - CPU registers\n\n You might want to clear ENVINFO's bit0 to be able to see any debugging information.\n [`threadOnException`]"]
    pub fn ERRF_ExceptionHandler(excep: *mut ERRF_ExceptionInfo, regs: *mut CpuRegisters) -> !;
}
#[doc = "Kernel configuration page (read-only)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct osKernelConfig_s {
    pub kernel_ver: u32_,
    pub update_flag: u32_,
    pub ns_tid: u64_,
    pub kernel_syscore_ver: u32_,
    pub env_info: u8_,
    pub unit_info: u8_,
    pub boot_env: u8_,
    pub unk_0x17: u8_,
    pub kernel_ctrsdk_ver: u32_,
    pub unk_0x1c: u32_,
    pub firmlaunch_flags: u32_,
    pub unk_0x24: [u8_; 12usize],
    pub app_memtype: u32_,
    pub unk_0x34: [u8_; 12usize],
    pub memregion_sz: [u32_; 3usize],
    pub unk_0x4c: [u8_; 20usize],
    pub firm_ver: u32_,
    pub firm_syscore_ver: u32_,
    pub firm_ctrsdk_ver: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of osKernelConfig_s"][::core::mem::size_of::<osKernelConfig_s>() - 112usize];
    ["Alignment of osKernelConfig_s"][::core::mem::align_of::<osKernelConfig_s>() - 8usize];
    ["Offset of field: osKernelConfig_s::kernel_ver"]
        [::core::mem::offset_of!(osKernelConfig_s, kernel_ver) - 0usize];
    ["Offset of field: osKernelConfig_s::update_flag"]
        [::core::mem::offset_of!(osKernelConfig_s, update_flag) - 4usize];
    ["Offset of field: osKernelConfig_s::ns_tid"]
        [::core::mem::offset_of!(osKernelConfig_s, ns_tid) - 8usize];
    ["Offset of field: osKernelConfig_s::kernel_syscore_ver"]
        [::core::mem::offset_of!(osKernelConfig_s, kernel_syscore_ver) - 16usize];
    ["Offset of field: osKernelConfig_s::env_info"]
        [::core::mem::offset_of!(osKernelConfig_s, env_info) - 20usize];
    ["Offset of field: osKernelConfig_s::unit_info"]
        [::core::mem::offset_of!(osKernelConfig_s, unit_info) - 21usize];
    ["Offset of field: osKernelConfig_s::boot_env"]
        [::core::mem::offset_of!(osKernelConfig_s, boot_env) - 22usize];
    ["Offset of field: osKernelConfig_s::unk_0x17"]
        [::core::mem::offset_of!(osKernelConfig_s, unk_0x17) - 23usize];
    ["Offset of field: osKernelConfig_s::kernel_ctrsdk_ver"]
        [::core::mem::offset_of!(osKernelConfig_s, kernel_ctrsdk_ver) - 24usize];
    ["Offset of field: osKernelConfig_s::unk_0x1c"]
        [::core::mem::offset_of!(osKernelConfig_s, unk_0x1c) - 28usize];
    ["Offset of field: osKernelConfig_s::firmlaunch_flags"]
        [::core::mem::offset_of!(osKernelConfig_s, firmlaunch_flags) - 32usize];
    ["Offset of field: osKernelConfig_s::unk_0x24"]
        [::core::mem::offset_of!(osKernelConfig_s, unk_0x24) - 36usize];
    ["Offset of field: osKernelConfig_s::app_memtype"]
        [::core::mem::offset_of!(osKernelConfig_s, app_memtype) - 48usize];
    ["Offset of field: osKernelConfig_s::unk_0x34"]
        [::core::mem::offset_of!(osKernelConfig_s, unk_0x34) - 52usize];
    ["Offset of field: osKernelConfig_s::memregion_sz"]
        [::core::mem::offset_of!(osKernelConfig_s, memregion_sz) - 64usize];
    ["Offset of field: osKernelConfig_s::unk_0x4c"]
        [::core::mem::offset_of!(osKernelConfig_s, unk_0x4c) - 76usize];
    ["Offset of field: osKernelConfig_s::firm_ver"]
        [::core::mem::offset_of!(osKernelConfig_s, firm_ver) - 96usize];
    ["Offset of field: osKernelConfig_s::firm_syscore_ver"]
        [::core::mem::offset_of!(osKernelConfig_s, firm_syscore_ver) - 100usize];
    ["Offset of field: osKernelConfig_s::firm_ctrsdk_ver"]
        [::core::mem::offset_of!(osKernelConfig_s, firm_ctrsdk_ver) - 104usize];
};
#[doc = "Time reference information struct (filled in by PTM)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct osTimeRef_s {
    #[doc = "< Milliseconds elapsed since January 1900 when this structure was last updated"]
    pub value_ms: u64_,
    #[doc = "< System ticks elapsed since boot when this structure was last updated"]
    pub value_tick: u64_,
    #[doc = "< System clock frequency in Hz adjusted using RTC measurements (usually around SYSCLOCK_ARM11)"]
    pub sysclock_hz: s64,
    #[doc = "< Measured time drift of the system clock (according to the RTC) in milliseconds since the last update"]
    pub drift_ms: s64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of osTimeRef_s"][::core::mem::size_of::<osTimeRef_s>() - 32usize];
    ["Alignment of osTimeRef_s"][::core::mem::align_of::<osTimeRef_s>() - 8usize];
    ["Offset of field: osTimeRef_s::value_ms"]
        [::core::mem::offset_of!(osTimeRef_s, value_ms) - 0usize];
    ["Offset of field: osTimeRef_s::value_tick"]
        [::core::mem::offset_of!(osTimeRef_s, value_tick) - 8usize];
    ["Offset of field: osTimeRef_s::sysclock_hz"]
        [::core::mem::offset_of!(osTimeRef_s, sysclock_hz) - 16usize];
    ["Offset of field: osTimeRef_s::drift_ms"]
        [::core::mem::offset_of!(osTimeRef_s, drift_ms) - 24usize];
};
#[doc = "Shared system configuration page structure (read-only or read-write depending on exheader)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct osSharedConfig_s {
    pub timeref_cnt: vu32,
    pub running_hw: u8_,
    pub mcu_hwinfo: u8_,
    pub unk_0x06: [u8_; 26usize],
    pub timeref: [osTimeRef_s; 2usize],
    pub wifi_macaddr: [u8_; 6usize],
    pub wifi_strength: vu8,
    pub network_state: vu8,
    pub unk_0x68: [u8_; 24usize],
    pub slider_3d: f32,
    pub led_3d: vu8,
    pub led_battery: vu8,
    pub unk_flag: vu8,
    pub unk_0x87: u8_,
    pub unk_0x88: [u8_; 24usize],
    pub menu_tid: vu64,
    pub cur_menu_tid: vu64,
    pub unk_0xB0: [u8_; 16usize],
    pub headset_connected: vu8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of osSharedConfig_s"][::core::mem::size_of::<osSharedConfig_s>() - 200usize];
    ["Alignment of osSharedConfig_s"][::core::mem::align_of::<osSharedConfig_s>() - 8usize];
    ["Offset of field: osSharedConfig_s::timeref_cnt"]
        [::core::mem::offset_of!(osSharedConfig_s, timeref_cnt) - 0usize];
    ["Offset of field: osSharedConfig_s::running_hw"]
        [::core::mem::offset_of!(osSharedConfig_s, running_hw) - 4usize];
    ["Offset of field: osSharedConfig_s::mcu_hwinfo"]
        [::core::mem::offset_of!(osSharedConfig_s, mcu_hwinfo) - 5usize];
    ["Offset of field: osSharedConfig_s::unk_0x06"]
        [::core::mem::offset_of!(osSharedConfig_s, unk_0x06) - 6usize];
    ["Offset of field: osSharedConfig_s::timeref"]
        [::core::mem::offset_of!(osSharedConfig_s, timeref) - 32usize];
    ["Offset of field: osSharedConfig_s::wifi_macaddr"]
        [::core::mem::offset_of!(osSharedConfig_s, wifi_macaddr) - 96usize];
    ["Offset of field: osSharedConfig_s::wifi_strength"]
        [::core::mem::offset_of!(osSharedConfig_s, wifi_strength) - 102usize];
    ["Offset of field: osSharedConfig_s::network_state"]
        [::core::mem::offset_of!(osSharedConfig_s, network_state) - 103usize];
    ["Offset of field: osSharedConfig_s::unk_0x68"]
        [::core::mem::offset_of!(osSharedConfig_s, unk_0x68) - 104usize];
    ["Offset of field: osSharedConfig_s::slider_3d"]
        [::core::mem::offset_of!(osSharedConfig_s, slider_3d) - 128usize];
    ["Offset of field: osSharedConfig_s::led_3d"]
        [::core::mem::offset_of!(osSharedConfig_s, led_3d) - 132usize];
    ["Offset of field: osSharedConfig_s::led_battery"]
        [::core::mem::offset_of!(osSharedConfig_s, led_battery) - 133usize];
    ["Offset of field: osSharedConfig_s::unk_flag"]
        [::core::mem::offset_of!(osSharedConfig_s, unk_flag) - 134usize];
    ["Offset of field: osSharedConfig_s::unk_0x87"]
        [::core::mem::offset_of!(osSharedConfig_s, unk_0x87) - 135usize];
    ["Offset of field: osSharedConfig_s::unk_0x88"]
        [::core::mem::offset_of!(osSharedConfig_s, unk_0x88) - 136usize];
    ["Offset of field: osSharedConfig_s::menu_tid"]
        [::core::mem::offset_of!(osSharedConfig_s, menu_tid) - 160usize];
    ["Offset of field: osSharedConfig_s::cur_menu_tid"]
        [::core::mem::offset_of!(osSharedConfig_s, cur_menu_tid) - 168usize];
    ["Offset of field: osSharedConfig_s::unk_0xB0"]
        [::core::mem::offset_of!(osSharedConfig_s, unk_0xB0) - 176usize];
    ["Offset of field: osSharedConfig_s::headset_connected"]
        [::core::mem::offset_of!(osSharedConfig_s, headset_connected) - 192usize];
};
#[doc = "Tick counter."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TickCounter {
    #[doc = "< Elapsed CPU ticks between measurements."]
    pub elapsed: u64_,
    #[doc = "< Point in time used as reference."]
    pub reference: u64_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TickCounter"][::core::mem::size_of::<TickCounter>() - 16usize];
    ["Alignment of TickCounter"][::core::mem::align_of::<TickCounter>() - 8usize];
    ["Offset of field: TickCounter::elapsed"]
        [::core::mem::offset_of!(TickCounter, elapsed) - 0usize];
    ["Offset of field: TickCounter::reference"]
        [::core::mem::offset_of!(TickCounter, reference) - 8usize];
};
#[doc = "OS_VersionBin. Format of the system version: \"<major>.<minor>.<build>-<nupver><region>\""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OS_VersionBin {
    pub build: u8_,
    pub minor: u8_,
    pub mainver: u8_,
    pub reserved_x3: u8_,
    pub region: ::libc::c_char,
    pub reserved_x5: [u8_; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OS_VersionBin"][::core::mem::size_of::<OS_VersionBin>() - 8usize];
    ["Alignment of OS_VersionBin"][::core::mem::align_of::<OS_VersionBin>() - 1usize];
    ["Offset of field: OS_VersionBin::build"]
        [::core::mem::offset_of!(OS_VersionBin, build) - 0usize];
    ["Offset of field: OS_VersionBin::minor"]
        [::core::mem::offset_of!(OS_VersionBin, minor) - 1usize];
    ["Offset of field: OS_VersionBin::mainver"]
        [::core::mem::offset_of!(OS_VersionBin, mainver) - 2usize];
    ["Offset of field: OS_VersionBin::reserved_x3"]
        [::core::mem::offset_of!(OS_VersionBin, reserved_x3) - 3usize];
    ["Offset of field: OS_VersionBin::region"]
        [::core::mem::offset_of!(OS_VersionBin, region) - 4usize];
    ["Offset of field: OS_VersionBin::reserved_x5"]
        [::core::mem::offset_of!(OS_VersionBin, reserved_x5) - 5usize];
};
unsafe extern "C" {
    #[doc = "Converts an address from virtual (process) memory to physical memory.\n # Arguments\n\n* `vaddr` - Input virtual address.\n # Returns\n\nThe corresponding physical address.\n It is sometimes required by services or when using the GPU command buffer."]
    pub fn osConvertVirtToPhys(vaddr: *const ::libc::c_void) -> u32_;
}
unsafe extern "C" {
    #[doc = "Converts 0x14* vmem to 0x30*.\n # Arguments\n\n* `vaddr` - Input virtual address.\n # Returns\n\nThe corresponding address in the 0x30* range, the input address if it's already within the new vmem, or 0 if it's outside of both ranges."]
    pub fn osConvertOldLINEARMemToNew(vaddr: *const ::libc::c_void) -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[doc = "Retrieves basic information about a service error.\n # Arguments\n\n* `error` - Error to retrieve information about.\n # Returns\n\nA string containing a summary of an error.\n\n This can be used to get some details about an error returned by a service call."]
    pub fn osStrError(error: Result) -> *const ::libc::c_char;
}
unsafe extern "C" {
    #[doc = "Gets the system's FIRM version.\n # Returns\n\nThe system's FIRM version.\n\n This can be used to compare system versions easily with SYSTEM_VERSION."]
    #[link_name = "osGetFirmVersion__extern"]
    pub fn osGetFirmVersion() -> u32_;
}
unsafe extern "C" {
    #[doc = "Gets the system's kernel version.\n # Returns\n\nThe system's kernel version.\n\n This can be used to compare system versions easily with SYSTEM_VERSION.\n\n if(osGetKernelVersion() > SYSTEM_VERSION(2,46,0)) printf(\"You are running 9.0 or higher"]
    #[link_name = "osGetKernelVersion__extern"]
    pub fn osGetKernelVersion() -> u32_;
}
unsafe extern "C" {
    #[doc = "Gets the system's \"core version\" (2 on NATIVE_FIRM, 3 on SAFE_FIRM, etc.)"]
    #[link_name = "osGetSystemCoreVersion__extern"]
    pub fn osGetSystemCoreVersion() -> u32_;
}
unsafe extern "C" {
    #[doc = "Gets the system's memory layout ID (0-5 on Old 3DS, 6-8 on New 3DS)"]
    #[link_name = "osGetApplicationMemType__extern"]
    pub fn osGetApplicationMemType() -> u32_;
}
unsafe extern "C" {
    #[doc = "Gets the size of the specified memory region.\n # Arguments\n\n* `region` - Memory region to check.\n # Returns\n\nThe size of the memory region, in bytes."]
    #[link_name = "osGetMemRegionSize__extern"]
    pub fn osGetMemRegionSize(region: MemRegion) -> u32_;
}
unsafe extern "C" {
    #[doc = "Gets the number of used bytes within the specified memory region.\n # Arguments\n\n* `region` - Memory region to check.\n # Returns\n\nThe number of used bytes of memory."]
    #[link_name = "osGetMemRegionUsed__extern"]
    pub fn osGetMemRegionUsed(region: MemRegion) -> u32_;
}
unsafe extern "C" {
    #[doc = "Gets the number of free bytes within the specified memory region.\n # Arguments\n\n* `region` - Memory region to check.\n # Returns\n\nThe number of free bytes of memory."]
    #[link_name = "osGetMemRegionFree__extern"]
    pub fn osGetMemRegionFree(region: MemRegion) -> u32_;
}
unsafe extern "C" {
    #[doc = "Reads the latest reference timepoint published by PTM.\n # Returns\n\nStructure (see osTimeRef_s)."]
    pub fn osGetTimeRef() -> osTimeRef_s;
}
unsafe extern "C" {
    #[doc = "Gets the current time.\n # Returns\n\nThe number of milliseconds since 1st Jan 1900 00:00."]
    pub fn osGetTime() -> u64_;
}
unsafe extern "C" {
    #[doc = "Starts a tick counter.\n # Arguments\n\n* `cnt` - The tick counter."]
    #[link_name = "osTickCounterStart__extern"]
    pub fn osTickCounterStart(cnt: *mut TickCounter);
}
unsafe extern "C" {
    #[doc = "Updates the elapsed time in a tick counter.\n # Arguments\n\n* `cnt` - The tick counter."]
    #[link_name = "osTickCounterUpdate__extern"]
    pub fn osTickCounterUpdate(cnt: *mut TickCounter);
}
unsafe extern "C" {
    #[doc = "Reads the elapsed time in a tick counter.\n # Arguments\n\n* `cnt` - The tick counter.\n # Returns\n\nThe number of milliseconds elapsed."]
    pub fn osTickCounterRead(cnt: *const TickCounter) -> f64;
}
unsafe extern "C" {
    #[doc = "Gets the current Wifi signal strength.\n # Returns\n\nThe current Wifi signal strength.\n\n Valid values are 0-3:\n - 0 means the signal strength is terrible or the 3DS is disconnected from\n all networks.\n - 1 means the signal strength is bad.\n - 2 means the signal strength is decent.\n - 3 means the signal strength is good.\n\n Values outside the range of 0-3 should never be returned.\n\n These values correspond with the number of wifi bars displayed by Home Menu."]
    #[link_name = "osGetWifiStrength__extern"]
    pub fn osGetWifiStrength() -> u8_;
}
unsafe extern "C" {
    #[doc = "Gets the state of the 3D slider.\n # Returns\n\nThe state of the 3D slider (0.0~1.0)"]
    #[link_name = "osGet3DSliderState__extern"]
    pub fn osGet3DSliderState() -> f32;
}
unsafe extern "C" {
    #[doc = "Checks whether a headset is connected.\n # Returns\n\ntrue or false."]
    #[link_name = "osIsHeadsetConnected__extern"]
    pub fn osIsHeadsetConnected() -> bool;
}
unsafe extern "C" {
    #[doc = "Configures the New 3DS speedup.\n # Arguments\n\n* `enable` - Specifies whether to enable or disable the speedup."]
    pub fn osSetSpeedupEnable(enable: bool);
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the NAND system-version stored in NVer/CVer.\n # Arguments\n\n* `nver_versionbin` - Output OS_VersionBin structure for the data read from NVer.\n * `cver_versionbin` - Output OS_VersionBin structure for the data read from CVer.\n # Returns\n\nThe result-code. This value can be positive if opening \"romfs:/version.bin\" fails with stdio, since errno would be returned in that case. In some cases the error can be special negative values as well."]
    pub fn osGetSystemVersionData(
        nver_versionbin: *mut OS_VersionBin,
        cver_versionbin: *mut OS_VersionBin,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This is a wrapper for osGetSystemVersionData.\n # Arguments\n\n* `nver_versionbin` - Optional output OS_VersionBin structure for the data read from NVer, can be NULL.\n * `cver_versionbin` - Optional output OS_VersionBin structure for the data read from CVer, can be NULL.\n * `sysverstr` - Output string where the printed system-version will be written, in the same format displayed by the System Settings title.\n * `sysverstr_maxsize` - Max size of the above string buffer, *including* NULL-terminator.\n # Returns\n\nSee osGetSystemVersionData."]
    pub fn osGetSystemVersionDataString(
        nver_versionbin: *mut OS_VersionBin,
        cver_versionbin: *mut OS_VersionBin,
        sysverstr: *mut ::libc::c_char,
        sysverstr_maxsize: u32_,
    ) -> Result;
}
pub type _LOCK_T = i32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __lock_t {
    pub lock: _LOCK_T,
    pub thread_tag: u32,
    pub counter: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __lock_t"][::core::mem::size_of::<__lock_t>() - 12usize];
    ["Alignment of __lock_t"][::core::mem::align_of::<__lock_t>() - 4usize];
    ["Offset of field: __lock_t::lock"][::core::mem::offset_of!(__lock_t, lock) - 0usize];
    ["Offset of field: __lock_t::thread_tag"]
        [::core::mem::offset_of!(__lock_t, thread_tag) - 4usize];
    ["Offset of field: __lock_t::counter"][::core::mem::offset_of!(__lock_t, counter) - 8usize];
};
pub type _LOCK_RECURSIVE_T = __lock_t;
#[doc = "A light lock."]
pub type LightLock = _LOCK_T;
#[doc = "A recursive lock."]
pub type RecursiveLock = _LOCK_RECURSIVE_T;
#[doc = "A condition variable."]
pub type CondVar = s32;
#[doc = "A light event."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LightEvent {
    #[doc = "< State of the event: -2=cleared sticky, -1=cleared oneshot, 0=signaled oneshot, 1=signaled sticky"]
    pub state: s32,
    #[doc = "< Lock used for sticky timer operation"]
    pub lock: LightLock,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LightEvent"][::core::mem::size_of::<LightEvent>() - 8usize];
    ["Alignment of LightEvent"][::core::mem::align_of::<LightEvent>() - 4usize];
    ["Offset of field: LightEvent::state"][::core::mem::offset_of!(LightEvent, state) - 0usize];
    ["Offset of field: LightEvent::lock"][::core::mem::offset_of!(LightEvent, lock) - 4usize];
};
#[doc = "A light semaphore."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LightSemaphore {
    #[doc = "< The current release count of the semaphore"]
    pub current_count: s32,
    #[doc = "< Number of threads concurrently acquiring the semaphore"]
    pub num_threads_acq: s16,
    #[doc = "< The maximum release count of the semaphore"]
    pub max_count: s16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LightSemaphore"][::core::mem::size_of::<LightSemaphore>() - 8usize];
    ["Alignment of LightSemaphore"][::core::mem::align_of::<LightSemaphore>() - 4usize];
    ["Offset of field: LightSemaphore::current_count"]
        [::core::mem::offset_of!(LightSemaphore, current_count) - 0usize];
    ["Offset of field: LightSemaphore::num_threads_acq"]
        [::core::mem::offset_of!(LightSemaphore, num_threads_acq) - 4usize];
    ["Offset of field: LightSemaphore::max_count"]
        [::core::mem::offset_of!(LightSemaphore, max_count) - 6usize];
};
unsafe extern "C" {
    #[doc = "Performs a Data Synchronization Barrier operation."]
    #[link_name = "__dsb__extern"]
    pub fn __dsb();
}
unsafe extern "C" {
    #[doc = "Performs a Data Memory Barrier operation."]
    #[link_name = "__dmb__extern"]
    pub fn __dmb();
}
unsafe extern "C" {
    #[doc = "Performs an Instruction Synchronization Barrier (officially \"flush prefetch buffer\") operation."]
    #[link_name = "__isb__extern"]
    pub fn __isb();
}
unsafe extern "C" {
    #[doc = "Performs a clrex operation."]
    #[link_name = "__clrex__extern"]
    pub fn __clrex();
}
unsafe extern "C" {
    #[doc = "Performs a ldrex operation.\n # Arguments\n\n* `addr` - Address to perform the operation on.\n # Returns\n\nThe resulting value."]
    #[link_name = "__ldrex__extern"]
    pub fn __ldrex(addr: *mut s32) -> s32;
}
unsafe extern "C" {
    #[doc = "Performs a strex operation.\n # Arguments\n\n* `addr` - Address to perform the operation on.\n * `val` - Value to store.\n # Returns\n\nWhether the operation was successful."]
    #[link_name = "__strex__extern"]
    pub fn __strex(addr: *mut s32, val: s32) -> bool;
}
unsafe extern "C" {
    #[doc = "Performs a ldrexh operation.\n # Arguments\n\n* `addr` - Address to perform the operation on.\n # Returns\n\nThe resulting value."]
    #[link_name = "__ldrexh__extern"]
    pub fn __ldrexh(addr: *mut u16_) -> u16_;
}
unsafe extern "C" {
    #[doc = "Performs a strexh operation.\n # Arguments\n\n* `addr` - Address to perform the operation on.\n * `val` - Value to store.\n # Returns\n\nWhether the operation was successful."]
    #[link_name = "__strexh__extern"]
    pub fn __strexh(addr: *mut u16_, val: u16_) -> bool;
}
unsafe extern "C" {
    #[doc = "Performs a ldrexb operation.\n # Arguments\n\n* `addr` - Address to perform the operation on.\n # Returns\n\nThe resulting value."]
    #[link_name = "__ldrexb__extern"]
    pub fn __ldrexb(addr: *mut u8_) -> u8_;
}
unsafe extern "C" {
    #[doc = "Performs a strexb operation.\n # Arguments\n\n* `addr` - Address to perform the operation on.\n * `val` - Value to store.\n # Returns\n\nWhether the operation was successful."]
    #[link_name = "__strexb__extern"]
    pub fn __strexb(addr: *mut u8_, val: u8_) -> bool;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Function used to implement user-mode synchronization primitives.\n # Arguments\n\n* `addr` - Pointer to a signed 32-bit value whose address will be used to identify waiting threads.\n * `type` - Type of action to be performed by the arbiter\n * `value` - Number of threads to signal if using ARBITRATION_SIGNAL, or the value used for comparison.\n\n This will perform an arbitration based on #type. The comparisons are done between #value and the value at the address #addr.\n\n s32 val=0;\n // Does *nothing* since val >= 0\n syncArbitrateAddress(&val,ARBITRATION_WAIT_IF_LESS_THAN,0);\n > **Note:** Usage of this function entails an implicit Data Memory Barrier (dmb)."]
    pub fn syncArbitrateAddress(addr: *mut s32, type_: ArbitrationType, value: s32) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Function used to implement user-mode synchronization primitives (with timeout).\n # Arguments\n\n* `addr` - Pointer to a signed 32-bit value whose address will be used to identify waiting threads.\n * `type` - Type of action to be performed by the arbiter (must use ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT or ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN_TIMEOUT)\n * `value` - Number of threads to signal if using ARBITRATION_SIGNAL, or the value used for comparison.\n\n This will perform an arbitration based on #type. The comparisons are done between #value and the value at the address #addr.\n\n s32 val=0;\n // Thread will wait for a signal or wake up after 10000000 nanoseconds because val < 1.\n syncArbitrateAddressWithTimeout(&val,ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT,1,10000000LL);\n > **Note:** Usage of this function entails an implicit Data Memory Barrier (dmb)."]
    pub fn syncArbitrateAddressWithTimeout(
        addr: *mut s32,
        type_: ArbitrationType,
        value: s32,
        timeout_ns: s64,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Initializes a light lock.\n # Arguments\n\n* `lock` - Pointer to the lock."]
    pub fn LightLock_Init(lock: *mut LightLock);
}
unsafe extern "C" {
    #[doc = "Locks a light lock.\n # Arguments\n\n* `lock` - Pointer to the lock."]
    pub fn LightLock_Lock(lock: *mut LightLock);
}
unsafe extern "C" {
    #[doc = "Attempts to lock a light lock.\n # Arguments\n\n* `lock` - Pointer to the lock.\n # Returns\n\nZero on success, non-zero on failure."]
    pub fn LightLock_TryLock(lock: *mut LightLock) -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Unlocks a light lock.\n # Arguments\n\n* `lock` - Pointer to the lock."]
    pub fn LightLock_Unlock(lock: *mut LightLock);
}
unsafe extern "C" {
    #[doc = "Initializes a recursive lock.\n # Arguments\n\n* `lock` - Pointer to the lock."]
    pub fn RecursiveLock_Init(lock: *mut RecursiveLock);
}
unsafe extern "C" {
    #[doc = "Locks a recursive lock.\n # Arguments\n\n* `lock` - Pointer to the lock."]
    pub fn RecursiveLock_Lock(lock: *mut RecursiveLock);
}
unsafe extern "C" {
    #[doc = "Attempts to lock a recursive lock.\n # Arguments\n\n* `lock` - Pointer to the lock.\n # Returns\n\nZero on success, non-zero on failure."]
    pub fn RecursiveLock_TryLock(lock: *mut RecursiveLock) -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Unlocks a recursive lock.\n # Arguments\n\n* `lock` - Pointer to the lock."]
    pub fn RecursiveLock_Unlock(lock: *mut RecursiveLock);
}
unsafe extern "C" {
    #[doc = "Initializes a condition variable.\n # Arguments\n\n* `cv` - Pointer to the condition variable."]
    pub fn CondVar_Init(cv: *mut CondVar);
}
unsafe extern "C" {
    #[doc = "Waits on a condition variable.\n # Arguments\n\n* `cv` - Pointer to the condition variable.\n * `lock` - Pointer to the lock to atomically unlock/relock during the wait."]
    pub fn CondVar_Wait(cv: *mut CondVar, lock: *mut LightLock);
}
unsafe extern "C" {
    #[doc = "Waits on a condition variable with a timeout.\n # Arguments\n\n* `cv` - Pointer to the condition variable.\n * `lock` - Pointer to the lock to atomically unlock/relock during the wait.\n * `timeout_ns` - Timeout in nanoseconds.\n # Returns\n\nZero on success, non-zero on failure."]
    pub fn CondVar_WaitTimeout(
        cv: *mut CondVar,
        lock: *mut LightLock,
        timeout_ns: s64,
    ) -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Wakes up threads waiting on a condition variable.\n # Arguments\n\n* `cv` - Pointer to the condition variable.\n * `num_threads` - Maximum number of threads to wake up (or ARBITRATION_SIGNAL_ALL to wake them all)."]
    pub fn CondVar_WakeUp(cv: *mut CondVar, num_threads: s32);
}
unsafe extern "C" {
    #[doc = "Wakes up a single thread waiting on a condition variable.\n # Arguments\n\n* `cv` - Pointer to the condition variable."]
    #[link_name = "CondVar_Signal__extern"]
    pub fn CondVar_Signal(cv: *mut CondVar);
}
unsafe extern "C" {
    #[doc = "Wakes up all threads waiting on a condition variable.\n # Arguments\n\n* `cv` - Pointer to the condition variable."]
    #[link_name = "CondVar_Broadcast__extern"]
    pub fn CondVar_Broadcast(cv: *mut CondVar);
}
unsafe extern "C" {
    #[doc = "Initializes a light event.\n # Arguments\n\n* `event` - Pointer to the event.\n * `reset_type` - Type of reset the event uses (RESET_ONESHOT/RESET_STICKY)."]
    pub fn LightEvent_Init(event: *mut LightEvent, reset_type: ResetType);
}
unsafe extern "C" {
    #[doc = "Clears a light event.\n # Arguments\n\n* `event` - Pointer to the event."]
    pub fn LightEvent_Clear(event: *mut LightEvent);
}
unsafe extern "C" {
    #[doc = "Wakes up threads waiting on a sticky light event without signaling it. If the event had been signaled before, it is cleared instead.\n # Arguments\n\n* `event` - Pointer to the event."]
    pub fn LightEvent_Pulse(event: *mut LightEvent);
}
unsafe extern "C" {
    #[doc = "Signals a light event, waking up threads waiting on it.\n # Arguments\n\n* `event` - Pointer to the event."]
    pub fn LightEvent_Signal(event: *mut LightEvent);
}
unsafe extern "C" {
    #[doc = "Attempts to wait on a light event.\n # Arguments\n\n* `event` - Pointer to the event.\n # Returns\n\nNon-zero if the event was signaled, zero otherwise."]
    pub fn LightEvent_TryWait(event: *mut LightEvent) -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Waits on a light event.\n # Arguments\n\n* `event` - Pointer to the event."]
    pub fn LightEvent_Wait(event: *mut LightEvent);
}
unsafe extern "C" {
    #[doc = "Waits on a light event until either the event is signaled or the timeout is reached.\n # Arguments\n\n* `event` - Pointer to the event.\n * `timeout_ns` - Timeout in nanoseconds.\n # Returns\n\nNon-zero on timeout, zero otherwise."]
    pub fn LightEvent_WaitTimeout(event: *mut LightEvent, timeout_ns: s64) -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Initializes a light semaphore.\n # Arguments\n\n* `event` - Pointer to the semaphore.\n * `max_count` - Initial count of the semaphore.\n * `max_count` - Maximum count of the semaphore."]
    pub fn LightSemaphore_Init(semaphore: *mut LightSemaphore, initial_count: s16, max_count: s16);
}
unsafe extern "C" {
    #[doc = "Acquires a light semaphore.\n # Arguments\n\n* `semaphore` - Pointer to the semaphore.\n * `count` - Acquire count"]
    pub fn LightSemaphore_Acquire(semaphore: *mut LightSemaphore, count: s32);
}
unsafe extern "C" {
    #[doc = "Attempts to acquire a light semaphore.\n # Arguments\n\n* `semaphore` - Pointer to the semaphore.\n * `count` - Acquire count\n # Returns\n\nZero on success, non-zero on failure"]
    pub fn LightSemaphore_TryAcquire(semaphore: *mut LightSemaphore, count: s32) -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Releases a light semaphore.\n # Arguments\n\n* `semaphore` - Pointer to the semaphore.\n * `count` - Release count"]
    pub fn LightSemaphore_Release(semaphore: *mut LightSemaphore, count: s32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Thread_tag {
    _unused: [u8; 0],
}
#[doc = "libctru thread handle type"]
pub type Thread = *mut Thread_tag;
#[doc = "Exception handler type, necessarily an ARM function that does not return."]
pub type ExceptionHandler = ::core::option::Option<
    unsafe extern "C" fn(excep: *mut ERRF_ExceptionInfo, regs: *mut CpuRegisters),
>;
unsafe extern "C" {
    #[doc = "Creates a new libctru thread.\n # Arguments\n\n* `entrypoint` - The function that will be called first upon thread creation\n * `arg` - The argument passed to `entrypoint`\n * `stack_size` - The size of the stack that will be allocated for the thread (will be rounded to a multiple of 8 bytes)\n * `prio` - Low values gives the thread higher priority.\n For userland apps, this has to be within the range [0x18;0x3F].\n The main thread usually has a priority of 0x30, but not always. Use svcGetThreadPriority() if you need\n to create a thread with a priority that is explicitly greater or smaller than that of the main thread.\n * `core_id` - The ID of the processor the thread should be ran on. Processor IDs are labeled starting from 0.\n On Old3DS it must be <2, and on New3DS it must be <4.\n Pass -1 to execute the thread on all CPUs and -2 to execute the thread on the default CPU (read from the Exheader).\n * `detached` - When set to true, the thread is automatically freed when it finishes.\n # Returns\n\nThe libctru thread handle on success, NULL on failure.\n\n - Processor #0 is the application core. It is always possible to create a thread on this core.\n - Processor #1 is the system core. If APT_SetAppCpuTimeLimit is used, it is possible to create a single thread on this core.\n - Processor #2 is New3DS exclusive. Normal applications can create threads on this core if the exheader kernel flags bitmask has 0x2000 set.\n - Processor #3 is New3DS exclusive. Normal applications cannot create threads on this core.\n - Processes in the BASE memory region can always create threads on processors #2 and #3.\n\n > **Note:** Default exit code of a thread is 0.\n svcExitThread should never be called from the thread, use threadExit instead."]
    pub fn threadCreate(
        entrypoint: ThreadFunc,
        arg: *mut ::libc::c_void,
        stack_size: usize,
        prio: ::libc::c_int,
        core_id: ::libc::c_int,
        detached: bool,
    ) -> Thread;
}
unsafe extern "C" {
    #[doc = "Retrieves the OS thread handle of a libctru thread.\n # Arguments\n\n* `thread` - libctru thread handle\n # Returns\n\nOS thread handle"]
    pub fn threadGetHandle(thread: Thread) -> Handle;
}
unsafe extern "C" {
    #[doc = "Retrieves the exit code of a finished libctru thread.\n # Arguments\n\n* `thread` - libctru thread handle\n # Returns\n\nExit code"]
    pub fn threadGetExitCode(thread: Thread) -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Frees a finished libctru thread.\n # Arguments\n\n* `thread` - libctru thread handle\n > This function should not be called if the thread is detached, as it is freed automatically when it finishes."]
    pub fn threadFree(thread: Thread);
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Waits for a libctru thread to finish (or returns immediately if it is already finished).\n # Arguments\n\n* `thread` - libctru thread handle\n * `timeout_ns` - Timeout in nanoseconds. Pass U64_MAX if a timeout isn't desired"]
    pub fn threadJoin(thread: Thread, timeout_ns: u64_) -> Result;
}
unsafe extern "C" {
    #[doc = "Changes a thread's status from attached to detached.\n # Arguments\n\n* `thread` - libctru thread handle"]
    pub fn threadDetach(thread: Thread);
}
unsafe extern "C" {
    #[doc = "Retrieves the libctru thread handle of the current thread.\n # Returns\n\nlibctru thread handle of the current thread, or NULL for the main thread"]
    pub fn threadGetCurrent() -> Thread;
}
unsafe extern "C" {
    #[doc = "Exits the current libctru thread with an exit code (not usable from the main thread).\n # Arguments\n\n* `rc` - Exit code"]
    pub fn threadExit(rc: ::libc::c_int) -> !;
}
unsafe extern "C" {
    #[doc = "Sets the exception handler for the current thread. Called from the main thread, this sets the default handler.\n # Arguments\n\n* `handler` - The exception handler, necessarily an ARM function that does not return\n * `stack_top` - A pointer to the top of the stack that will be used by the handler. See also RUN_HANDLER_ON_FAULTING_STACK\n * `exception_data` - A pointer to the buffer that will contain the exception data.\nSee also WRITE_DATA_TO_HANDLER_STACK and WRITE_DATA_TO_FAULTING_STACK\n\n To have CPU exceptions reported through this mechanism, it is normally necessary that UNITINFO is set to a non-zero value when Kernel11 starts,\n and this mechanism is also controlled by svcKernelSetState type 6, see 3dbrew.\n\n VFP exceptions are always reported this way even if the process is being debugged using the debug SVCs.\n\n The current thread need not be a libctru thread."]
    #[link_name = "threadOnException__extern"]
    pub fn threadOnException(
        handler: ExceptionHandler,
        stack_top: *mut ::libc::c_void,
        exception_data: *mut ERRF_ExceptionData,
    );
}
#[doc = "Framebuffer information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSPGPU_FramebufferInfo {
    #[doc = "< Active framebuffer. (0 = first, 1 = second)"]
    pub active_framebuf: u32_,
    #[doc = "< Framebuffer virtual address, for the main screen this is the 3D left framebuffer."]
    pub framebuf0_vaddr: *mut u32_,
    #[doc = "< For the main screen: 3D right framebuffer address."]
    pub framebuf1_vaddr: *mut u32_,
    #[doc = "< Value for 0x1EF00X90, controls framebuffer width."]
    pub framebuf_widthbytesize: u32_,
    #[doc = "< Framebuffer format, this u16 is written to the low u16 for LCD register 0x1EF00X70."]
    pub format: u32_,
    #[doc = "< Value for 0x1EF00X78, controls which framebuffer is displayed."]
    pub framebuf_dispselect: u32_,
    #[doc = "< Unknown."]
    pub unk: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GSPGPU_FramebufferInfo"][::core::mem::size_of::<GSPGPU_FramebufferInfo>() - 28usize];
    ["Alignment of GSPGPU_FramebufferInfo"]
        [::core::mem::align_of::<GSPGPU_FramebufferInfo>() - 4usize];
    ["Offset of field: GSPGPU_FramebufferInfo::active_framebuf"]
        [::core::mem::offset_of!(GSPGPU_FramebufferInfo, active_framebuf) - 0usize];
    ["Offset of field: GSPGPU_FramebufferInfo::framebuf0_vaddr"]
        [::core::mem::offset_of!(GSPGPU_FramebufferInfo, framebuf0_vaddr) - 4usize];
    ["Offset of field: GSPGPU_FramebufferInfo::framebuf1_vaddr"]
        [::core::mem::offset_of!(GSPGPU_FramebufferInfo, framebuf1_vaddr) - 8usize];
    ["Offset of field: GSPGPU_FramebufferInfo::framebuf_widthbytesize"]
        [::core::mem::offset_of!(GSPGPU_FramebufferInfo, framebuf_widthbytesize) - 12usize];
    ["Offset of field: GSPGPU_FramebufferInfo::format"]
        [::core::mem::offset_of!(GSPGPU_FramebufferInfo, format) - 16usize];
    ["Offset of field: GSPGPU_FramebufferInfo::framebuf_dispselect"]
        [::core::mem::offset_of!(GSPGPU_FramebufferInfo, framebuf_dispselect) - 20usize];
    ["Offset of field: GSPGPU_FramebufferInfo::unk"]
        [::core::mem::offset_of!(GSPGPU_FramebufferInfo, unk) - 24usize];
};
impl Default for GSPGPU_FramebufferInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< RGBA8. (4 bytes)"]
pub const GSP_RGBA8_OES: GSPGPU_FramebufferFormat = 0;
#[doc = "< BGR8. (3 bytes)"]
pub const GSP_BGR8_OES: GSPGPU_FramebufferFormat = 1;
#[doc = "< RGB565. (2 bytes)"]
pub const GSP_RGB565_OES: GSPGPU_FramebufferFormat = 2;
#[doc = "< RGB5A1. (2 bytes)"]
pub const GSP_RGB5_A1_OES: GSPGPU_FramebufferFormat = 3;
#[doc = "< RGBA4. (2 bytes)"]
pub const GSP_RGBA4_OES: GSPGPU_FramebufferFormat = 4;
#[doc = "Framebuffer format."]
pub type GSPGPU_FramebufferFormat = ::libc::c_uchar;
#[doc = "Capture info entry."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSPGPU_CaptureInfoEntry {
    #[doc = "< Left framebuffer."]
    pub framebuf0_vaddr: *mut u32_,
    #[doc = "< Right framebuffer."]
    pub framebuf1_vaddr: *mut u32_,
    #[doc = "< Framebuffer format."]
    pub format: u32_,
    #[doc = "< Framebuffer pitch."]
    pub framebuf_widthbytesize: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GSPGPU_CaptureInfoEntry"]
        [::core::mem::size_of::<GSPGPU_CaptureInfoEntry>() - 16usize];
    ["Alignment of GSPGPU_CaptureInfoEntry"]
        [::core::mem::align_of::<GSPGPU_CaptureInfoEntry>() - 4usize];
    ["Offset of field: GSPGPU_CaptureInfoEntry::framebuf0_vaddr"]
        [::core::mem::offset_of!(GSPGPU_CaptureInfoEntry, framebuf0_vaddr) - 0usize];
    ["Offset of field: GSPGPU_CaptureInfoEntry::framebuf1_vaddr"]
        [::core::mem::offset_of!(GSPGPU_CaptureInfoEntry, framebuf1_vaddr) - 4usize];
    ["Offset of field: GSPGPU_CaptureInfoEntry::format"]
        [::core::mem::offset_of!(GSPGPU_CaptureInfoEntry, format) - 8usize];
    ["Offset of field: GSPGPU_CaptureInfoEntry::framebuf_widthbytesize"]
        [::core::mem::offset_of!(GSPGPU_CaptureInfoEntry, framebuf_widthbytesize) - 12usize];
};
impl Default for GSPGPU_CaptureInfoEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Capture info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSPGPU_CaptureInfo {
    #[doc = "< Capture info entries, one for each screen."]
    pub screencapture: [GSPGPU_CaptureInfoEntry; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GSPGPU_CaptureInfo"][::core::mem::size_of::<GSPGPU_CaptureInfo>() - 32usize];
    ["Alignment of GSPGPU_CaptureInfo"][::core::mem::align_of::<GSPGPU_CaptureInfo>() - 4usize];
    ["Offset of field: GSPGPU_CaptureInfo::screencapture"]
        [::core::mem::offset_of!(GSPGPU_CaptureInfo, screencapture) - 0usize];
};
impl Default for GSPGPU_CaptureInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Memory fill completed."]
pub const GSPGPU_EVENT_PSC0: GSPGPU_Event = 0;
#[doc = "< TODO"]
pub const GSPGPU_EVENT_PSC1: GSPGPU_Event = 1;
#[doc = "< TODO"]
pub const GSPGPU_EVENT_VBlank0: GSPGPU_Event = 2;
#[doc = "< TODO"]
pub const GSPGPU_EVENT_VBlank1: GSPGPU_Event = 3;
#[doc = "< Display transfer finished."]
pub const GSPGPU_EVENT_PPF: GSPGPU_Event = 4;
#[doc = "< Command list processing finished."]
pub const GSPGPU_EVENT_P3D: GSPGPU_Event = 5;
#[doc = "< TODO"]
pub const GSPGPU_EVENT_DMA: GSPGPU_Event = 6;
#[doc = "< Used to know how many events there are."]
pub const GSPGPU_EVENT_MAX: GSPGPU_Event = 7;
#[doc = "GSPGPU events."]
pub type GSPGPU_Event = ::libc::c_uchar;
#[doc = "GSPGPU performance log entry.\n\n Use the lastDurationUs field when benchmarking single GPU operations, this is usally meant\n for 3D library writers.\n\n Use the difference between two totalDurationUs when using a GPU library (e.g. citro3d), as\n there can be multiple GPU operations (e.g. P3D, PPF) per render pass, or per frame, and so on.\n Don't use totalDurationUs as-is (rather, take the difference as just described), because it\n can overflow."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GSPGPU_PerfLogEntry {
    #[doc = "< Duration of the last corresponding PICA200 operation (time between op is started and IRQ is received)."]
    pub lastDurationUs: u32_,
    #[doc = "< Sum of lastDurationUs for the corresponding PICA200 operation. Can overflow."]
    pub totalDurationUs: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GSPGPU_PerfLogEntry"][::core::mem::size_of::<GSPGPU_PerfLogEntry>() - 8usize];
    ["Alignment of GSPGPU_PerfLogEntry"][::core::mem::align_of::<GSPGPU_PerfLogEntry>() - 4usize];
    ["Offset of field: GSPGPU_PerfLogEntry::lastDurationUs"]
        [::core::mem::offset_of!(GSPGPU_PerfLogEntry, lastDurationUs) - 0usize];
    ["Offset of field: GSPGPU_PerfLogEntry::totalDurationUs"]
        [::core::mem::offset_of!(GSPGPU_PerfLogEntry, totalDurationUs) - 4usize];
};
#[doc = "GSPGPU performance log"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GSPGPU_PerfLog {
    #[doc = "< Performance log entries (one per operation/\"event\")."]
    pub entries: [GSPGPU_PerfLogEntry; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GSPGPU_PerfLog"][::core::mem::size_of::<GSPGPU_PerfLog>() - 56usize];
    ["Alignment of GSPGPU_PerfLog"][::core::mem::align_of::<GSPGPU_PerfLog>() - 4usize];
    ["Offset of field: GSPGPU_PerfLog::entries"]
        [::core::mem::offset_of!(GSPGPU_PerfLog, entries) - 0usize];
};
unsafe extern "C" {
    #[doc = "Gets the number of bytes per pixel for the specified format.\n # Arguments\n\n* `format` - See GSPGPU_FramebufferFormat.\n # Returns\n\nBytes per pixel."]
    #[link_name = "gspGetBytesPerPixel__extern"]
    pub fn gspGetBytesPerPixel(format: GSPGPU_FramebufferFormat) -> ::libc::c_uint;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes GSPGPU."]
    pub fn gspInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits GSPGPU."]
    pub fn gspExit();
}
unsafe extern "C" {
    #[doc = "Gets a pointer to the current gsp::Gpu session handle.\n # Returns\n\nA pointer to the current gsp::Gpu session handle."]
    pub fn gspGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[doc = "Returns true if the application currently has GPU rights."]
    pub fn gspHasGpuRight() -> bool;
}
unsafe extern "C" {
    #[doc = "Presents a buffer to the specified screen.\n # Arguments\n\n* `screen` - Screen ID (see GSP_SCREEN_TOP and GSP_SCREEN_BOTTOM)\n * `swap` - Specifies which set of framebuffer registers to configure and activate (0 or 1)\n * `fb_a` - Pointer to the framebuffer (in stereo mode: left eye)\n * `fb_b` - Pointer to the secondary framebuffer (only used in stereo mode for the right eye, otherwise pass the same as fb_a)\n * `stride` - Stride in bytes between scanlines\n * `mode` - Mode configuration to be written to LCD register\n # Returns\n\ntrue if a buffer had already been presented to the screen but not processed yet by GSP, false otherwise.\n > **Note:** The most recently presented buffer is processed and configured during the specified screen's next VBlank event."]
    pub fn gspPresentBuffer(
        screen: ::libc::c_uint,
        swap: ::libc::c_uint,
        fb_a: *const ::libc::c_void,
        fb_b: *const ::libc::c_void,
        stride: u32_,
        mode: u32_,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Returns true if a prior gspPresentBuffer command is still pending to be processed by GSP.\n # Arguments\n\n* `screen` - Screen ID (see GSP_SCREEN_TOP and GSP_SCREEN_BOTTOM)"]
    pub fn gspIsPresentPending(screen: ::libc::c_uint) -> bool;
}
unsafe extern "C" {
    #[doc = "Configures a callback to run when a GSPGPU event occurs.\n # Arguments\n\n* `id` - ID of the event.\n * `cb` - Callback to run.\n * `data` - Data to be passed to the callback.\n * `oneShot` - When true, the callback is only executed once. When false, the callback is executed every time the event occurs."]
    pub fn gspSetEventCallback(
        id: GSPGPU_Event,
        cb: ThreadFunc,
        data: *mut ::libc::c_void,
        oneShot: bool,
    );
}
unsafe extern "C" {
    #[doc = "Waits for a GSPGPU event to occur.\n # Arguments\n\n* `id` - ID of the event.\n * `nextEvent` - Whether to discard the current event and wait for the next event."]
    pub fn gspWaitForEvent(id: GSPGPU_Event, nextEvent: bool);
}
unsafe extern "C" {
    #[doc = "Waits for any GSPGPU event to occur.\n # Returns\n\nThe ID of the event that occurred.\n\n The function returns immediately if there are unprocessed events at the time of call."]
    pub fn gspWaitForAnyEvent() -> GSPGPU_Event;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Submits a GX command.\n # Arguments\n\n* `gxCommand` - GX command to execute."]
    pub fn gspSubmitGxCommand(gxCommand: *const u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acquires GPU rights.\n # Arguments\n\n* `flags` - Flags to acquire with."]
    pub fn GSPGPU_AcquireRight(flags: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Releases GPU rights."]
    pub fn GSPGPU_ReleaseRight() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrieves display capture info.\n # Arguments\n\n* `captureinfo` - Pointer to output capture info to."]
    pub fn GSPGPU_ImportDisplayCaptureInfo(captureinfo: *mut GSPGPU_CaptureInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Saves the VRAM sys area."]
    pub fn GSPGPU_SaveVramSysArea() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Resets the GPU"]
    pub fn GSPGPU_ResetGpuCore() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Restores the VRAM sys area."]
    pub fn GSPGPU_RestoreVramSysArea() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets whether to force the LCD to black.\n # Arguments\n\n* `flags` - Whether to force the LCD to black. (0 = no, non-zero = yes)"]
    pub fn GSPGPU_SetLcdForceBlack(flags: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates a screen's framebuffer state.\n # Arguments\n\n* `screenid` - ID of the screen to update.\n * `framebufinfo` - Framebuffer information to update with."]
    pub fn GSPGPU_SetBufferSwap(
        screenid: u32_,
        framebufinfo: *const GSPGPU_FramebufferInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Flushes memory from the data cache.\n # Arguments\n\n* `adr` - Address to flush.\n * `size` - Size of the memory to flush."]
    pub fn GSPGPU_FlushDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Invalidates memory in the data cache.\n # Arguments\n\n* `adr` - Address to invalidate.\n * `size` - Size of the memory to invalidate."]
    pub fn GSPGPU_InvalidateDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes to GPU hardware registers.\n # Arguments\n\n* `regAddr` - Register address to write to.\n * `data` - Data to write.\n * `size` - Size of the data to write."]
    pub fn GSPGPU_WriteHWRegs(regAddr: u32_, data: *const u32_, size: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes to GPU hardware registers with a mask.\n # Arguments\n\n* `regAddr` - Register address to write to.\n * `data` - Data to write.\n * `datasize` - Size of the data to write.\n * `maskdata` - Data of the mask.\n * `masksize` - Size of the mask."]
    pub fn GSPGPU_WriteHWRegsWithMask(
        regAddr: u32_,
        data: *const u32_,
        datasize: u8_,
        maskdata: *const u32_,
        masksize: u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads from GPU hardware registers.\n # Arguments\n\n* `regAddr` - Register address to read from.\n * `data` - Buffer to read data to.\n * `size` - Size of the buffer."]
    pub fn GSPGPU_ReadHWRegs(regAddr: u32_, data: *mut u32_, size: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Registers the interrupt relay queue.\n # Arguments\n\n* `eventHandle` - Handle of the GX command event.\n * `flags` - Flags to register with.\n * `outMemHandle` - Pointer to output the shared memory handle to.\n * `threadID` - Pointer to output the GSP thread ID to."]
    pub fn GSPGPU_RegisterInterruptRelayQueue(
        eventHandle: Handle,
        flags: u32_,
        outMemHandle: *mut Handle,
        threadID: *mut u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unregisters the interrupt relay queue."]
    pub fn GSPGPU_UnregisterInterruptRelayQueue() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Triggers a handling of commands written to shared memory."]
    pub fn GSPGPU_TriggerCmdReqQueue() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets 3D_LEDSTATE to the input state value.\n # Arguments\n\n* `disable` - False = 3D LED enable, true = 3D LED disable."]
    pub fn GSPGPU_SetLedForceOff(disable: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Enables or disables the performance log and clear\n its state to zero.\n # Arguments\n\n* `enabled` - Whether to enable the performance log.\n > **Note:** It is assumed that no GPU operation is in progress when calling this function.\n The official sysmodule forgets to clear the \"start tick\" states to 0, though\n this should not be much of an issue (as per the note above)."]
    pub fn GSPGPU_SetPerfLogMode(enabled: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrieves the performance log.\n # Arguments\n\n* `outPerfLog` (direction out) - Pointer to output the performance log to.\n > **Note:** Use the difference between two totalDurationUs when using a GPU library (e.g. citro3d), as\n there can be multiple GPU operations (e.g. P3D, PPF) per render pass, or per frame, and so on.\n Don't use totalDurationUs as-is (rather, take the difference as just described), because it\n can overflow.\n > **Note:** For a MemoryFill operation that uses both PSC0 and PSC1, take the maximum\n of the two \"last duration\" entries.\n > **Note:** For PDC0/PDC1 (VBlank0/1), the \"last duration\" entry corresponds to the time between\n the current PDC (VBlank) IRQ and the previous one. The official GSP sysmodule\n assumes both PDC0 and PDC1 IRQ happens at the same rate (this is almost always\n the case, but not always if user changes PDC timings), and sets both entries\n in the PDC0 handler.\n The official sysmodule doesn't handle the PDC0/1 entries correctly after init. On the first\n frame GSPGPU_SetPerfLogMode is enabled, \"last duration\" will have a nonsensical\n value; and \"total duration\" stays nonsensical. This isn't much of a problem, except for the\n first frame, because \"total duration\" is not supposed to be used as-is (you are supposed\n to take the difference of this field between two time points of your choosing, instead).\n Since it is running at approx. 3.25 GiB/s per bank, some small PSC operations might\n complete before the official GSP has time to record the start time.\n The official sysmodule doesn't properly handle data synchronization for the perflog,\n in practice this should be fine, however."]
    pub fn GSPGPU_GetPerfLog(outPerfLog: *mut GSPGPU_PerfLog) -> Result;
}
#[doc = "< Top screen"]
pub const GFX_TOP: gfxScreen_t = 0;
#[doc = "< Bottom screen"]
pub const GFX_BOTTOM: gfxScreen_t = 1;
#[doc = "Screen IDs."]
pub type gfxScreen_t = ::libc::c_uchar;
#[doc = "< Left eye framebuffer"]
pub const GFX_LEFT: gfx3dSide_t = 0;
#[doc = "< Right eye framebuffer"]
pub const GFX_RIGHT: gfx3dSide_t = 1;
#[doc = "Top screen framebuffer side.\n\n This is only meaningful when stereoscopic 3D is enabled on the top screen.\n In any other case, use GFX_LEFT."]
pub type gfx3dSide_t = ::libc::c_uchar;
unsafe extern "C" {
    #[doc = "Initializes the LCD framebuffers with default parameters\n This is equivalent to calling: gfxInit(GSP_BGR8_OES,GSP_BGR8_OES,false); "]
    pub fn gfxInitDefault();
}
unsafe extern "C" {
    #[doc = "Initializes the LCD framebuffers.\n # Arguments\n\n* `topFormat` - The format of the top screen framebuffers.\n * `bottomFormat` - The format of the bottom screen framebuffers.\n * `vramBuffers` - Whether to allocate the framebuffers in VRAM.\n\n This function allocates memory for the framebuffers in the specified memory region.\n Initially, stereoscopic 3D is disabled and double buffering is enabled.\n\n > **Note:** This function internally calls gspInit."]
    pub fn gfxInit(
        topFormat: GSPGPU_FramebufferFormat,
        bottomFormat: GSPGPU_FramebufferFormat,
        vrambuffers: bool,
    );
}
unsafe extern "C" {
    #[doc = "Deinitializes and frees the LCD framebuffers.\n > **Note:** This function internally calls gspExit."]
    pub fn gfxExit();
}
unsafe extern "C" {
    #[doc = "Enables or disables the 3D stereoscopic effect on the top screen.\n # Arguments\n\n* `enable` - Pass true to enable, false to disable.\n > **Note:** Stereoscopic 3D is disabled by default."]
    pub fn gfxSet3D(enable: bool);
}
unsafe extern "C" {
    #[doc = "Retrieves the status of the 3D stereoscopic effect on the top screen.\n # Returns\n\ntrue if 3D enabled, false otherwise."]
    pub fn gfxIs3D() -> bool;
}
unsafe extern "C" {
    #[doc = "Retrieves the status of the 800px (double-height) high resolution display mode of the top screen.\n # Returns\n\ntrue if wide mode enabled, false otherwise."]
    pub fn gfxIsWide() -> bool;
}
unsafe extern "C" {
    #[doc = "Enables or disables the 800px (double-height) high resolution display mode of the top screen.\n # Arguments\n\n* `enable` - Pass true to enable, false to disable.\n > **Note:** Wide mode is disabled by default.\n > **Note:** Wide and stereoscopic 3D modes are mutually exclusive.\n > **Note:** In wide mode pixels are not square, since scanlines are half as tall as they normally are.\n Wide mode does not work on Old 2DS consoles (however it does work on New 2DS XL consoles)."]
    pub fn gfxSetWide(enable: bool);
}
unsafe extern "C" {
    #[doc = "Changes the pixel format of a screen.\n # Arguments\n\n* `screen` - Screen ID (see gfxScreen_t)\n * `format` - Pixel format (see GSPGPU_FramebufferFormat)\n > **Note:** If the currently allocated framebuffers are too small for the specified format,\n they are freed and new ones are reallocated."]
    pub fn gfxSetScreenFormat(screen: gfxScreen_t, format: GSPGPU_FramebufferFormat);
}
unsafe extern "C" {
    #[doc = "Retrieves the current pixel format of a screen.\n # Arguments\n\n* `screen` - Screen ID (see gfxScreen_t)\n # Returns\n\nPixel format (see GSPGPU_FramebufferFormat)"]
    pub fn gfxGetScreenFormat(screen: gfxScreen_t) -> GSPGPU_FramebufferFormat;
}
unsafe extern "C" {
    #[doc = "Enables or disables double buffering on a screen.\n # Arguments\n\n* `screen` - Screen ID (see gfxScreen_t)\n * `enable` - Pass true to enable, false to disable.\n > **Note:** Double buffering is enabled by default."]
    pub fn gfxSetDoubleBuffering(screen: gfxScreen_t, enable: bool);
}
unsafe extern "C" {
    #[doc = "Retrieves the framebuffer of the specified screen to which graphics should be rendered.\n # Arguments\n\n* `screen` - Screen ID (see gfxScreen_t)\n * `side` - Framebuffer side (see gfx3dSide_t) (pass GFX_LEFT if not using stereoscopic 3D)\n * `width` - Pointer that will hold the width of the framebuffer in pixels.\n * `height` - Pointer that will hold the height of the framebuffer in pixels.\n # Returns\n\nA pointer to the current framebuffer of the chosen screen.\n\n Please remember that the returned pointer will change every frame if double buffering is enabled."]
    pub fn gfxGetFramebuffer(
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        width: *mut u16_,
        height: *mut u16_,
    ) -> *mut u8_;
}
unsafe extern "C" {
    #[doc = "Flushes the data cache for the current framebuffers.\n This is **only used during software rendering**. Since this function has significant overhead,\n it is preferred to call this only once per frame, after all software rendering is completed."]
    pub fn gfxFlushBuffers();
}
unsafe extern "C" {
    #[doc = "Updates the configuration of the specified screen, swapping the buffers if double buffering is enabled.\n # Arguments\n\n* `scr` - Screen ID (see gfxScreen_t)\n * `hasStereo` - For the top screen in 3D mode: true if the framebuffer contains individual images\n for both eyes, or false if the left image should be duplicated to the right eye.\n > **Note:** Previously rendered content will be displayed on the screen after the next VBlank.\n > **Note:** This function is still useful even if double buffering is disabled, as it must be used to commit configuration changes.\n Only call this once per screen per frame, otherwise graphical glitches will occur\n since this API does not implement triple buffering."]
    pub fn gfxScreenSwapBuffers(scr: gfxScreen_t, hasStereo: bool);
}
unsafe extern "C" {
    #[doc = "Same as gfxScreenSwapBuffers, but with hasStereo set to true.\n # Arguments\n\n* `scr` - Screen ID (see gfxScreen_t)\n * `immediate` - This parameter no longer has any effect and is thus ignored.\n > **Deprecated** This function has been superseded by gfxScreenSwapBuffers, please use that instead."]
    pub fn gfxConfigScreen(scr: gfxScreen_t, immediate: bool);
}
unsafe extern "C" {
    #[doc = "Updates the configuration of both screens.\n > **Note:** This function is equivalent to: gfxScreenSwapBuffers(GFX_TOP,true); gfxScreenSwapBuffers(GFX_BOTTOM,true); "]
    pub fn gfxSwapBuffers();
}
unsafe extern "C" {
    #[doc = "Same as gfxSwapBuffers (formerly different)."]
    pub fn gfxSwapBuffersGpu();
}
#[doc = "A callback for printing a character."]
pub type ConsolePrint = ::core::option::Option<
    unsafe extern "C" fn(con: *mut ::libc::c_void, c: ::libc::c_int) -> bool,
>;
#[doc = "A font struct for the console."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConsoleFont {
    #[doc = "< A pointer to the font graphics"]
    pub gfx: *mut u8_,
    #[doc = "< Offset to the first valid character in the font table"]
    pub asciiOffset: u16_,
    #[doc = "< Number of characters in the font graphics"]
    pub numChars: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ConsoleFont"][::core::mem::size_of::<ConsoleFont>() - 8usize];
    ["Alignment of ConsoleFont"][::core::mem::align_of::<ConsoleFont>() - 4usize];
    ["Offset of field: ConsoleFont::gfx"][::core::mem::offset_of!(ConsoleFont, gfx) - 0usize];
    ["Offset of field: ConsoleFont::asciiOffset"]
        [::core::mem::offset_of!(ConsoleFont, asciiOffset) - 4usize];
    ["Offset of field: ConsoleFont::numChars"]
        [::core::mem::offset_of!(ConsoleFont, numChars) - 6usize];
};
impl Default for ConsoleFont {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Console structure used to store the state of a console render context.\n\n Default values from consoleGetDefault();\n PrintConsole defaultConsole =\n {\n \t//Font:\n \t{\n \t\t(u8*)default_font_bin, //font gfx\n \t\t0, //first ascii character in the set\n \t\t128, //number of characters in the font set\n\t},\n\t0,0, //cursorX cursorY\n\t0,0, //prevcursorX prevcursorY\n\t40, //console width\n\t30, //console height\n\t0, //window x\n\t0, //window y\n\t32, //window width\n\t24, //window height\n\t3, //tab size\n\t0, //font character offset\n\t0, //print callback\n\tfalse //console initialized\n };\n "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrintConsole {
    #[doc = "< Font of the console"]
    pub font: ConsoleFont,
    #[doc = "< Framebuffer address"]
    pub frameBuffer: *mut u16_,
    #[doc = "< Current X location of the cursor (as a tile offset by default)"]
    pub cursorX: ::libc::c_int,
    #[doc = "< Current Y location of the cursor (as a tile offset by default)"]
    pub cursorY: ::libc::c_int,
    #[doc = "< Internal state"]
    pub prevCursorX: ::libc::c_int,
    #[doc = "< Internal state"]
    pub prevCursorY: ::libc::c_int,
    #[doc = "< Width of the console hardware layer in characters"]
    pub consoleWidth: ::libc::c_int,
    #[doc = "< Height of the console hardware layer in characters"]
    pub consoleHeight: ::libc::c_int,
    #[doc = "< Window X location in characters (not implemented)"]
    pub windowX: ::libc::c_int,
    #[doc = "< Window Y location in characters (not implemented)"]
    pub windowY: ::libc::c_int,
    #[doc = "< Window width in characters (not implemented)"]
    pub windowWidth: ::libc::c_int,
    #[doc = "< Window height in characters (not implemented)"]
    pub windowHeight: ::libc::c_int,
    #[doc = "< Size of a tab"]
    pub tabSize: ::libc::c_int,
    #[doc = "< Foreground color"]
    pub fg: u16_,
    #[doc = "< Background color"]
    pub bg: u16_,
    #[doc = "< Reverse/bright flags"]
    pub flags: ::libc::c_int,
    #[doc = "< Callback for printing a character. Should return true if it has handled rendering the graphics (else the print engine will attempt to render via tiles)."]
    pub PrintChar: ConsolePrint,
    #[doc = "< True if the console is initialized"]
    pub consoleInitialised: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PrintConsole"][::core::mem::size_of::<PrintConsole>() - 72usize];
    ["Alignment of PrintConsole"][::core::mem::align_of::<PrintConsole>() - 4usize];
    ["Offset of field: PrintConsole::font"][::core::mem::offset_of!(PrintConsole, font) - 0usize];
    ["Offset of field: PrintConsole::frameBuffer"]
        [::core::mem::offset_of!(PrintConsole, frameBuffer) - 8usize];
    ["Offset of field: PrintConsole::cursorX"]
        [::core::mem::offset_of!(PrintConsole, cursorX) - 12usize];
    ["Offset of field: PrintConsole::cursorY"]
        [::core::mem::offset_of!(PrintConsole, cursorY) - 16usize];
    ["Offset of field: PrintConsole::prevCursorX"]
        [::core::mem::offset_of!(PrintConsole, prevCursorX) - 20usize];
    ["Offset of field: PrintConsole::prevCursorY"]
        [::core::mem::offset_of!(PrintConsole, prevCursorY) - 24usize];
    ["Offset of field: PrintConsole::consoleWidth"]
        [::core::mem::offset_of!(PrintConsole, consoleWidth) - 28usize];
    ["Offset of field: PrintConsole::consoleHeight"]
        [::core::mem::offset_of!(PrintConsole, consoleHeight) - 32usize];
    ["Offset of field: PrintConsole::windowX"]
        [::core::mem::offset_of!(PrintConsole, windowX) - 36usize];
    ["Offset of field: PrintConsole::windowY"]
        [::core::mem::offset_of!(PrintConsole, windowY) - 40usize];
    ["Offset of field: PrintConsole::windowWidth"]
        [::core::mem::offset_of!(PrintConsole, windowWidth) - 44usize];
    ["Offset of field: PrintConsole::windowHeight"]
        [::core::mem::offset_of!(PrintConsole, windowHeight) - 48usize];
    ["Offset of field: PrintConsole::tabSize"]
        [::core::mem::offset_of!(PrintConsole, tabSize) - 52usize];
    ["Offset of field: PrintConsole::fg"][::core::mem::offset_of!(PrintConsole, fg) - 56usize];
    ["Offset of field: PrintConsole::bg"][::core::mem::offset_of!(PrintConsole, bg) - 58usize];
    ["Offset of field: PrintConsole::flags"]
        [::core::mem::offset_of!(PrintConsole, flags) - 60usize];
    ["Offset of field: PrintConsole::PrintChar"]
        [::core::mem::offset_of!(PrintConsole, PrintChar) - 64usize];
    ["Offset of field: PrintConsole::consoleInitialised"]
        [::core::mem::offset_of!(PrintConsole, consoleInitialised) - 68usize];
};
impl Default for PrintConsole {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Swallows prints to stderr"]
pub const debugDevice_NULL: debugDevice = 0;
#[doc = "< Outputs stderr debug statements using svcOutputDebugString, which can then be captured by interactive debuggers"]
pub const debugDevice_SVC: debugDevice = 1;
#[doc = "< Directs stderr debug statements to 3DS console window"]
pub const debugDevice_CONSOLE: debugDevice = 2;
pub const debugDevice_3DMOO: debugDevice = 1;
#[doc = "Console debug devices supported by libctru."]
pub type debugDevice = ::libc::c_uchar;
unsafe extern "C" {
    #[doc = "Loads the font into the console.\n # Arguments\n\n* `console` - Pointer to the console to update, if NULL it will update the current console.\n * `font` - The font to load."]
    pub fn consoleSetFont(console: *mut PrintConsole, font: *mut ConsoleFont);
}
unsafe extern "C" {
    #[doc = "Sets the print window.\n # Arguments\n\n* `console` - Console to set, if NULL it will set the current console window.\n * `x` - X location of the window.\n * `y` - Y location of the window.\n * `width` - Width of the window.\n * `height` - Height of the window."]
    pub fn consoleSetWindow(
        console: *mut PrintConsole,
        x: ::libc::c_int,
        y: ::libc::c_int,
        width: ::libc::c_int,
        height: ::libc::c_int,
    );
}
unsafe extern "C" {
    #[doc = "Gets a pointer to the console with the default values.\n This should only be used when using a single console or without changing the console that is returned, otherwise use consoleInit().\n # Returns\n\nA pointer to the console with the default values."]
    pub fn consoleGetDefault() -> *mut PrintConsole;
}
unsafe extern "C" {
    #[doc = "Make the specified console the render target.\n # Arguments\n\n* `console` - A pointer to the console struct (must have been initialized with consoleInit(PrintConsole* console)).\n # Returns\n\nA pointer to the previous console."]
    pub fn consoleSelect(console: *mut PrintConsole) -> *mut PrintConsole;
}
unsafe extern "C" {
    #[doc = "Initialise the console.\n # Arguments\n\n* `screen` - The screen to use for the console.\n * `console` - A pointer to the console data to initialize (if it's NULL, the default console will be used).\n # Returns\n\nA pointer to the current console."]
    pub fn consoleInit(screen: gfxScreen_t, console: *mut PrintConsole) -> *mut PrintConsole;
}
unsafe extern "C" {
    #[doc = "Initializes debug console output on stderr to the specified device.\n # Arguments\n\n* `device` - The debug device (or devices) to output debug print statements to."]
    pub fn consoleDebugInit(device: debugDevice);
}
unsafe extern "C" {
    #[doc = "Clears the screen by using iprintf(\""]
    pub fn consoleClear();
}
#[doc = "< Use APT workaround."]
pub const RUNFLAG_APTWORKAROUND: _bindgen_ty_9 = 1;
#[doc = "< Reinitialize APT."]
pub const RUNFLAG_APTREINIT: _bindgen_ty_9 = 2;
#[doc = "< Chainload APT on return."]
pub const RUNFLAG_APTCHAINLOAD: _bindgen_ty_9 = 4;
#[doc = "System run-flags."]
pub type _bindgen_ty_9 = ::libc::c_uchar;
unsafe extern "C" {
    #[doc = "Gets whether the application was launched from a homebrew environment.\n # Returns\n\nWhether the application was launched from a homebrew environment."]
    #[link_name = "envIsHomebrew__extern"]
    pub fn envIsHomebrew() -> bool;
}
unsafe extern "C" {
    #[doc = "Retrieves a handle from the environment handle list.\n # Arguments\n\n* `name` - Name of the handle.\n # Returns\n\nThe retrieved handle."]
    pub fn envGetHandle(name: *const ::libc::c_char) -> Handle;
}
unsafe extern "C" {
    #[doc = "Gets the environment-recommended app ID to use with APT.\n # Returns\n\nThe APT app ID."]
    #[link_name = "envGetAptAppId__extern"]
    pub fn envGetAptAppId() -> u32_;
}
unsafe extern "C" {
    #[doc = "Gets the size of the application heap.\n # Returns\n\nThe application heap size."]
    #[link_name = "envGetHeapSize__extern"]
    pub fn envGetHeapSize() -> u32_;
}
unsafe extern "C" {
    #[doc = "Gets the size of the linear heap.\n # Returns\n\nThe linear heap size."]
    #[link_name = "envGetLinearHeapSize__extern"]
    pub fn envGetLinearHeapSize() -> u32_;
}
unsafe extern "C" {
    #[doc = "Gets the environment argument list.\n # Returns\n\nThe argument list."]
    #[link_name = "envGetSystemArgList__extern"]
    pub fn envGetSystemArgList() -> *const ::libc::c_char;
}
unsafe extern "C" {
    #[doc = "Gets the environment run flags.\n # Returns\n\nThe run flags."]
    #[link_name = "envGetSystemRunFlags__extern"]
    pub fn envGetSystemRunFlags() -> u32_;
}
pub type __suseconds_t = ::libc::c_long;
#[doc = "< Dummy compression"]
pub const DECOMPRESS_DUMMY: decompressType = 0;
#[doc = "< LZSS/LZ10 compression"]
pub const DECOMPRESS_LZSS: decompressType = 16;
#[doc = "< LZSS/LZ10 compression"]
pub const DECOMPRESS_LZ10: decompressType = 16;
#[doc = "< LZ11 compression"]
pub const DECOMPRESS_LZ11: decompressType = 17;
#[doc = "< Huffman compression with 1-bit data"]
pub const DECOMPRESS_HUFF1: decompressType = 33;
#[doc = "< Huffman compression with 2-bit data"]
pub const DECOMPRESS_HUFF2: decompressType = 34;
#[doc = "< Huffman compression with 3-bit data"]
pub const DECOMPRESS_HUFF3: decompressType = 35;
#[doc = "< Huffman compression with 4-bit data"]
pub const DECOMPRESS_HUFF4: decompressType = 36;
#[doc = "< Huffman compression with 5-bit data"]
pub const DECOMPRESS_HUFF5: decompressType = 37;
#[doc = "< Huffman compression with 6-bit data"]
pub const DECOMPRESS_HUFF6: decompressType = 38;
#[doc = "< Huffman compression with 7-bit data"]
pub const DECOMPRESS_HUFF7: decompressType = 39;
#[doc = "< Huffman compression with 8-bit data"]
pub const DECOMPRESS_HUFF8: decompressType = 40;
#[doc = "< Huffman compression with 8-bit data"]
pub const DECOMPRESS_HUFF: decompressType = 40;
#[doc = "< Run-length encoding compression"]
pub const DECOMPRESS_RLE: decompressType = 48;
#[doc = "Compression types"]
pub type decompressType = ::libc::c_uchar;
#[doc = "I/O vector"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct decompressIOVec {
    #[doc = "< I/O buffer"]
    pub data: *mut ::libc::c_void,
    #[doc = "< Buffer size"]
    pub size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of decompressIOVec"][::core::mem::size_of::<decompressIOVec>() - 8usize];
    ["Alignment of decompressIOVec"][::core::mem::align_of::<decompressIOVec>() - 4usize];
    ["Offset of field: decompressIOVec::data"]
        [::core::mem::offset_of!(decompressIOVec, data) - 0usize];
    ["Offset of field: decompressIOVec::size"]
        [::core::mem::offset_of!(decompressIOVec, size) - 4usize];
};
impl Default for decompressIOVec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Data callback"]
pub type decompressCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::libc::c_void,
        buffer: *mut ::libc::c_void,
        size: usize,
    ) -> isize,
>;
unsafe extern "C" {
    #[doc = "Decompression callback for file descriptors\n # Arguments\n\n* `userdata` (direction in) - Address of file descriptor\n * `buffer` (direction in) - Buffer to write into\n * `size` (direction in) - Size to read from file descriptor\n # Returns\n\nNumber of bytes read"]
    pub fn decompressCallback_FD(
        userdata: *mut ::libc::c_void,
        buffer: *mut ::libc::c_void,
        size: usize,
    ) -> isize;
}
unsafe extern "C" {
    #[doc = "Decompression callback for stdio FILE*\n # Arguments\n\n* `userdata` (direction in) - FILE*\n * `buffer` (direction in) - Buffer to write into\n * `size` (direction in) - Size to read from file descriptor\n # Returns\n\nNumber of bytes read"]
    pub fn decompressCallback_Stdio(
        userdata: *mut ::libc::c_void,
        buffer: *mut ::libc::c_void,
        size: usize,
    ) -> isize;
}
unsafe extern "C" {
    #[doc = "Decode decompression header\n # Arguments\n\n* `type` (direction out) - Decompression type\n * `size` (direction out) - Decompressed size\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nBytes consumed\n * `-1` - error"]
    pub fn decompressHeader(
        type_: *mut decompressType,
        size: *mut usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> isize;
}
unsafe extern "C" {
    #[doc = "Decompress data\n # Arguments\n\n* `iov` (direction in) - Output vector\n * `iovcnt` (direction in) - Number of buffers\n * `callback` (direction in) - Data callback (see note)\n * `userdata` (direction in) - User data passed to callback (see note)\n * `insize` (direction in) - Size of userdata (see note)\n # Returns\n\nWhether succeeded\n\n > **Note:** If callback is null, userdata is a pointer to memory to read from,\n and insize is the size of that data. If callback is not null,\n userdata is passed to callback to fetch more data, and insize is\n unused."]
    pub fn decompressV(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Decompress data\n # Arguments\n\n* `output` (direction in) - Output buffer\n * `size` (direction in) - Output size limit\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    #[link_name = "decompress__extern"]
    pub fn decompress(
        output: *mut ::libc::c_void,
        size: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Decompress LZSS/LZ10\n # Arguments\n\n* `iov` (direction in) - Output vector\n * `iovcnt` (direction in) - Number of buffers\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    pub fn decompressV_LZSS(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Decompress LZSS/LZ10\n # Arguments\n\n* `output` (direction in) - Output buffer\n * `size` (direction in) - Output size limit\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    #[link_name = "decompress_LZSS__extern"]
    pub fn decompress_LZSS(
        output: *mut ::libc::c_void,
        size: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Decompress LZ11\n # Arguments\n\n* `iov` (direction in) - Output vector\n * `iovcnt` (direction in) - Number of buffers\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    pub fn decompressV_LZ11(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Decompress LZ11\n # Arguments\n\n* `output` (direction in) - Output buffer\n * `size` (direction in) - Output size limit\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    #[link_name = "decompress_LZ11__extern"]
    pub fn decompress_LZ11(
        output: *mut ::libc::c_void,
        size: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Decompress Huffman\n # Arguments\n\n* `bits` (direction in) - Data size in bits (usually 4 or 8)\n * `iov` (direction in) - Output vector\n * `iovcnt` (direction in) - Number of buffers\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    pub fn decompressV_Huff(
        bits: usize,
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Decompress Huffman\n # Arguments\n\n* `bits` (direction in) - Data size in bits (usually 4 or 8)\n * `output` (direction in) - Output buffer\n * `size` (direction in) - Output size limit\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    #[link_name = "decompress_Huff__extern"]
    pub fn decompress_Huff(
        bits: usize,
        output: *mut ::libc::c_void,
        size: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Decompress run-length encoding\n # Arguments\n\n* `iov` (direction in) - Output vector\n * `iovcnt` (direction in) - Number of buffers\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    pub fn decompressV_RLE(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Decompress run-length encoding\n # Arguments\n\n* `output` (direction in) - Output buffer\n * `size` (direction in) - Output size limit\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    #[link_name = "decompress_RLE__extern"]
    pub fn decompress_RLE(
        output: *mut ::libc::c_void,
        size: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Convert a UTF-8 sequence into a UTF-32 codepoint\n\n # Arguments\n\n* `out` (direction out) - Output codepoint\n * `in` (direction in) - Input sequence\n\n # Returns\n\nnumber of input code units consumed\n -1 for error"]
    pub fn decode_utf8(out: *mut u32, in_: *const u8) -> isize;
}
unsafe extern "C" {
    #[doc = "Convert a UTF-16 sequence into a UTF-32 codepoint\n\n # Arguments\n\n* `out` (direction out) - Output codepoint\n * `in` (direction in) - Input sequence\n\n # Returns\n\nnumber of input code units consumed\n -1 for error"]
    pub fn decode_utf16(out: *mut u32, in_: *const u16) -> isize;
}
unsafe extern "C" {
    #[doc = "Convert a UTF-32 codepoint into a UTF-8 sequence\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input codepoint\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ must be able to store 4 code units"]
    pub fn encode_utf8(out: *mut u8, in_: u32) -> isize;
}
unsafe extern "C" {
    #[doc = "Convert a UTF-32 codepoint into a UTF-16 sequence\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input codepoint\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ must be able to store 2 code units"]
    pub fn encode_utf16(out: *mut u16, in_: u32) -> isize;
}
unsafe extern "C" {
    #[doc = "Convert a UTF-8 sequence into a UTF-16 sequence\n\n Fills the output buffer up to _len_ code units.\n Returns the number of code units that the input would produce;\n if it returns greater than _len,_ the output has been\n truncated.\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input sequence (null-terminated)\n * `len` (direction in) - Output length\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ is not null-terminated"]
    pub fn utf8_to_utf16(out: *mut u16, in_: *const u8, len: usize) -> isize;
}
unsafe extern "C" {
    #[doc = "Convert a UTF-8 sequence into a UTF-32 sequence\n\n Fills the output buffer up to _len_ code units.\n Returns the number of code units that the input would produce;\n if it returns greater than _len,_ the output has been\n truncated.\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input sequence (null-terminated)\n * `len` (direction in) - Output length\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ is not null-terminated"]
    pub fn utf8_to_utf32(out: *mut u32, in_: *const u8, len: usize) -> isize;
}
unsafe extern "C" {
    #[doc = "Convert a UTF-16 sequence into a UTF-8 sequence\n\n Fills the output buffer up to _len_ code units.\n Returns the number of code units that the input would produce;\n if it returns greater than _len,_ the output has been\n truncated.\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input sequence (null-terminated)\n * `len` (direction in) - Output length\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ is not null-terminated"]
    pub fn utf16_to_utf8(out: *mut u8, in_: *const u16, len: usize) -> isize;
}
unsafe extern "C" {
    #[doc = "Convert a UTF-16 sequence into a UTF-32 sequence\n\n Fills the output buffer up to _len_ code units.\n Returns the number of code units that the input would produce;\n if it returns greater than _len,_ the output has been\n truncated.\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input sequence (null-terminated)\n * `len` (direction in) - Output length\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ is not null-terminated"]
    pub fn utf16_to_utf32(out: *mut u32, in_: *const u16, len: usize) -> isize;
}
unsafe extern "C" {
    #[doc = "Convert a UTF-32 sequence into a UTF-8 sequence\n\n Fills the output buffer up to _len_ code units.\n Returns the number of code units that the input would produce;\n if it returns greater than _len,_ the output has been\n truncated.\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input sequence (null-terminated)\n * `len` (direction in) - Output length\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ is not null-terminated"]
    pub fn utf32_to_utf8(out: *mut u8, in_: *const u32, len: usize) -> isize;
}
unsafe extern "C" {
    #[doc = "Convert a UTF-32 sequence into a UTF-16 sequence\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input sequence (null-terminated)\n * `len` (direction in) - Output length\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ is not null-terminated"]
    pub fn utf32_to_utf16(out: *mut u16, in_: *const u32, len: usize) -> isize;
}
unsafe extern "C" {
    #[doc = "Allocates a 0x80-byte aligned buffer.\n # Arguments\n\n* `size` - Size of the buffer to allocate.\n # Returns\n\nThe allocated buffer."]
    pub fn linearAlloc(size: usize) -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[doc = "Allocates a buffer aligned to the given size.\n # Arguments\n\n* `size` - Size of the buffer to allocate.\n * `alignment` - Alignment to use.\n # Returns\n\nThe allocated buffer."]
    pub fn linearMemAlign(size: usize, alignment: usize) -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[doc = "Reallocates a buffer.\n Note: Not implemented yet.\n # Arguments\n\n* `mem` - Buffer to reallocate.\n * `size` - Size of the buffer to allocate.\n # Returns\n\nThe reallocated buffer."]
    pub fn linearRealloc(mem: *mut ::libc::c_void, size: usize) -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[doc = "Retrieves the allocated size of a buffer.\n # Returns\n\nThe size of the buffer."]
    pub fn linearGetSize(mem: *mut ::libc::c_void) -> usize;
}
unsafe extern "C" {
    #[doc = "Frees a buffer.\n # Arguments\n\n* `mem` - Buffer to free."]
    pub fn linearFree(mem: *mut ::libc::c_void);
}
unsafe extern "C" {
    #[doc = "Gets the current linear free space.\n # Returns\n\nThe current linear free space."]
    pub fn linearSpaceFree() -> u32_;
}
unsafe extern "C" {
    #[doc = "Initializes the mappable allocator.\n # Arguments\n\n* `addrMin` - Minimum address.\n * `addrMax` - Maxium address."]
    pub fn mappableInit(addrMin: u32_, addrMax: u32_);
}
unsafe extern "C" {
    #[doc = "Finds a mappable memory area.\n # Arguments\n\n* `size` - Size of the area to find.\n # Returns\n\nThe mappable area."]
    pub fn mappableAlloc(size: usize) -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[doc = "Frees a mappable area (stubbed).\n # Arguments\n\n* `mem` - Mappable area to free."]
    pub fn mappableFree(mem: *mut ::libc::c_void);
}
pub const VRAM_ALLOC_A: vramAllocPos = 1;
pub const VRAM_ALLOC_B: vramAllocPos = 2;
pub const VRAM_ALLOC_ANY: vramAllocPos = 3;
pub type vramAllocPos = ::libc::c_uchar;
unsafe extern "C" {
    #[doc = "Allocates a 0x80-byte aligned buffer.\n # Arguments\n\n* `size` - Size of the buffer to allocate.\n # Returns\n\nThe allocated buffer."]
    pub fn vramAlloc(size: usize) -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[doc = "Allocates a 0x80-byte aligned buffer in the given VRAM bank.\n # Arguments\n\n* `size` - Size of the buffer to allocate.\n * `pos` - VRAM bank to use (see vramAllocPos).\n # Returns\n\nThe allocated buffer."]
    pub fn vramAllocAt(size: usize, pos: vramAllocPos) -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[doc = "Allocates a buffer aligned to the given size.\n # Arguments\n\n* `size` - Size of the buffer to allocate.\n * `alignment` - Alignment to use.\n # Returns\n\nThe allocated buffer."]
    pub fn vramMemAlign(size: usize, alignment: usize) -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[doc = "Allocates a buffer aligned to the given size in the given VRAM bank.\n # Arguments\n\n* `size` - Size of the buffer to allocate.\n * `alignment` - Alignment to use.\n * `pos` - VRAM bank to use (see vramAllocPos).\n # Returns\n\nThe allocated buffer."]
    pub fn vramMemAlignAt(size: usize, alignment: usize, pos: vramAllocPos) -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[doc = "Reallocates a buffer.\n Note: Not implemented yet.\n # Arguments\n\n* `mem` - Buffer to reallocate.\n * `size` - Size of the buffer to allocate.\n # Returns\n\nThe reallocated buffer."]
    pub fn vramRealloc(mem: *mut ::libc::c_void, size: usize) -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[doc = "Retrieves the allocated size of a buffer.\n # Returns\n\nThe size of the buffer."]
    pub fn vramGetSize(mem: *mut ::libc::c_void) -> usize;
}
unsafe extern "C" {
    #[doc = "Frees a buffer.\n # Arguments\n\n* `mem` - Buffer to free."]
    pub fn vramFree(mem: *mut ::libc::c_void);
}
unsafe extern "C" {
    #[doc = "Gets the current VRAM free space.\n # Returns\n\nThe current VRAM free space."]
    pub fn vramSpaceFree() -> u32_;
}
#[doc = "< Open authentication."]
pub const AC_OPEN: acSecurityMode = 0;
#[doc = "< WEP 40-bit authentication."]
pub const AC_WEP_40BIT: acSecurityMode = 1;
#[doc = "< WEP 104-bit authentication."]
pub const AC_WEP_104BIT: acSecurityMode = 2;
#[doc = "< WEP 128-bit authentication."]
pub const AC_WEP_128BIT: acSecurityMode = 3;
#[doc = "< WPA TKIP authentication."]
pub const AC_WPA_TKIP: acSecurityMode = 4;
#[doc = "< WPA2 TKIP authentication."]
pub const AC_WPA2_TKIP: acSecurityMode = 5;
#[doc = "< WPA AES authentication."]
pub const AC_WPA_AES: acSecurityMode = 6;
#[doc = "< WPA2 AES authentication."]
pub const AC_WPA2_AES: acSecurityMode = 7;
#[doc = "Wifi security modes."]
pub type acSecurityMode = ::libc::c_uchar;
#[doc = "< No access point/none allowed."]
pub const AC_AP_TYPE_NONE: _bindgen_ty_10 = 0;
#[doc = "< Slot 1 in System Settings."]
pub const AC_AP_TYPE_SLOT1: _bindgen_ty_10 = 2;
#[doc = "< Slot 2 in System Settings."]
pub const AC_AP_TYPE_SLOT2: _bindgen_ty_10 = 4;
#[doc = "< Slot 3 in System Settings."]
pub const AC_AP_TYPE_SLOT3: _bindgen_ty_10 = 8;
#[doc = "< All access point types allowed."]
pub const AC_AP_TYPE_ALL: _bindgen_ty_10 = 2147483647;
#[doc = "Wifi access point types (bitfield)."]
pub type _bindgen_ty_10 = ::libc::c_uint;
#[doc = "Struct to contain the data for connecting to a Wifi network from a stored slot."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acuConfig {
    pub reserved: [u8_; 512usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of acuConfig"][::core::mem::size_of::<acuConfig>() - 512usize];
    ["Alignment of acuConfig"][::core::mem::align_of::<acuConfig>() - 1usize];
    ["Offset of field: acuConfig::reserved"][::core::mem::offset_of!(acuConfig, reserved) - 0usize];
};
impl Default for acuConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes AC."]
    pub fn acInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits AC."]
    pub fn acExit();
}
unsafe extern "C" {
    #[doc = "Gets the current AC session handle."]
    pub fn acGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Waits for the system to connect to the internet."]
    pub fn acWaitInternetConnection() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Describes the access point the console is currently connected to with AC_AP_TYPE_* flags.\n # Arguments\n\n* `out` - Pointer to output the combination of AC_AP_TYPE_* flags describing the AP to."]
    pub fn ACU_GetWifiStatus(out: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the connected Wifi status.\n # Arguments\n\n* `out` - Pointer to output the connected Wifi status to. (1 = not connected, 3 = connected)"]
    pub fn ACU_GetStatus(out: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the connected Wifi security mode.\n # Arguments\n\n* `mode` - Pointer to output the connected Wifi security mode to. (0 = Open Authentication, 1 = WEP 40-bit, 2 = WEP 104-bit, 3 = WEP 128-bit, 4 = WPA TKIP, 5 = WPA2 TKIP, 6 = WPA AES, 7 = WPA2 AES)"]
    pub fn ACU_GetSecurityMode(mode: *mut acSecurityMode) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the connected Wifi SSID.\n # Arguments\n\n* `SSID` - Pointer to output the connected Wifi SSID to."]
    pub fn ACU_GetSSID(SSID: *mut ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the connected Wifi SSID length.\n # Arguments\n\n* `out` - Pointer to output the connected Wifi SSID length to."]
    pub fn ACU_GetSSIDLength(out: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Determines whether proxy is enabled for the connected network.\n # Arguments\n\n* `enable` - Pointer to output the proxy status to."]
    pub fn ACU_GetProxyEnable(enable: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the connected network's proxy host.\n # Arguments\n\n* `host` - Pointer to output the proxy host to. (The size must be at least 0x100-bytes)"]
    pub fn ACU_GetProxyHost(host: *mut ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the connected network's proxy port.\n # Arguments\n\n* `out` - Pointer to output the proxy port to."]
    pub fn ACU_GetProxyPort(out: *mut u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the connected network's proxy username.\n # Arguments\n\n* `username` - Pointer to output the proxy username to. (The size must be at least 0x20-bytes)"]
    pub fn ACU_GetProxyUserName(username: *mut ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the connected network's proxy password.\n # Arguments\n\n* `password` - Pointer to output the proxy password to. (The size must be at least 0x20-bytes)"]
    pub fn ACU_GetProxyPassword(password: *mut ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the last error to occur during a connection.\n # Arguments\n\n* `errorCode` - Pointer to output the error code to."]
    pub fn ACU_GetLastErrorCode(errorCode: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the last detailed error to occur during a connection.\n # Arguments\n\n* `errorCode` - Pointer to output the error code to."]
    pub fn ACU_GetLastDetailErrorCode(errorCode: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Prepares a buffer to hold the configuration data to start a connection.\n # Arguments\n\n* `config` - Pointer to an acuConfig struct to contain the data."]
    pub fn ACU_CreateDefaultConfig(config: *mut acuConfig) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets something that makes the connection reliable.\n # Arguments\n\n* `config` - Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously.\n * `area` - Always 2 ?"]
    pub fn ACU_SetNetworkArea(config: *mut acuConfig, area: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the slot to use when connecting.\n # Arguments\n\n* `config` - Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously.\n * `type` - Allowed AP types bitmask, a combination of AC_AP_TYPE_* flags."]
    pub fn ACU_SetAllowApType(config: *mut acuConfig, type_: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets something that makes the connection reliable.\n # Arguments\n\n* `config` - Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously."]
    pub fn ACU_SetRequestEulaVersion(config: *mut acuConfig) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Starts the connection procedure.\n # Arguments\n\n* `config` - Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously.\n * `connectionHandle` - Handle created with svcCreateEvent to wait on until the connection succeeds or fails."]
    pub fn ACU_ConnectAsync(config: *const acuConfig, connectionHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Selects the WiFi configuration slot for further ac:i operations.\n # Arguments\n\n* `slot` - WiFi slot (0, 1 or 2)."]
    pub fn ACI_LoadNetworkSetting(slot: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Fetches the SSID of the previously selected WiFi configuration slot.\n # Arguments\n\n* `ssid` (direction out) - Pointer to the output buffer of size 32B the SSID will be stored in."]
    pub fn ACI_GetNetworkWirelessEssidSecuritySsid(ssid: *mut ::libc::c_void) -> Result;
}
pub type MiiScreenName = [u16_; 11usize];
#[doc = "Shared Base Mii struct"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData {
    #[doc = "< Always 3"]
    pub version: u8_,
    pub mii_options: MiiData__bindgen_ty_1,
    pub mii_pos: MiiData__bindgen_ty_2,
    pub console_identity: MiiData__bindgen_ty_3,
    #[doc = "< Identifies the system that the Mii was created on (Determines pants)"]
    pub system_id: u64_,
    #[doc = "< ID of Mii"]
    pub mii_id: u32_,
    #[doc = "< Creator's system's full MAC address"]
    pub mac: [u8_; 6usize],
    #[doc = "< Padding"]
    pub pad: [u8_; 2usize],
    pub mii_details: MiiData__bindgen_ty_4,
    #[doc = "< Name of Mii (Encoded using UTF16)"]
    pub mii_name: [u16_; 10usize],
    #[doc = "< How tall the Mii is"]
    pub height: u8_,
    #[doc = "< How wide the Mii is"]
    pub width: u8_,
    pub face_style: MiiData__bindgen_ty_5,
    pub face_details: MiiData__bindgen_ty_6,
    pub hair_style: u8_,
    pub hair_details: MiiData__bindgen_ty_7,
    pub eye_details: MiiData__bindgen_ty_8,
    pub eyebrow_details: MiiData__bindgen_ty_9,
    pub nose_details: MiiData__bindgen_ty_10,
    pub mouth_details: MiiData__bindgen_ty_11,
    pub mustache_details: MiiData__bindgen_ty_12,
    pub beard_details: MiiData__bindgen_ty_13,
    pub glasses_details: MiiData__bindgen_ty_14,
    pub mole_details: MiiData__bindgen_ty_15,
    #[doc = "< Name of Mii's author (Encoded using UTF16)"]
    pub author_name: [u16_; 10usize],
}
#[doc = "Mii options"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_1"][::core::mem::size_of::<MiiData__bindgen_ty_1>() - 1usize];
    ["Alignment of MiiData__bindgen_ty_1"]
        [::core::mem::align_of::<MiiData__bindgen_ty_1>() - 1usize];
};
impl MiiData__bindgen_ty_1 {
    #[inline]
    pub fn allow_copying(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allow_copying(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_copying_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_allow_copying_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_private_name(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_private_name(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_private_name_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_private_name_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn region_lock(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_region_lock(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn region_lock_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_region_lock_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn char_set(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_char_set(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn char_set_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_char_set_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        allow_copying: bool,
        is_private_name: bool,
        region_lock: u8_,
        char_set: u8_,
        _pad: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let allow_copying: u8 = unsafe { ::core::mem::transmute(allow_copying) };
            allow_copying as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_private_name: u8 = unsafe { ::core::mem::transmute(is_private_name) };
            is_private_name as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let region_lock: u8 = unsafe { ::core::mem::transmute(region_lock) };
            region_lock as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let char_set: u8 = unsafe { ::core::mem::transmute(char_set) };
            char_set as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let _pad: u8 = unsafe { ::core::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mii position in Mii selector or Mii maker"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_2"][::core::mem::size_of::<MiiData__bindgen_ty_2>() - 1usize];
    ["Alignment of MiiData__bindgen_ty_2"]
        [::core::mem::align_of::<MiiData__bindgen_ty_2>() - 1usize];
};
impl MiiData__bindgen_ty_2 {
    #[inline]
    pub fn page_index(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_page_index(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn page_index_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_page_index_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn slot_index(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_slot_index(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn slot_index_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_slot_index_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(page_index: u8_, slot_index: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let page_index: u8 = unsafe { ::core::mem::transmute(page_index) };
            page_index as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let slot_index: u8 = unsafe { ::core::mem::transmute(slot_index) };
            slot_index as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Console Identity"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_3 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_3"][::core::mem::size_of::<MiiData__bindgen_ty_3>() - 1usize];
    ["Alignment of MiiData__bindgen_ty_3"]
        [::core::mem::align_of::<MiiData__bindgen_ty_3>() - 1usize];
};
impl MiiData__bindgen_ty_3 {
    #[inline]
    pub fn unknown0(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unknown0(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn unknown0_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_unknown0_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn origin_console(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_origin_console(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn origin_console_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_origin_console_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u8_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unknown0: u8_,
        origin_console: u8_,
        _pad: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let unknown0: u8 = unsafe { ::core::mem::transmute(unknown0) };
            unknown0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let origin_console: u8 = unsafe { ::core::mem::transmute(origin_console) };
            origin_console as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let _pad: u8 = unsafe { ::core::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mii details"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_4 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_4"][::core::mem::size_of::<MiiData__bindgen_ty_4>() - 2usize];
    ["Alignment of MiiData__bindgen_ty_4"]
        [::core::mem::align_of::<MiiData__bindgen_ty_4>() - 1usize];
};
impl MiiData__bindgen_ty_4 {
    #[inline]
    pub fn sex(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sex(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sex_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sex_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bday_month(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_bday_month(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bday_month_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_bday_month_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bday_day(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_bday_day(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bday_day_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_bday_day_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shirt_color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_shirt_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shirt_color_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_shirt_color_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn favorite(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_favorite(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn favorite_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_favorite_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sex: bool,
        bday_month: u16_,
        bday_day: u16_,
        shirt_color: u16_,
        favorite: u16_,
        _pad: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sex: u8 = unsafe { ::core::mem::transmute(sex) };
            sex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let bday_month: u16 = unsafe { ::core::mem::transmute(bday_month) };
            bday_month as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let bday_day: u16 = unsafe { ::core::mem::transmute(bday_day) };
            bday_day as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let shirt_color: u16 = unsafe { ::core::mem::transmute(shirt_color) };
            shirt_color as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let favorite: u16 = unsafe { ::core::mem::transmute(favorite) };
            favorite as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let _pad: u16 = unsafe { ::core::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Face style"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_5 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_5"][::core::mem::size_of::<MiiData__bindgen_ty_5>() - 1usize];
    ["Alignment of MiiData__bindgen_ty_5"]
        [::core::mem::align_of::<MiiData__bindgen_ty_5>() - 1usize];
};
impl MiiData__bindgen_ty_5 {
    #[inline]
    pub fn disable_sharing(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_disable_sharing(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disable_sharing_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_disable_sharing_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn shape(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_shape(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shape_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_shape_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skinColor(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_skinColor(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skinColor_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_skinColor_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_sharing: u16_,
        shape: u16_,
        skinColor: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disable_sharing: u16 = unsafe { ::core::mem::transmute(disable_sharing) };
            disable_sharing as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let shape: u16 = unsafe { ::core::mem::transmute(shape) };
            shape as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let skinColor: u16 = unsafe { ::core::mem::transmute(skinColor) };
            skinColor as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Face details"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_6 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_6"][::core::mem::size_of::<MiiData__bindgen_ty_6>() - 1usize];
    ["Alignment of MiiData__bindgen_ty_6"]
        [::core::mem::align_of::<MiiData__bindgen_ty_6>() - 1usize];
};
impl MiiData__bindgen_ty_6 {
    #[inline]
    pub fn wrinkles(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_wrinkles(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wrinkles_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_wrinkles_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn makeup(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_makeup(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn makeup_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_makeup_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(wrinkles: u16_, makeup: u16_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let wrinkles: u16 = unsafe { ::core::mem::transmute(wrinkles) };
            wrinkles as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let makeup: u16 = unsafe { ::core::mem::transmute(makeup) };
            makeup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Hair details"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_7 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_7"][::core::mem::size_of::<MiiData__bindgen_ty_7>() - 1usize];
    ["Alignment of MiiData__bindgen_ty_7"]
        [::core::mem::align_of::<MiiData__bindgen_ty_7>() - 1usize];
};
impl MiiData__bindgen_ty_7 {
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn color_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_color_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flip(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_flip(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flip_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_flip_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        color: u16_,
        flip: u16_,
        _pad: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let flip: u16 = unsafe { ::core::mem::transmute(flip) };
            flip as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let _pad: u16 = unsafe { ::core::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Eye details"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_8 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_8"][::core::mem::size_of::<MiiData__bindgen_ty_8>() - 4usize];
    ["Alignment of MiiData__bindgen_ty_8"]
        [::core::mem::align_of::<MiiData__bindgen_ty_8>() - 1usize];
};
impl MiiData__bindgen_ty_8 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn style_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_style_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn color_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_color_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scale_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_scale_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn yscale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_yscale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn yscale_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_yscale_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rotation(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_rotation(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rotation_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_rotation_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn xspacing(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_xspacing(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn xspacing_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_xspacing_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn yposition(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_yposition(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn yposition_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_yposition_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        color: u16_,
        scale: u16_,
        yscale: u16_,
        rotation: u16_,
        xspacing: u16_,
        yposition: u16_,
        _pad: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let yscale: u16 = unsafe { ::core::mem::transmute(yscale) };
            yscale as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let rotation: u16 = unsafe { ::core::mem::transmute(rotation) };
            rotation as u64
        });
        __bindgen_bitfield_unit.set(21usize, 4u8, {
            let xspacing: u16 = unsafe { ::core::mem::transmute(xspacing) };
            xspacing as u64
        });
        __bindgen_bitfield_unit.set(25usize, 5u8, {
            let yposition: u16 = unsafe { ::core::mem::transmute(yposition) };
            yposition as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let _pad: u16 = unsafe { ::core::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Eyebrow details"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_9 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_9"][::core::mem::size_of::<MiiData__bindgen_ty_9>() - 4usize];
    ["Alignment of MiiData__bindgen_ty_9"]
        [::core::mem::align_of::<MiiData__bindgen_ty_9>() - 1usize];
};
impl MiiData__bindgen_ty_9 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn style_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_style_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn color_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_color_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scale_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_scale_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn yscale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_yscale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn yscale_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_yscale_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rotation(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_rotation(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rotation_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_rotation_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn xspacing(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_xspacing(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn xspacing_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_xspacing_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn yposition(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_yposition(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn yposition_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_yposition_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad2(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set__pad2(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad2_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set__pad2_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        color: u16_,
        scale: u16_,
        yscale: u16_,
        _pad: u16_,
        rotation: u16_,
        xspacing: u16_,
        yposition: u16_,
        _pad2: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let yscale: u16 = unsafe { ::core::mem::transmute(yscale) };
            yscale as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let _pad: u16 = unsafe { ::core::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let rotation: u16 = unsafe { ::core::mem::transmute(rotation) };
            rotation as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let xspacing: u16 = unsafe { ::core::mem::transmute(xspacing) };
            xspacing as u64
        });
        __bindgen_bitfield_unit.set(24usize, 5u8, {
            let yposition: u16 = unsafe { ::core::mem::transmute(yposition) };
            yposition as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let _pad2: u16 = unsafe { ::core::mem::transmute(_pad2) };
            _pad2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Nose details"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_10 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_10"][::core::mem::size_of::<MiiData__bindgen_ty_10>() - 2usize];
    ["Alignment of MiiData__bindgen_ty_10"]
        [::core::mem::align_of::<MiiData__bindgen_ty_10>() - 1usize];
};
impl MiiData__bindgen_ty_10 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn style_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_style_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scale_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_scale_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn yposition(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_yposition(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn yposition_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_yposition_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        scale: u16_,
        yposition: u16_,
        _pad: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(9usize, 5u8, {
            let yposition: u16 = unsafe { ::core::mem::transmute(yposition) };
            yposition as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let _pad: u16 = unsafe { ::core::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mouth details"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_11 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_11"][::core::mem::size_of::<MiiData__bindgen_ty_11>() - 2usize];
    ["Alignment of MiiData__bindgen_ty_11"]
        [::core::mem::align_of::<MiiData__bindgen_ty_11>() - 1usize];
};
impl MiiData__bindgen_ty_11 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn style_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_style_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn color_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_color_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scale_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_scale_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn yscale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_yscale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn yscale_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_yscale_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        color: u16_,
        scale: u16_,
        yscale: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let yscale: u16 = unsafe { ::core::mem::transmute(yscale) };
            yscale as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mustache details"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_12 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_12"][::core::mem::size_of::<MiiData__bindgen_ty_12>() - 2usize];
    ["Alignment of MiiData__bindgen_ty_12"]
        [::core::mem::align_of::<MiiData__bindgen_ty_12>() - 1usize];
};
impl MiiData__bindgen_ty_12 {
    #[inline]
    pub fn mouth_yposition(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_mouth_yposition(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mouth_yposition_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_mouth_yposition_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mustache_style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_mustache_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mustache_style_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_mustache_style_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mouth_yposition: u16_,
        mustache_style: u16_,
        _pad: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let mouth_yposition: u16 = unsafe { ::core::mem::transmute(mouth_yposition) };
            mouth_yposition as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let mustache_style: u16 = unsafe { ::core::mem::transmute(mustache_style) };
            mustache_style as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let _pad: u16 = unsafe { ::core::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Beard details"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_13 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_13"][::core::mem::size_of::<MiiData__bindgen_ty_13>() - 2usize];
    ["Alignment of MiiData__bindgen_ty_13"]
        [::core::mem::align_of::<MiiData__bindgen_ty_13>() - 1usize];
};
impl MiiData__bindgen_ty_13 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn style_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_style_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn color_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_color_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scale_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_scale_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ypos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_ypos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ypos_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ypos_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        color: u16_,
        scale: u16_,
        ypos: u16_,
        _pad: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let ypos: u16 = unsafe { ::core::mem::transmute(ypos) };
            ypos as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let _pad: u16 = unsafe { ::core::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Glasses details"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_14 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_14"][::core::mem::size_of::<MiiData__bindgen_ty_14>() - 2usize];
    ["Alignment of MiiData__bindgen_ty_14"]
        [::core::mem::align_of::<MiiData__bindgen_ty_14>() - 1usize];
};
impl MiiData__bindgen_ty_14 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn style_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_style_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn color_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_color_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scale_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_scale_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ypos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_ypos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ypos_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ypos_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        color: u16_,
        scale: u16_,
        ypos: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(7usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let ypos: u16 = unsafe { ::core::mem::transmute(ypos) };
            ypos as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mole details"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_15 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData__bindgen_ty_15"][::core::mem::size_of::<MiiData__bindgen_ty_15>() - 2usize];
    ["Alignment of MiiData__bindgen_ty_15"]
        [::core::mem::align_of::<MiiData__bindgen_ty_15>() - 1usize];
};
impl MiiData__bindgen_ty_15 {
    #[inline]
    pub fn enable(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_enable_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scale_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_scale_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn xpos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_xpos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn xpos_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_xpos_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ypos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_ypos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ypos_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ypos_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _pad(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _pad_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set__pad_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable: bool,
        scale: u16_,
        xpos: u16_,
        ypos: u16_,
        _pad: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u8 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let xpos: u16 = unsafe { ::core::mem::transmute(xpos) };
            xpos as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let ypos: u16 = unsafe { ::core::mem::transmute(ypos) };
            ypos as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let _pad: u16 = unsafe { ::core::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiData"][::core::mem::size_of::<MiiData>() - 92usize];
    ["Alignment of MiiData"][::core::mem::align_of::<MiiData>() - 1usize];
    ["Offset of field: MiiData::version"][::core::mem::offset_of!(MiiData, version) - 0usize];
    ["Offset of field: MiiData::mii_options"]
        [::core::mem::offset_of!(MiiData, mii_options) - 1usize];
    ["Offset of field: MiiData::mii_pos"][::core::mem::offset_of!(MiiData, mii_pos) - 2usize];
    ["Offset of field: MiiData::console_identity"]
        [::core::mem::offset_of!(MiiData, console_identity) - 3usize];
    ["Offset of field: MiiData::system_id"][::core::mem::offset_of!(MiiData, system_id) - 4usize];
    ["Offset of field: MiiData::mii_id"][::core::mem::offset_of!(MiiData, mii_id) - 12usize];
    ["Offset of field: MiiData::mac"][::core::mem::offset_of!(MiiData, mac) - 16usize];
    ["Offset of field: MiiData::pad"][::core::mem::offset_of!(MiiData, pad) - 22usize];
    ["Offset of field: MiiData::mii_details"]
        [::core::mem::offset_of!(MiiData, mii_details) - 24usize];
    ["Offset of field: MiiData::mii_name"][::core::mem::offset_of!(MiiData, mii_name) - 26usize];
    ["Offset of field: MiiData::height"][::core::mem::offset_of!(MiiData, height) - 46usize];
    ["Offset of field: MiiData::width"][::core::mem::offset_of!(MiiData, width) - 47usize];
    ["Offset of field: MiiData::face_style"]
        [::core::mem::offset_of!(MiiData, face_style) - 48usize];
    ["Offset of field: MiiData::face_details"]
        [::core::mem::offset_of!(MiiData, face_details) - 49usize];
    ["Offset of field: MiiData::hair_style"]
        [::core::mem::offset_of!(MiiData, hair_style) - 50usize];
    ["Offset of field: MiiData::hair_details"]
        [::core::mem::offset_of!(MiiData, hair_details) - 51usize];
    ["Offset of field: MiiData::eye_details"]
        [::core::mem::offset_of!(MiiData, eye_details) - 52usize];
    ["Offset of field: MiiData::eyebrow_details"]
        [::core::mem::offset_of!(MiiData, eyebrow_details) - 56usize];
    ["Offset of field: MiiData::nose_details"]
        [::core::mem::offset_of!(MiiData, nose_details) - 60usize];
    ["Offset of field: MiiData::mouth_details"]
        [::core::mem::offset_of!(MiiData, mouth_details) - 62usize];
    ["Offset of field: MiiData::mustache_details"]
        [::core::mem::offset_of!(MiiData, mustache_details) - 64usize];
    ["Offset of field: MiiData::beard_details"]
        [::core::mem::offset_of!(MiiData, beard_details) - 66usize];
    ["Offset of field: MiiData::glasses_details"]
        [::core::mem::offset_of!(MiiData, glasses_details) - 68usize];
    ["Offset of field: MiiData::mole_details"]
        [::core::mem::offset_of!(MiiData, mole_details) - 70usize];
    ["Offset of field: MiiData::author_name"]
        [::core::mem::offset_of!(MiiData, author_name) - 72usize];
};
pub type FriendComment = [u16_; 17usize];
pub type FriendGameModeDescription = [u16_; 128usize];
pub type ScrambledFriendCode = [u16_; 6usize];
pub type NfsTypeStr = [::libc::c_char; 3usize];
#[doc = "Friend key data"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FriendKey {
    pub principalId: u32_,
    pub padding: u32_,
    pub localFriendCode: u64_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FriendKey"][::core::mem::size_of::<FriendKey>() - 16usize];
    ["Alignment of FriendKey"][::core::mem::align_of::<FriendKey>() - 1usize];
    ["Offset of field: FriendKey::principalId"]
        [::core::mem::offset_of!(FriendKey, principalId) - 0usize];
    ["Offset of field: FriendKey::padding"][::core::mem::offset_of!(FriendKey, padding) - 4usize];
    ["Offset of field: FriendKey::localFriendCode"]
        [::core::mem::offset_of!(FriendKey, localFriendCode) - 8usize];
};
#[doc = "Game key data"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GameKey {
    pub titleId: u64_,
    pub version: u16_,
    pub reserved: [u8_; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GameKey"][::core::mem::size_of::<GameKey>() - 16usize];
    ["Alignment of GameKey"][::core::mem::align_of::<GameKey>() - 1usize];
    ["Offset of field: GameKey::titleId"][::core::mem::offset_of!(GameKey, titleId) - 0usize];
    ["Offset of field: GameKey::version"][::core::mem::offset_of!(GameKey, version) - 8usize];
    ["Offset of field: GameKey::reserved"][::core::mem::offset_of!(GameKey, reserved) - 10usize];
};
#[doc = "Base profile data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Profile {
    #[doc = "< The region code for the hardware."]
    pub region: u8_,
    #[doc = "< Country code."]
    pub country: u8_,
    #[doc = "< Area code."]
    pub area: u8_,
    #[doc = "< Language code."]
    pub language: u8_,
    #[doc = "< Platform code."]
    pub platform: u8_,
    pub padding: [u8_; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Profile"][::core::mem::size_of::<Profile>() - 8usize];
    ["Alignment of Profile"][::core::mem::align_of::<Profile>() - 1usize];
    ["Offset of field: Profile::region"][::core::mem::offset_of!(Profile, region) - 0usize];
    ["Offset of field: Profile::country"][::core::mem::offset_of!(Profile, country) - 1usize];
    ["Offset of field: Profile::area"][::core::mem::offset_of!(Profile, area) - 2usize];
    ["Offset of field: Profile::language"][::core::mem::offset_of!(Profile, language) - 3usize];
    ["Offset of field: Profile::platform"][::core::mem::offset_of!(Profile, platform) - 4usize];
    ["Offset of field: Profile::padding"][::core::mem::offset_of!(Profile, padding) - 5usize];
};
#[doc = "Friend profile data"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FriendProfile {
    #[doc = "< Base profile data of this friend."]
    pub profile: Profile,
    #[doc = "< Favorite game of this friend."]
    pub favoriteGame: GameKey,
    #[doc = "< NC PrincipalID of this friend."]
    pub ncPrincipalId: u32_,
    #[doc = "< Personal message (comment) of this friend."]
    pub personalMessage: FriendComment,
    pub pad: [u8_; 2usize],
    #[doc = "< NEX timestamp of when this friend was last seen online."]
    pub lastOnlineTimestamp: s64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FriendProfile"][::core::mem::size_of::<FriendProfile>() - 72usize];
    ["Alignment of FriendProfile"][::core::mem::align_of::<FriendProfile>() - 1usize];
    ["Offset of field: FriendProfile::profile"]
        [::core::mem::offset_of!(FriendProfile, profile) - 0usize];
    ["Offset of field: FriendProfile::favoriteGame"]
        [::core::mem::offset_of!(FriendProfile, favoriteGame) - 8usize];
    ["Offset of field: FriendProfile::ncPrincipalId"]
        [::core::mem::offset_of!(FriendProfile, ncPrincipalId) - 24usize];
    ["Offset of field: FriendProfile::personalMessage"]
        [::core::mem::offset_of!(FriendProfile, personalMessage) - 28usize];
    ["Offset of field: FriendProfile::pad"][::core::mem::offset_of!(FriendProfile, pad) - 62usize];
    ["Offset of field: FriendProfile::lastOnlineTimestamp"]
        [::core::mem::offset_of!(FriendProfile, lastOnlineTimestamp) - 64usize];
};
#[doc = "Base presence data"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Presence {
    pub joinAvailabilityFlag: u32_,
    pub matchmakeSystemType: u32_,
    pub joinGameId: u32_,
    pub joinGameMode: u32_,
    pub ownerPrincipalId: u32_,
    pub joinGroupId: u32_,
    pub applicationArg: [u8_; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Presence"][::core::mem::size_of::<Presence>() - 44usize];
    ["Alignment of Presence"][::core::mem::align_of::<Presence>() - 1usize];
    ["Offset of field: Presence::joinAvailabilityFlag"]
        [::core::mem::offset_of!(Presence, joinAvailabilityFlag) - 0usize];
    ["Offset of field: Presence::matchmakeSystemType"]
        [::core::mem::offset_of!(Presence, matchmakeSystemType) - 4usize];
    ["Offset of field: Presence::joinGameId"]
        [::core::mem::offset_of!(Presence, joinGameId) - 8usize];
    ["Offset of field: Presence::joinGameMode"]
        [::core::mem::offset_of!(Presence, joinGameMode) - 12usize];
    ["Offset of field: Presence::ownerPrincipalId"]
        [::core::mem::offset_of!(Presence, ownerPrincipalId) - 16usize];
    ["Offset of field: Presence::joinGroupId"]
        [::core::mem::offset_of!(Presence, joinGroupId) - 20usize];
    ["Offset of field: Presence::applicationArg"]
        [::core::mem::offset_of!(Presence, applicationArg) - 24usize];
};
#[doc = "Current user's presence data"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MyPresence {
    #[doc = "< The actual presence data."]
    pub presence: Presence,
    #[doc = "< The game mode description of the current user."]
    pub gameModeDescription: FriendGameModeDescription,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MyPresence"][::core::mem::size_of::<MyPresence>() - 300usize];
    ["Alignment of MyPresence"][::core::mem::align_of::<MyPresence>() - 1usize];
    ["Offset of field: MyPresence::presence"]
        [::core::mem::offset_of!(MyPresence, presence) - 0usize];
    ["Offset of field: MyPresence::gameModeDescription"]
        [::core::mem::offset_of!(MyPresence, gameModeDescription) - 44usize];
};
impl Default for MyPresence {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Friend presence data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FriendPresence {
    #[doc = "< The actual presence data."]
    pub presence: Presence,
    #[doc = "< Whether or not the presence data for this user has been loaded from the server."]
    pub isPresenceLoaded: bool,
    #[doc = "< Whether or not this friend has sent the current user an invitation."]
    pub hasSentInvitation: bool,
    #[doc = "< Whether or not this friend was found."]
    pub found: bool,
    pub pad: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FriendPresence"][::core::mem::size_of::<FriendPresence>() - 48usize];
    ["Alignment of FriendPresence"][::core::mem::align_of::<FriendPresence>() - 1usize];
    ["Offset of field: FriendPresence::presence"]
        [::core::mem::offset_of!(FriendPresence, presence) - 0usize];
    ["Offset of field: FriendPresence::isPresenceLoaded"]
        [::core::mem::offset_of!(FriendPresence, isPresenceLoaded) - 44usize];
    ["Offset of field: FriendPresence::hasSentInvitation"]
        [::core::mem::offset_of!(FriendPresence, hasSentInvitation) - 45usize];
    ["Offset of field: FriendPresence::found"]
        [::core::mem::offset_of!(FriendPresence, found) - 46usize];
    ["Offset of field: FriendPresence::pad"]
        [::core::mem::offset_of!(FriendPresence, pad) - 47usize];
};
#[doc = "Friend Mii data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FriendMii {
    #[doc = "< Whether or not the Mii contains profanity."]
    pub profanityFlag: bool,
    #[doc = "< The character set for text data."]
    pub characterSet: u8_,
    #[doc = "< Whether or not the Mii is marked as \"dirty\" (needs to be uploaded to the server)."]
    pub dirtyFlag: bool,
    pub pad: u8_,
    #[doc = "< The actual Mii data."]
    pub mii: MiiData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FriendMii"][::core::mem::size_of::<FriendMii>() - 96usize];
    ["Alignment of FriendMii"][::core::mem::align_of::<FriendMii>() - 1usize];
    ["Offset of field: FriendMii::profanityFlag"]
        [::core::mem::offset_of!(FriendMii, profanityFlag) - 0usize];
    ["Offset of field: FriendMii::characterSet"]
        [::core::mem::offset_of!(FriendMii, characterSet) - 1usize];
    ["Offset of field: FriendMii::dirtyFlag"]
        [::core::mem::offset_of!(FriendMii, dirtyFlag) - 2usize];
    ["Offset of field: FriendMii::pad"][::core::mem::offset_of!(FriendMii, pad) - 3usize];
    ["Offset of field: FriendMii::mii"][::core::mem::offset_of!(FriendMii, mii) - 4usize];
};
#[doc = "Friend playing game structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FriendPlayingGame {
    #[doc = "< Game key of the game."]
    pub game: GameKey,
    pub gameModeDescription: FriendGameModeDescription,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FriendPlayingGame"][::core::mem::size_of::<FriendPlayingGame>() - 272usize];
    ["Alignment of FriendPlayingGame"][::core::mem::align_of::<FriendPlayingGame>() - 1usize];
    ["Offset of field: FriendPlayingGame::game"]
        [::core::mem::offset_of!(FriendPlayingGame, game) - 0usize];
    ["Offset of field: FriendPlayingGame::gameModeDescription"]
        [::core::mem::offset_of!(FriendPlayingGame, gameModeDescription) - 16usize];
};
impl Default for FriendPlayingGame {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Friend info structure"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FriendInfo {
    #[doc = "< FriendKey of this friend."]
    pub friendKey: FriendKey,
    #[doc = "< NEX timestamp of when this friend was added to the current user's friend list."]
    pub addedTimestamp: s64,
    #[doc = "< The type of the relationship with this friend."]
    pub relationship: u8_,
    pub pad: [u8_; 7usize],
    #[doc = "< Friend profile data of this friend."]
    pub friendProfile: FriendProfile,
    #[doc = "< The screen name of this friend."]
    pub screenName: MiiScreenName,
    #[doc = "< The character set used for the text parts of the data of this friend."]
    pub characterSet: u8_,
    pub pad2: u8_,
    #[doc = "< The Mii of this friend."]
    pub mii: FriendMii,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FriendInfo"][::core::mem::size_of::<FriendInfo>() - 224usize];
    ["Alignment of FriendInfo"][::core::mem::align_of::<FriendInfo>() - 1usize];
    ["Offset of field: FriendInfo::friendKey"]
        [::core::mem::offset_of!(FriendInfo, friendKey) - 0usize];
    ["Offset of field: FriendInfo::addedTimestamp"]
        [::core::mem::offset_of!(FriendInfo, addedTimestamp) - 16usize];
    ["Offset of field: FriendInfo::relationship"]
        [::core::mem::offset_of!(FriendInfo, relationship) - 24usize];
    ["Offset of field: FriendInfo::pad"][::core::mem::offset_of!(FriendInfo, pad) - 25usize];
    ["Offset of field: FriendInfo::friendProfile"]
        [::core::mem::offset_of!(FriendInfo, friendProfile) - 32usize];
    ["Offset of field: FriendInfo::screenName"]
        [::core::mem::offset_of!(FriendInfo, screenName) - 104usize];
    ["Offset of field: FriendInfo::characterSet"]
        [::core::mem::offset_of!(FriendInfo, characterSet) - 126usize];
    ["Offset of field: FriendInfo::pad2"][::core::mem::offset_of!(FriendInfo, pad2) - 127usize];
    ["Offset of field: FriendInfo::mii"][::core::mem::offset_of!(FriendInfo, mii) - 128usize];
};
#[doc = "Friend Notification Event structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NotificationEvent {
    #[doc = "< Type of event."]
    pub type_: u8_,
    pub padding: [u8_; 7usize],
    #[doc = "< Friend key of friend who caused this notification event to be sent."]
    pub sender: FriendKey,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotificationEvent"][::core::mem::size_of::<NotificationEvent>() - 24usize];
    ["Alignment of NotificationEvent"][::core::mem::align_of::<NotificationEvent>() - 1usize];
    ["Offset of field: NotificationEvent::type_"]
        [::core::mem::offset_of!(NotificationEvent, type_) - 0usize];
    ["Offset of field: NotificationEvent::padding"]
        [::core::mem::offset_of!(NotificationEvent, padding) - 1usize];
    ["Offset of field: NotificationEvent::sender"]
        [::core::mem::offset_of!(NotificationEvent, sender) - 8usize];
};
#[doc = "Game Authentication Data structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GameAuthenticationData {
    #[doc = "< NASC result code for the LOGIN operation."]
    pub nascResult: u32_,
    #[doc = "< HTTP status code for the NASC LOGIN operation."]
    pub httpStatusCode: u32_,
    #[doc = "< Address of the game server."]
    pub serverAddress: [::libc::c_char; 32usize],
    #[doc = "< Port of the game server."]
    pub serverPort: u16_,
    pub pad: [u8_; 6usize],
    #[doc = "< Game server authentication token."]
    pub authToken: [::libc::c_char; 256usize],
    #[doc = "< NEX timestamp for current server time."]
    pub serverTime: u64_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GameAuthenticationData"][::core::mem::size_of::<GameAuthenticationData>() - 312usize];
    ["Alignment of GameAuthenticationData"]
        [::core::mem::align_of::<GameAuthenticationData>() - 1usize];
    ["Offset of field: GameAuthenticationData::nascResult"]
        [::core::mem::offset_of!(GameAuthenticationData, nascResult) - 0usize];
    ["Offset of field: GameAuthenticationData::httpStatusCode"]
        [::core::mem::offset_of!(GameAuthenticationData, httpStatusCode) - 4usize];
    ["Offset of field: GameAuthenticationData::serverAddress"]
        [::core::mem::offset_of!(GameAuthenticationData, serverAddress) - 8usize];
    ["Offset of field: GameAuthenticationData::serverPort"]
        [::core::mem::offset_of!(GameAuthenticationData, serverPort) - 40usize];
    ["Offset of field: GameAuthenticationData::pad"]
        [::core::mem::offset_of!(GameAuthenticationData, pad) - 42usize];
    ["Offset of field: GameAuthenticationData::authToken"]
        [::core::mem::offset_of!(GameAuthenticationData, authToken) - 48usize];
    ["Offset of field: GameAuthenticationData::serverTime"]
        [::core::mem::offset_of!(GameAuthenticationData, serverTime) - 304usize];
};
impl Default for GameAuthenticationData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Service Locator Data strcture"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ServiceLocatorData {
    #[doc = "< NASC result code for the SVCLOC operation."]
    pub nascResult: u32_,
    #[doc = "< HTTP status code for the NASC LOGIN operation."]
    pub httpStatusCode: u32_,
    #[doc = "< Host address of the target service."]
    pub serviceHost: [::libc::c_char; 128usize],
    #[doc = "< Token for the target service."]
    pub serviceToken: [::libc::c_char; 256usize],
    #[doc = "< `statusdata` value from the NASC response data."]
    pub statusData: u8_,
    pub padding: [u8_; 7usize],
    #[doc = "< NEX timestamp for current server time."]
    pub serverTime: u64_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ServiceLocatorData"][::core::mem::size_of::<ServiceLocatorData>() - 408usize];
    ["Alignment of ServiceLocatorData"][::core::mem::align_of::<ServiceLocatorData>() - 1usize];
    ["Offset of field: ServiceLocatorData::nascResult"]
        [::core::mem::offset_of!(ServiceLocatorData, nascResult) - 0usize];
    ["Offset of field: ServiceLocatorData::httpStatusCode"]
        [::core::mem::offset_of!(ServiceLocatorData, httpStatusCode) - 4usize];
    ["Offset of field: ServiceLocatorData::serviceHost"]
        [::core::mem::offset_of!(ServiceLocatorData, serviceHost) - 8usize];
    ["Offset of field: ServiceLocatorData::serviceToken"]
        [::core::mem::offset_of!(ServiceLocatorData, serviceToken) - 136usize];
    ["Offset of field: ServiceLocatorData::statusData"]
        [::core::mem::offset_of!(ServiceLocatorData, statusData) - 392usize];
    ["Offset of field: ServiceLocatorData::padding"]
        [::core::mem::offset_of!(ServiceLocatorData, padding) - 393usize];
    ["Offset of field: ServiceLocatorData::serverTime"]
        [::core::mem::offset_of!(ServiceLocatorData, serverTime) - 400usize];
};
impl Default for ServiceLocatorData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Encrypted inner Approach Context structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ApproachContext {
    pub friendProfile: FriendProfile,
    pub hasMii: bool,
    pub profanityFlag: bool,
    pub characterSet: u8_,
    pub wrappedMii: [u8_; 112usize],
    pub screenName: MiiScreenName,
    pub reserved: [u8_; 271usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ApproachContext"][::core::mem::size_of::<ApproachContext>() - 480usize];
    ["Alignment of ApproachContext"][::core::mem::align_of::<ApproachContext>() - 1usize];
    ["Offset of field: ApproachContext::friendProfile"]
        [::core::mem::offset_of!(ApproachContext, friendProfile) - 0usize];
    ["Offset of field: ApproachContext::hasMii"]
        [::core::mem::offset_of!(ApproachContext, hasMii) - 72usize];
    ["Offset of field: ApproachContext::profanityFlag"]
        [::core::mem::offset_of!(ApproachContext, profanityFlag) - 73usize];
    ["Offset of field: ApproachContext::characterSet"]
        [::core::mem::offset_of!(ApproachContext, characterSet) - 74usize];
    ["Offset of field: ApproachContext::wrappedMii"]
        [::core::mem::offset_of!(ApproachContext, wrappedMii) - 75usize];
    ["Offset of field: ApproachContext::screenName"]
        [::core::mem::offset_of!(ApproachContext, screenName) - 187usize];
    ["Offset of field: ApproachContext::reserved"]
        [::core::mem::offset_of!(ApproachContext, reserved) - 209usize];
};
impl Default for ApproachContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Encrypted Approach Context structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EncryptedApproachContext {
    pub unknown0: u8_,
    pub unknown1: u8_,
    pub unknown2: u8_,
    pub unknown3: u8_,
    pub nonce: EncryptedApproachContext__bindgen_ty_1,
    pub encryptedPayload: ApproachContext,
    pub ccmMac: [u8_; 16usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EncryptedApproachContext__bindgen_ty_1 {
    pub principalId: u32_,
    pub friendCode: u64_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EncryptedApproachContext__bindgen_ty_1"]
        [::core::mem::size_of::<EncryptedApproachContext__bindgen_ty_1>() - 12usize];
    ["Alignment of EncryptedApproachContext__bindgen_ty_1"]
        [::core::mem::align_of::<EncryptedApproachContext__bindgen_ty_1>() - 1usize];
    ["Offset of field: EncryptedApproachContext__bindgen_ty_1::principalId"]
        [::core::mem::offset_of!(EncryptedApproachContext__bindgen_ty_1, principalId) - 0usize];
    ["Offset of field: EncryptedApproachContext__bindgen_ty_1::friendCode"]
        [::core::mem::offset_of!(EncryptedApproachContext__bindgen_ty_1, friendCode) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EncryptedApproachContext"]
        [::core::mem::size_of::<EncryptedApproachContext>() - 512usize];
    ["Alignment of EncryptedApproachContext"]
        [::core::mem::align_of::<EncryptedApproachContext>() - 1usize];
    ["Offset of field: EncryptedApproachContext::unknown0"]
        [::core::mem::offset_of!(EncryptedApproachContext, unknown0) - 0usize];
    ["Offset of field: EncryptedApproachContext::unknown1"]
        [::core::mem::offset_of!(EncryptedApproachContext, unknown1) - 1usize];
    ["Offset of field: EncryptedApproachContext::unknown2"]
        [::core::mem::offset_of!(EncryptedApproachContext, unknown2) - 2usize];
    ["Offset of field: EncryptedApproachContext::unknown3"]
        [::core::mem::offset_of!(EncryptedApproachContext, unknown3) - 3usize];
    ["Offset of field: EncryptedApproachContext::nonce"]
        [::core::mem::offset_of!(EncryptedApproachContext, nonce) - 4usize];
    ["Offset of field: EncryptedApproachContext::encryptedPayload"]
        [::core::mem::offset_of!(EncryptedApproachContext, encryptedPayload) - 16usize];
    ["Offset of field: EncryptedApproachContext::ccmMac"]
        [::core::mem::offset_of!(EncryptedApproachContext, ccmMac) - 496usize];
};
impl Default for EncryptedApproachContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Decrypted Approach Context structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DecryptedApproachContext {
    pub unknown0: u8_,
    pub unknown1: u8_,
    pub unknown2: u8_,
    pub unknown3: u8_,
    #[doc = "< Whether or not this friend has a Mii."]
    pub hasMii: bool,
    pub profanityFlag: bool,
    #[doc = "< Character set for text data."]
    pub characterSet: u8_,
    pub pad: u8_,
    #[doc = "< Friend key of this friend."]
    pub friendKey: FriendKey,
    #[doc = "< Friend profile of this friend."]
    pub friendProfile: FriendProfile,
    #[doc = "< Mii data of this friend."]
    pub mii: FriendMii,
    #[doc = "< UTF-16 screen name of this friend."]
    pub screenName: MiiScreenName,
    pub reserved: [u8_; 298usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DecryptedApproachContext"]
        [::core::mem::size_of::<DecryptedApproachContext>() - 512usize];
    ["Alignment of DecryptedApproachContext"]
        [::core::mem::align_of::<DecryptedApproachContext>() - 1usize];
    ["Offset of field: DecryptedApproachContext::unknown0"]
        [::core::mem::offset_of!(DecryptedApproachContext, unknown0) - 0usize];
    ["Offset of field: DecryptedApproachContext::unknown1"]
        [::core::mem::offset_of!(DecryptedApproachContext, unknown1) - 1usize];
    ["Offset of field: DecryptedApproachContext::unknown2"]
        [::core::mem::offset_of!(DecryptedApproachContext, unknown2) - 2usize];
    ["Offset of field: DecryptedApproachContext::unknown3"]
        [::core::mem::offset_of!(DecryptedApproachContext, unknown3) - 3usize];
    ["Offset of field: DecryptedApproachContext::hasMii"]
        [::core::mem::offset_of!(DecryptedApproachContext, hasMii) - 4usize];
    ["Offset of field: DecryptedApproachContext::profanityFlag"]
        [::core::mem::offset_of!(DecryptedApproachContext, profanityFlag) - 5usize];
    ["Offset of field: DecryptedApproachContext::characterSet"]
        [::core::mem::offset_of!(DecryptedApproachContext, characterSet) - 6usize];
    ["Offset of field: DecryptedApproachContext::pad"]
        [::core::mem::offset_of!(DecryptedApproachContext, pad) - 7usize];
    ["Offset of field: DecryptedApproachContext::friendKey"]
        [::core::mem::offset_of!(DecryptedApproachContext, friendKey) - 8usize];
    ["Offset of field: DecryptedApproachContext::friendProfile"]
        [::core::mem::offset_of!(DecryptedApproachContext, friendProfile) - 24usize];
    ["Offset of field: DecryptedApproachContext::mii"]
        [::core::mem::offset_of!(DecryptedApproachContext, mii) - 96usize];
    ["Offset of field: DecryptedApproachContext::screenName"]
        [::core::mem::offset_of!(DecryptedApproachContext, screenName) - 192usize];
    ["Offset of field: DecryptedApproachContext::reserved"]
        [::core::mem::offset_of!(DecryptedApproachContext, reserved) - 214usize];
};
impl Default for DecryptedApproachContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Character set for JPN, USA, and EUR(+AUS)."]
pub const CHARSET_JPN_USA_EUR: CharacterSet = 0;
#[doc = "< Character set for CHN."]
pub const CHARSET_CHN: CharacterSet = 1;
#[doc = "< Character set for KOR."]
pub const CHARSET_KOR: CharacterSet = 2;
#[doc = "< Character set for TWN."]
pub const CHARSET_TWN: CharacterSet = 3;
#[doc = "Enum for character set"]
pub type CharacterSet = ::libc::c_uchar;
pub const NASC_SUCCESS: NASCResult = 1;
pub const NASC_SERVER_UNDER_MAINTENANCE: NASCResult = 101;
pub const NASC_DEVICE_BANNED: NASCResult = 102;
pub const NASC_INVALID_PRODUCT_CODE: NASCResult = 107;
pub const NASC_INVALID_REQUEST_PARAM: NASCResult = 109;
pub const NASC_SERVER_NO_LONGER_AVAILABLE: NASCResult = 110;
pub const NASC_INVALID_SVC: NASCResult = 112;
pub const NASC_INVALID_FPD_VERSION: NASCResult = 119;
pub const NASC_INVALID_TITLE_VERSION: NASCResult = 120;
pub const NASC_INVALID_DEVICE_CERTIFICATE: NASCResult = 121;
pub const NASC_INVALID_PID_HMAC: NASCResult = 122;
pub const NASC_BANNED_ROM_ID: NASCResult = 123;
pub const NASC_INVALID_GAME_ID: NASCResult = 125;
pub const NASC_INVALID_KEY_HASH: NASCResult = 127;
#[doc = "Enum for NASC Result"]
pub type NASCResult = ::libc::c_uchar;
pub const NASC_PRODUCTION: NASCEnvironment = 0;
pub const NASC_TESTING: NASCEnvironment = 1;
pub const NASC_DEVELOPMENT: NASCEnvironment = 2;
#[doc = "Enum for NASC Server Environment"]
pub type NASCEnvironment = ::libc::c_uchar;
#[doc = "< Self went online"]
pub const USER_WENT_ONLINE: FriendNotificationTypes = 1;
#[doc = "< Self went offline"]
pub const USER_WENT_OFFLINE: FriendNotificationTypes = 2;
#[doc = "< Friend Went Online"]
pub const FRIEND_WENT_ONLINE: FriendNotificationTypes = 3;
#[doc = "< Friend Presence changed (with matching GameJoinID)"]
pub const FRIEND_UPDATED_PRESENCE: FriendNotificationTypes = 4;
#[doc = "< Friend Mii changed"]
pub const FRIEND_UPDATED_MII: FriendNotificationTypes = 5;
#[doc = "< Friend Profile changed"]
pub const FRIEND_UPDATED_PROFILE: FriendNotificationTypes = 6;
#[doc = "< Friend went offline"]
pub const FRIEND_WENT_OFFLINE: FriendNotificationTypes = 7;
#[doc = "< Friend registered self as friend"]
pub const FRIEND_REGISTERED_USER: FriendNotificationTypes = 8;
#[doc = "< Friend sent invitation (with matching GameJoinID)"]
pub const FRIEND_SENT_JOINABLE_INVITATION: FriendNotificationTypes = 9;
#[doc = "< Friend changed game mode description"]
pub const FRIEND_CHANGED_GAME_MODE_DESCRIPTION: FriendNotificationTypes = 145;
#[doc = "< Friend changed favorite game"]
pub const FRIEND_CHANGED_FAVORITE_GAME: FriendNotificationTypes = 146;
#[doc = "< Friend changed comment"]
pub const FRIEND_CHANGED_COMMENT: FriendNotificationTypes = 147;
#[doc = "< Friend Presence changed (with nonmatching GameJoinID)"]
pub const FRIEND_CHANGED_ANY_PRESENCE: FriendNotificationTypes = 148;
#[doc = "< Friend sent invitiation (with nonmatching GameJoinID)"]
pub const FRIEND_SENT_ANY_INVITATION: FriendNotificationTypes = 149;
#[doc = "Enum for notification event types"]
pub type FriendNotificationTypes = ::libc::c_uchar;
pub const MASK_USER_WENT_ONLINE: FriendNotificationMask = 1;
pub const MASK_USER_WENT_OFFLINE: FriendNotificationMask = 2;
pub const MASK_FRIEND_WENT_ONLINE: FriendNotificationMask = 4;
pub const MASK_FRIEND_UPDATED_PRESENCE: FriendNotificationMask = 8;
pub const MASK_FRIEND_UPDATED_MII: FriendNotificationMask = 16;
pub const MASK_FRIEND_UPDATED_PROFILE: FriendNotificationMask = 32;
pub const MASK_FRIEND_WENT_OFFLINE: FriendNotificationMask = 64;
pub const MASK_FRIEND_REGISTERED_USER: FriendNotificationMask = 128;
pub const MASK_FRIEND_SENT_JOINABLE_INVITATION: FriendNotificationMask = 256;
#[doc = "Enum for notification event mask"]
pub type FriendNotificationMask = ::libc::c_ushort;
#[doc = "< Provisionally registered friend."]
pub const RELATIONSHIP_INCOMPLETE: RelationshipType = 0;
#[doc = "< Fully registered friend."]
pub const RELATIONSHIP_COMPLETE: RelationshipType = 1;
#[doc = "< Friend not registered at all."]
pub const RELATIONSHIP_NOT_FOUND: RelationshipType = 2;
#[doc = "< Relationship was deleted."]
pub const RELATIONSHIP_DELETED: RelationshipType = 3;
#[doc = "< Provisionally registered friend (but this relationship has not been sent to the server yet)."]
pub const RELATIONSHIP_LOCAL: RelationshipType = 4;
#[doc = "Enum for friend relationship type"]
pub type RelationshipType = ::libc::c_uchar;
#[doc = "< Whether or not the current user has ever been in a friend relationship with the friend. This is set when the relationship type is either incomplete, complete, local, or deleted."]
pub const FRIEND_ATTRIBUTE_EVER_REGISTERED: FriendAttributes = 1;
#[doc = "< Whether or not the current user has been fully registered by this friend. Set only when the relationship type is complete."]
pub const FRIEND_ATTRIBUTE_REGISTRATION_COMPLETE: FriendAttributes = 2;
#[doc = "Enum for friend attributes according to relationship type"]
pub type FriendAttributes = ::libc::c_uchar;
pub const NAT_MAPPING_UNKNOWN: NatMappingType = 0;
pub const NAT_MAPPING_ENDPOINT_INDEPENDENT: NatMappingType = 1;
pub const NAT_MAPPING_ENDPOINT_DEPENDENT: NatMappingType = 2;
#[doc = "Enum for NAT mapping type"]
pub type NatMappingType = ::libc::c_uchar;
pub const NAT_FILTERING_UNKNOWN: NatFilteringType = 0;
pub const NAT_FILTERING_PORT_INDEPENDENT: NatFilteringType = 1;
pub const NAT_FILTERING_PORT_DEPENDENT: NatFilteringType = 2;
#[doc = "Enum for NAT filtering type"]
pub type NatFilteringType = ::libc::c_uchar;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes friend services.\n # Arguments\n\n* `forceUser` - Whether or not to force using the user service frd:u instead of the default (admin service frd:a)."]
    pub fn frdInit(forceUser: bool) -> Result;
}
unsafe extern "C" {
    #[doc = "Exits friend services."]
    pub fn frdExit();
}
unsafe extern "C" {
    #[doc = "Get the friend user/admin service handle."]
    pub fn frdGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the login status of the current user.\n # Arguments\n\n* `state` - Pointer to write the current user's login status to."]
    pub fn FRD_HasLoggedIn(state: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the online status of the current user.\n # Arguments\n\n* `state` - Pointer to write the current user's online status to."]
    pub fn FRD_IsOnline(state: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Log in to Nintendo's friend server.\n # Arguments\n\n* `event` - Event to signal when Login is done."]
    pub fn FRD_Login(event: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Logs out of Nintendo's friend server."]
    pub fn FRD_Logout() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current user's friend key.\n # Arguments\n\n* `key` - Pointer to write the current user's friend key to."]
    pub fn FRD_GetMyFriendKey(key: *mut FriendKey) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current user's privacy information.\n # Arguments\n\n* `isPublicMode` - Determines whether friends are notified of the current user's online status.\n * `isShowGameName` - Determines whether friends are notified of the application that the current user is running.\n * `isShowPlayedGame` - Determiens whether to display the current user's game history."]
    pub fn FRD_GetMyPreference(
        isPublicMode: *mut bool,
        isShowGameName: *mut bool,
        isShowPlayedGame: *mut bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current user's profile information.\n # Arguments\n\n* `profile` - Pointer to write the current user's profile information to."]
    pub fn FRD_GetMyProfile(profile: *mut Profile) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current user's presence information.\n # Arguments\n\n* `presence` - Pointer to write the current user's presence information to."]
    pub fn FRD_GetMyPresence(presence: *mut MyPresence) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current user's screen name.\n # Arguments\n\n* `name` - Pointer to write the current user's screen name to.\n * `max_size` - Max size of the screen name."]
    pub fn FRD_GetMyScreenName(name: *mut MiiScreenName) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current user's Mii data.\n # Arguments\n\n* `mii` - Pointer to write the current user's mii data to."]
    pub fn FRD_GetMyMii(mii: *mut FriendMii) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the ID of the current local account.\n # Arguments\n\n* `localAccountId` - Pointer to write the current local account ID to."]
    pub fn FRD_GetMyLocalAccountId(localAccountId: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current user's playing game.\n # Arguments\n\n* `titleId` - Pointer to write the current user's playing game to."]
    pub fn FRD_GetMyPlayingGame(playingGame: *mut GameKey) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current user's favourite game.\n # Arguments\n\n* `titleId` - Pointer to write the title ID of current user's favourite game to."]
    pub fn FRD_GetMyFavoriteGame(favoriteGame: *mut GameKey) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the NcPrincipalId for the current user.\n # Arguments\n\n* `ncPrincipalId` - Pointer to output the NcPrincipalId to."]
    pub fn FRD_GetMyNcPrincipalId(ncPrincipalId: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current user's comment on their friend profile.\n # Arguments\n\n* `comment` - Pointer to write the current user's comment to.\n * `max_size` - Max size of the comment."]
    pub fn FRD_GetMyComment(comment: *mut FriendComment) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current friend account's NEX password.\n # Arguments\n\n* `password` - Pointer to write the NEX password to.\n * `max_size` - Max size of the output buffer. Must not exceed 0x800."]
    pub fn FRD_GetMyPassword(password: *mut ::libc::c_char, bufsize: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current user's friend key list.\n # Arguments\n\n* `friendKeyList` - Pointer to write the friend key list to.\n * `num` - Stores the number of friend keys obtained.\n * `offset` - The index of the friend key to start with.\n * `size` - Size of the friend key list. (FRIEND_LIST_SIZE)"]
    pub fn FRD_GetFriendKeyList(
        friendKeyList: *mut FriendKey,
        num: *mut u32_,
        offset: u32_,
        size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets friend presence data for the current user's friends.\n # Arguments\n\n* `friendPresences` - Pointer to write the friend presence data to.\n * `friendKeyList` - The friend keys of the friends to get presence data for.\n * `count` - The number of input friend keys."]
    pub fn FRD_GetFriendPresence(
        friendPresences: *mut FriendPresence,
        friendKeyList: *const FriendKey,
        count: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets screen names for the current user's friends.\n # Arguments\n\n* `screenNames` - Pointer to write the UTF-16 screen names to.\n * `screenNamesLen` - Number of UTF-16 characters `screenNames` can hold. (max: 0x800)\n * `characterSets` - Pointer to write the character sets for the screen names to.\n * `characterSetsLen` - Size of buffer to output character sets to.\n * `friendKeyList` - The friend keys for the friends to get screen names for.\n * `count` - The number of input friend keys.\n * `maskNonAscii` - Whether or not to replace all non-ASCII characters with question marks ('?') if the given character set doesn't match that of the corresponding friend's Mii data.\n * `profanityFlag` - Setting this to true replaces the screen names with all question marks ('?') if profanityFlag is also set in the corresponding friend's Mii data."]
    pub fn FRD_GetMiiScreenName(
        screenNames: *mut MiiScreenName,
        screenNamesLen: u32_,
        characterSets: *mut u8_,
        characterSetsLen: u32_,
        friendKeyList: *const FriendKey,
        count: u32_,
        maskNonAscii: bool,
        profanityFlag: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current user's friends' Mii data.\n # Arguments\n\n* `miiList` - Pointer to write Mii data to.\n * `friendKeyList` - Pointer to input friend keys.\n * `count` - Number of input friend keys."]
    pub fn FRD_GetFriendMii(
        miiList: *mut FriendMii,
        friendKeyList: *const FriendKey,
        count: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Get the current user's friends' profile data.\n # Arguments\n\n* `profile` - Pointer to write profile data to.\n * `friendKeyList` - Pointer to input friend keys.\n * `count` - Number of input friend keys."]
    pub fn FRD_GetFriendProfile(
        profiles: *mut Profile,
        friendKeyList: *const FriendKey,
        count: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Get the relationship type for the current user's friends.\n # Arguments\n\n* `relationships` - Pointer to output relationship types to.\n * `friendKeyList` - Pointer to input friend keys to query relationship types for.\n * `count` - Number of input friend keys."]
    pub fn FRD_GetFriendRelationship(
        relationships: *mut u8_,
        friendKeyList: *const FriendKey,
        count: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Get attributes for the current user's friends.\n # Arguments\n\n* `attributes` - Pointer to output the attributes to.\n * `friendKeyList` - Pointer to input friend keys to query attributes for.\n * `count` - Number of input friend keys."]
    pub fn FRD_GetFriendAttributeFlags(
        attributes: *mut u32_,
        friendKeyList: *const FriendKey,
        count: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Get the current user's friends' playing game.\n # Arguments\n\n* `playingGames` - Pointer to write playing game data to.\n * `friendKeyList` - Pointer to friend keys.\n * `count` - Number of input friend keys."]
    pub fn FRD_GetFriendPlayingGame(
        playingGames: *mut FriendPlayingGame,
        friendKeyList: *const FriendKey,
        count: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Get the current user's friends' favourite games.\n # Arguments\n\n* `favoriteGames` - Pointer to write game key data to.\n * `friendKeyList` - Pointer to friend keys.\n * `count` - Number of friend keys."]
    pub fn FRD_GetFriendFavoriteGame(
        favoriteGames: *mut GameKey,
        friendKeyList: *const FriendKey,
        count: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Get info about the current user's friends.\n # Arguments\n\n* `infos` - Pointer to output friend info data to.\n * `friendKeyList` - Pointer to input friend keys.\n * `count` - Number of input friend keys.\n * `maskNonAscii` - Whether or not to replace all non-ASCII characters with question marks ('?') if the given character set doesn't match that of the corresponding friend's Mii data.\n * `profanityFlag` - Setting this to true replaces the screen names with all question marks ('?') if profanityFlag is also set in the corresponding friend's Mii data."]
    pub fn FRD_GetFriendInfo(
        infos: *mut FriendInfo,
        friendKeyList: *const FriendKey,
        count: u32_,
        maskNonAscii: bool,
        profanityFlag: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether a friend code is included in the current user's friend list.\n # Arguments\n\n* `friendCode` - The friend code to check for.\n * `isFromList` - Pointer to write whether or not the given friend code was found in the current user's friends list."]
    pub fn FRD_IsInFriendList(friendCode: u64_, isFromList: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unscrambles a scrambled friend code.\n # Arguments\n\n* `unscrambled` - Pointer to output the unscrambled friend codes to.\n * `scrambled` - Pointer to the input scrambled friend codes.\n * `count` - Number of input scrambled codes."]
    pub fn FRD_UnscrambleLocalFriendCode(
        unscrambled: *mut u64_,
        scrambled: *mut ScrambledFriendCode,
        count: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates the game mode description string.\n # Arguments\n\n* `desc` - Pointer to the UTF-8 game mode description to use."]
    pub fn FRD_UpdateGameModeDescription(desc: *mut FriendGameModeDescription) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates the current user's presence data and game mode description.\n # Arguments\n\n* `presence` - The new presence data to use.\n * `desc` - The new game mode description to use."]
    pub fn FRD_UpdateMyPresence(
        presence: *mut Presence,
        desc: *mut FriendGameModeDescription,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sends an invitation to the current user's friends.\n # Arguments\n\n* `friendKeyList` - The friend keys to send an invitation to.\n * `count` - The number of input friend keys."]
    pub fn FRD_SendInvitation(friendKeyList: *const FriendKey, count: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Registers the event handle that will be signaled to inform the session of various status changes.\n # Arguments\n\n* `event` - The event handle to register for notification signaling."]
    pub fn FRD_AttachToEventNotification(event: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the notification mask for the event notification system.\n # Arguments\n\n* `mask` - The notifications to subscribe to for the event notification system."]
    pub fn FRD_SetNotificationMask(mask: FriendNotificationMask) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Get Latest Event Notification\n # Arguments\n\n* `event` - Pointer to write recieved notification event struct to.\n * `count` - Number of events\n * `recievedNotifCount` - Number of notification reccieved."]
    pub fn FRD_GetEventNotification(
        event: *mut NotificationEvent,
        count: u32_,
        recievedNotifCount: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Get the result of the last internal operation."]
    pub fn FRD_GetLastResponseResult() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns the friend code using the given principal ID.\n # Arguments\n\n* `principalId` - The principal ID being used.\n * `friendCode` - Pointer to write the friend code to."]
    pub fn FRD_PrincipalIdToFriendCode(principalId: u32_, friendCode: *mut u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns the principal ID using the given friend code.\n # Arguments\n\n* `friendCode` - The friend code being used.\n * `principalId` - Pointer to write the principal ID to."]
    pub fn FRD_FriendCodeToPrincipalId(friendCode: u64_, principalId: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if the friend code is valid.\n # Arguments\n\n* `friendCode` - The friend code being used.\n * `isValid` - Pointer to write the validity of the friend code to."]
    pub fn FRD_IsValidFriendCode(friendCode: u64_, isValid: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Get a support error code (XXX-YYYY) for the given result code.\n # Arguments\n\n* `errorCode` - Pointer to write the support error code to.\n * `res` - The result code to convert."]
    pub fn FRD_ResultToErrorCode(errorCode: *mut u32_, res: Result) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Requests game server authentication.\n # Arguments\n\n* `serverId` - The ID of the NEX server to request authentication for.\n * `ingamesn` - The UTF-16 nickname to use in game.\n * `ingamesnSize` - Buffer size of the input ingamesn buffer. (max: FRIEND_INGAMESN_LEN * 2)\n * `majorSdkVersion` - The major SDK version.\n * `minorSdkVersion` - The minor SDK version.\n * `completionEvent` - The event handle to signal once the operation has completed."]
    pub fn FRD_RequestGameAuthentication(
        serverId: u32_,
        ingamesn: *mut u16_,
        ingamesnSize: u32_,
        majorSdkVersion: u8_,
        minorSdkVersion: u8_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Get game server authentication data requested using FRD_RequestGameAuthentication.\n # Arguments\n\n* `data` - Pointer to write game server authentication data to."]
    pub fn FRD_GetGameAuthenticationData(data: *mut GameAuthenticationData) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Request service locator info for a given NEX server.\n # Arguments\n\n* `keyhash` - The `keyhash` value to use for the NASC request.\n * `svc` - The svc `value` to use for the NASC request.\n * `majorSdkVersion` - The major SDK version.\n * `minorSdkVersion` - The minor SDK version.\n * `completionEvent` - The event handle to signal once the operation has completed.\n * `serverId` -"]
    pub fn FRD_RequestServiceLocator(
        serverId: u32_,
        keyhash: *mut ::libc::c_char,
        svc: *mut ::libc::c_char,
        majorSdkVersion: u8_,
        minorSdkVersion: u8_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Get service locator data requested using FRD_RequestServiceLocator.\n # Arguments\n\n* `data` - Pointer to write the service locator data to."]
    pub fn FRD_GetServiceLocatorData(data: *mut ServiceLocatorData) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Starts an internal task to determine the NAT properties of the current internet connection.\n # Arguments\n\n* `completionEvent` - The event handle to signal once the task has completed."]
    pub fn FRD_DetectNatProperties(completionEvent: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns NAT properties for the current internet connection.\n # Arguments\n\n* `natMappingType` - Pointer to write the NAT mapping type of the connection to.\n * `natFilteringType` - Pointer to write the NAT filtering type of the connection to."]
    pub fn FRD_GetNatProperties(natMappingType: *mut u32_, natFilteringType: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns the difference (in nanoseconds) between server time and device time. This difference is calculated every time the system logs into friend services.\n # Arguments\n\n* `diffMs` - The pointer to write the time difference (in nanoseconds) to."]
    pub fn FRD_GetServerTimeDifference(diff: *mut u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures the current session to allow or disallow running the friends service in sleep mode (half-awake mode).\n # Arguments\n\n* `allow` - Whether or not to enable half-awake mode."]
    pub fn FRD_AllowHalfAwake(allow: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the server environment configuration for the current user.\n # Arguments\n\n* `nascEnvironment` - Pointer to write the NASC server environment type to.\n * `nfsType` - Pointer to write the NFS (Nintendo Friend Server) type to.\n * `nfsNo` - Pointer to write the NFS (Nintendo Friend Server) number to."]
    pub fn FRD_GetServerTypes(
        nascEnvironment: *mut u8_,
        nfsType: *mut u8_,
        nfsNo: *mut u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the comment (personal) message of the current user's friends.\n # Arguments\n\n* `comments` - Pointer to write the friend comment data to.\n * `commentsLen` - Number of UTF-16 characters `screenNames` can hold. (max: 0xC00)\n * `friendKeyList` - Pointer to input friend keys.\n * `count` - Number of input friend keys."]
    pub fn FRD_GetFriendComment(
        comments: *mut FriendComment,
        commentsLen: u32_,
        friendKeyList: *const FriendKey,
        count: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the Friend API to use a specific SDK version.\n # Arguments\n\n* `sdkVer` - The SDK version needed to be used."]
    pub fn FRD_SetClientSdkVersion(sdkVer: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current user's encrypted approach context.\n # Arguments\n\n* `ctx` - Pointer to write the encrypted approach context data to."]
    pub fn FRD_GetMyApproachContext(ctx: *mut EncryptedApproachContext) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a friend using their encrypted approach context.\n # Arguments\n\n* `unkbuf` - Pointer to unknown (and unused) data.\n * `unkbufSize` - Size of unknown (and unused) data. (max: 0x600)\n * `ctx` - Pointer to encrypted approach context data.\n * `completionEvent` - The event handle to signal when this action is completed."]
    pub fn FRD_AddFriendWithApproach(
        unkbuf: *mut u8_,
        unkbufSize: u32_,
        ctx: *mut EncryptedApproachContext,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Decrypts an encrypted approach context.\n # Arguments\n\n* `decryptedContext` - Pointer to write the decrypted approach context data to.\n * `encryptedContext` - Pointer to input encrypted approach context.\n * `maskNonAscii` - Whether or not to replace all non-ASCII characters with question marks ('?') if the given character set doesn't match that of the corresponding friend's Mii data.\n * `characterSet` - The character set to use for text conversions."]
    pub fn FRD_DecryptApproachContext(
        decryptedContext: *mut DecryptedApproachContext,
        encryptedContext: *mut EncryptedApproachContext,
        maskNonAscii: bool,
        characterSet: u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets extended NAT properties. This is the same as FRD_GetNatProperties, with this version also returning the NAT Mapping Port Increment.\n # Arguments\n\n* `natMappingType` - Pointer to write the NAT mapping type of the connection to.\n * `natFilteringType` - Pointer to write the NAT filtering type of the connection to.\n * `natMappingPortIncrement` - Pointer to write the NAT mapping port increment to."]
    pub fn FRD_GetExtendedNatProperties(
        natMappingType: *mut u32_,
        natFilteringType: *mut u32_,
        natMappingPortIncrement: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a new local friends account.\n # Arguments\n\n* `localAccountId` - The local account ID to use.\n * `nascEnvironment` - The NASC environment to create this account in.\n * `nfsType` - The NFS (Nintendo Friend Server) type this account should use.\n * `nfsNo` - The NFS (Nintendo Friend Server) number this account should use."]
    pub fn FRDA_CreateLocalAccount(
        localAccountId: u8_,
        nascEnvironment: u8_,
        nfsType: u8_,
        nfsNo: u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes a local friends account.\n # Arguments\n\n* `localAccountId` - The ID of the local account to delete."]
    pub fn FRDA_DeleteLocalAccount(localAccountId: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Loads a local friends account.\n # Arguments\n\n* `localAccountId` - The ID of the local account to load."]
    pub fn FRDA_LoadLocalAccount(localAccountId: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unloads the currently active local account."]
    pub fn FRDA_UnloadLocalAccount() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Saves all data of the friends module."]
    pub fn FRDA_Save() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a friend online (\"Internet\" option).\n # Arguments\n\n* `event` - Event signaled when friend is registered.\n * `principalId` - PrincipalId of the friend to add."]
    pub fn FRDA_AddFriendOnline(event: Handle, principalId: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a friend offline (\"Local\" option).\n # Arguments\n\n* `friendKey` - Pointer to the friend key of the friend to add.\n * `mii` - Pointer to the Mii of the friend to add.\n * `friendProfile` - Pointer to the friend profile of the friend to add.\n * `screenName` - Pointer to the UTF-16 screen name of the friend to add.\n * `profanityFlag` - Setting this to true will cause calls that return the screen name to replace it with question marks ('?') when profanityFlag is true in those calls.\n * `characterSet` - The character set to use for text data of the friend."]
    pub fn FRDA_AddFriendOffline(
        friendKey: *mut FriendKey,
        mii: *mut FriendMii,
        friendProfile: *mut FriendProfile,
        screenName: *mut MiiScreenName,
        profanityFlag: bool,
        characterSet: u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates a friend's display name.\n # Arguments\n\n* `friendKey` - Pointer to friend key of the friend to update the screen name of.\n * `screenName` - Pointer to the new screen name to use.\n * `characterSet` - The character set of the new screen name."]
    pub fn FRDA_UpdateMiiScreenName(
        friendKey: *mut FriendKey,
        screenName: *mut MiiScreenName,
        characterSet: u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Remove a friend.\n # Arguments\n\n* `principalId` - PrinipalId of the friend code to remove.\n * `localFriendCode` - LocalFriendCode of the friend code to remove."]
    pub fn FRDA_RemoveFriend(principalId: u32_, localFriendCode: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates the game being played by the current user.\n # Arguments\n\n* `playingGame` - Pointer to game key of the game being played."]
    pub fn FRDA_UpdatePlayingGame(playingGame: *mut GameKey) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates the current user's friend list preferences.\n # Arguments\n\n* `isPublicMode` - Whether or not the online status should be public.\n * `isShowGameMode` - Whether or not the currently played game is shown.\n * `isShowPlayedMode` - Whether or not the play history is shown."]
    pub fn FRDA_UpdatePreference(
        isPublicMode: bool,
        isShowGameMode: bool,
        isShowPlayedMode: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates the current user's Mii.\n # Arguments\n\n* `mii` - Pointer to the new Mii data to use.\n * `screenName` - Pointer to new screen name associated with the new Mii.\n * `profanityFlag` - Setting this to true will cause calls that return the screen name to replace it with question marks ('?') when profanityFlag is true in those calls.\n * `characterSet` - The character set to use for the screen name."]
    pub fn FRDA_UpdateMii(
        mii: *mut FriendMii,
        screenName: *mut MiiScreenName,
        profanityFlag: bool,
        characterSet: u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates the current user's favorite game.\n # Arguments\n\n* `favoriteGame` - Pointer to the game key of the new favorite game."]
    pub fn FRDA_UpdateFavoriteGame(favoriteGame: *mut GameKey) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the NcPrincipalId of the current user.\n # Arguments\n\n* `ncPrincipalId` - The new NcPrincipalId."]
    pub fn FRDA_SetNcPrincipalId(ncPrincipalId: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates the current user's comment (personal message).\n # Arguments\n\n* `comment` - Pointer to the new comment (personal message)."]
    pub fn FRDA_UpdateComment(comment: *mut FriendComment) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Increments the move count in the current local account's save data."]
    pub fn FRDA_IncrementMoveCount() -> Result;
}
pub type ActUuid = [u8_; 16usize];
pub type ActNnasSubdomain = [::libc::c_char; 33usize];
pub type AccountId = [::libc::c_char; 17usize];
pub type AccountPassword = [::libc::c_char; 18usize];
pub type AccountMailAddress = [::libc::c_char; 257usize];
#[doc = "< u8"]
pub const INFO_TYPE_COMMON_NUM_ACCOUNTS: ACT_InfoType = 1;
#[doc = "< u8"]
pub const INFO_TYPE_COMMON_CURRENT_ACCOUNT_SLOT: ACT_InfoType = 2;
#[doc = "< u8"]
pub const INFO_TYPE_COMMON_DEFAULT_ACCOUNT_SLOT: ACT_InfoType = 3;
#[doc = "< s64, difference between server time and device time in nanoseconds."]
pub const INFO_TYPE_COMMON_NETWORK_TIME_DIFF: ACT_InfoType = 4;
#[doc = "< u32"]
pub const INFO_TYPE_PERSISTENT_ID: ACT_InfoType = 5;
#[doc = "< u64"]
pub const INFO_TYPE_COMMON_TRANSFERABLE_ID_BASE: ACT_InfoType = 6;
#[doc = "< u64"]
pub const INFO_TYPE_TRANSFERABLE_ID_BASE: ACT_InfoType = 6;
#[doc = "< CFLStoreData"]
pub const INFO_TYPE_MII: ACT_InfoType = 7;
#[doc = "< AccountId"]
pub const INFO_TYPE_ACCOUNT_ID: ACT_InfoType = 8;
#[doc = "< AccountMailAddress"]
pub const INFO_TYPE_MAIL_ADDRESS: ACT_InfoType = 9;
#[doc = "< BirthDate structure"]
pub const INFO_TYPE_BIRTH_DATE: ACT_InfoType = 10;
#[doc = "< char[2+1]"]
pub const INFO_TYPE_COUNTRY_NAME: ACT_InfoType = 11;
#[doc = "< u32"]
pub const INFO_TYPE_PRINCIPAL_ID: ACT_InfoType = 12;
pub const INFO_TYPE_STUB_0xD: ACT_InfoType = 13;
#[doc = "< bool"]
pub const INFO_TYPE_IS_PASSWORD_CACHE_ENABLED: ACT_InfoType = 14;
pub const INFO_TYPE_STUB_0xF: ACT_InfoType = 15;
pub const INFO_TYPE_STUB_0x10: ACT_InfoType = 16;
#[doc = "< AccountInfo structure"]
pub const INFO_TYPE_ACCOUNT_INFO: ACT_InfoType = 17;
pub const INFO_TYPE_ACCOUNT_SERVER_TYPES: ACT_InfoType = 18;
#[doc = "< u8, F = 0, M = 1"]
pub const INFO_TYPE_GENDER: ACT_InfoType = 19;
#[doc = "< Result"]
pub const INFO_TYPE_LAST_AUTHENTICATION_RESULT: ACT_InfoType = 20;
#[doc = "< AccountId"]
pub const INFO_TYPE_ASSIGNED_ACCOUNT_ID: ACT_InfoType = 21;
#[doc = "< u8"]
pub const INFO_TYPE_PARENTAL_CONTROL_SLOT_NUMBER: ACT_InfoType = 22;
#[doc = "< u32"]
pub const INFO_TYPE_SIMPLE_ADDRESS_ID: ACT_InfoType = 23;
pub const INFO_TYPE_STUB_0x18: ACT_InfoType = 24;
#[doc = "< s64"]
pub const INFO_TYPE_UTC_OFFSET: ACT_InfoType = 25;
#[doc = "< bool"]
pub const INFO_TYPE_IS_COMMITTED: ACT_InfoType = 26;
#[doc = "< MiiScreenName"]
pub const INFO_TYPE_MII_NAME: ACT_InfoType = 27;
#[doc = "< char[0x10+1]"]
pub const INFO_TYPE_NFS_PASSWORD: ACT_InfoType = 28;
#[doc = "< bool"]
pub const INFO_TYPE_HAS_ECI_VIRTUAL_ACCOUNT: ACT_InfoType = 29;
#[doc = "< char[0x40+1]"]
pub const INFO_TYPE_TIMEZONE_ID: ACT_InfoType = 30;
#[doc = "< bool"]
pub const INFO_TYPE_IS_MII_UPDATED: ACT_InfoType = 31;
#[doc = "< bool"]
pub const INFO_TYPE_IS_MAIL_ADDRESS_VALIDATED: ACT_InfoType = 32;
#[doc = "< AccountAccessToken structure"]
pub const INFO_TYPE_ACCOUNT_ACCESS_TOKEN: ACT_InfoType = 33;
#[doc = "< bool"]
pub const INFO_TYPE_COMMON_IS_APPLICATION_UPDATE_REQUIRED: ACT_InfoType = 34;
#[doc = "< AccountServerTypes"]
pub const INFO_TYPE_COMMON_DEFAULT_ACCOUNT_SERVER_TYPES: ACT_InfoType = 35;
#[doc = "< bool"]
pub const INFO_TYPE_IS_SERVER_ACCOUNT_DELETED: ACT_InfoType = 36;
#[doc = "< char[0x100+1]"]
pub const INFO_TYPE_MII_IMAGE_URL: ACT_InfoType = 37;
#[doc = "< u32"]
pub const INFO_TYPE_ASSIGNED_PRINCIPAL_ID: ACT_InfoType = 38;
#[doc = "< u32, AccountAccessTokenState enum"]
pub const INFO_TYPE_ACCOUNT_ACCESS_TOKEN_STATE: ACT_InfoType = 39;
#[doc = "< AccountServerTypesStr structure"]
pub const INFO_TYPE_ACCOUNT_SERVER_ENVIRONMENT: ACT_InfoType = 40;
#[doc = "< AccountServerTypesStr structure"]
pub const INFO_TYPE_COMMON_DEFAULT_ACCOUNT_SERVER_ENVIRONMENT: ACT_InfoType = 41;
#[doc = "< u8[8]"]
pub const INFO_TYPE_COMMON_DEVICE_HASH: ACT_InfoType = 42;
#[doc = "< u8"]
pub const INFO_TYPE_FP_LOCAL_ACCOUNT_ID: ACT_InfoType = 43;
#[doc = "< u16"]
pub const INFO_TYPE_AGE: ACT_InfoType = 44;
#[doc = "< bool"]
pub const INFO_TYPE_IS_ENABLED_RECEIVE_ADS: ACT_InfoType = 45;
#[doc = "< bool"]
pub const INFO_TYPE_IS_OFF_DEVICE_ENABLED: ACT_InfoType = 46;
#[doc = "< u32"]
pub const INFO_TYPE_TRANSLATED_SIMPLE_ADDRESS_ID: ACT_InfoType = 47;
#[doc = "Enum for common / account specific info types"]
pub type ACT_InfoType = ::libc::c_uchar;
#[doc = "< ExistentServerAccountData struct"]
pub const REQUEST_INQUIRE_BINDING_TO_EXISTENT_SERVER_ACCOUNT: ACT_AsyncRequestType = 1;
#[doc = "< u32, parentalConsentApprovalId"]
pub const REQUEST_BIND_TO_EXISTENT_SERVER_ACCOUNT: ACT_AsyncRequestType = 2;
#[doc = "< EulaList structure (dynamically sized)"]
pub const REQUEST_ACQUIRE_EULA: ACT_AsyncRequestType = 3;
#[doc = "< EulaList structure (dynamically sized)"]
pub const REQUEST_ACQUIRE_EULA_LIST: ACT_AsyncRequestType = 3;
#[doc = "< EulaList structure with only the languageNameOffsets populated (dynamically sized)"]
pub const REQUEST_ACQUIRE_EULA_LANGUAGE_LIST: ACT_AsyncRequestType = 3;
#[doc = "< TimezoneList structure"]
pub const REQUEST_ACQUIRE_TIMEZONE_LIST: ACT_AsyncRequestType = 4;
#[doc = "< INFO_TYPE_MAIL_ADDRESS: AccountMailAddress"]
pub const REQUEST_ACQUIRE_ACCOUNT_INFO: ACT_AsyncRequestType = 5;
#[doc = "< AccountId[count]"]
pub const REQUEST_ACQUIRE_ACCOUNT_ID_BY_PRINCIPAL_ID_MULTI: ACT_AsyncRequestType = 6;
#[doc = "< AccountId"]
pub const REQUEST_ACQUIRE_ACCOUNT_ID_BY_PRINCIPAL_ID: ACT_AsyncRequestType = 7;
#[doc = "< u32[count]"]
pub const REQUEST_ACQUIRE_PRINCIPAL_ID_BY_ACCOUNT_ID_MULTI: ACT_AsyncRequestType = 8;
#[doc = "< u32"]
pub const REQUEST_ACQUIRE_PRINCIPAL_ID_BY_ACCOUNT_ID: ACT_AsyncRequestType = 9;
#[doc = "< u32, approvalId"]
pub const REQUEST_APPROVE_BY_CREDIT_CARD: ACT_AsyncRequestType = 10;
#[doc = "< CoppaCodeMailData structure"]
pub const REQUEST_SEND_COPPA_CODE_MAIL: ACT_AsyncRequestType = 11;
#[doc = "< CFLStoreData[count]"]
pub const REQUEST_ACQUIRE_MII: ACT_AsyncRequestType = 12;
#[doc = "< char[0xC00+1], NULL-terminate ASCII raw profile XML data"]
pub const REQUEST_ACQUIRE_ACCOUNT_INFO_RAW: ACT_AsyncRequestType = 13;
pub type ACT_AsyncRequestType = ::libc::c_uchar;
#[doc = "< The user's primary Mii image."]
pub const MII_IMAGE_PRIMARY: MiiImageType = 0;
pub const MII_IMAGE_1: MiiImageType = 1;
pub const MII_IMAGE_2: MiiImageType = 2;
pub const MII_IMAGE_3: MiiImageType = 3;
pub const MII_IMAGE_4: MiiImageType = 4;
pub const MII_IMAGE_5: MiiImageType = 5;
pub const MII_IMAGE_6: MiiImageType = 6;
pub const MII_IMAGE_7: MiiImageType = 7;
pub const MII_IMAGE_8: MiiImageType = 8;
#[doc = "Enum for Mii image type"]
pub type MiiImageType = ::libc::c_uchar;
pub const NNAS_PRODUCTION: NnasServerType = 0;
pub const NNAS_GAME_DEVELOPMENT: NnasServerType = 1;
pub const NNAS_SYSTEM_DEVELOPMENT: NnasServerType = 2;
pub const NNAS_LIBRARY_DEVELOPMENT: NnasServerType = 3;
pub const NNAS_STAGING: NnasServerType = 4;
#[doc = "Enum for NNAS (Nintendo Network Authentication Server) type"]
pub type NnasServerType = ::libc::c_uchar;
pub const ACCESS_TOKEN_UNINITIALIZED: AccountAccessTokenState = 0;
pub const ACCESS_TOKEN_EXPIRED: AccountAccessTokenState = 1;
pub const ACCESS_TOKEN_VALID: AccountAccessTokenState = 2;
#[doc = "Enum for account access token state"]
pub type AccountAccessTokenState = ::libc::c_uchar;
#[doc = "< Invalidates only the account token itself (and the expiry date)."]
pub const INVALIDATE_ACCESS_TOKEN: InvalidateAccessTokenAction = 1;
#[doc = "< Invalidates only the refresh token."]
pub const INVALIDATE_REFRESH_TOKEN: InvalidateAccessTokenAction = 2;
#[doc = "Enum for account access token invalidation action"]
pub type InvalidateAccessTokenAction = ::libc::c_uchar;
#[doc = "Coppa Code Mail Data Structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoppaCodeMailData {
    pub coppaCode: [::libc::c_char; 6usize],
    pub parentEmail: AccountMailAddress,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CoppaCodeMailData"][::core::mem::size_of::<CoppaCodeMailData>() - 263usize];
    ["Alignment of CoppaCodeMailData"][::core::mem::align_of::<CoppaCodeMailData>() - 1usize];
    ["Offset of field: CoppaCodeMailData::coppaCode"]
        [::core::mem::offset_of!(CoppaCodeMailData, coppaCode) - 0usize];
    ["Offset of field: CoppaCodeMailData::parentEmail"]
        [::core::mem::offset_of!(CoppaCodeMailData, parentEmail) - 6usize];
};
impl Default for CoppaCodeMailData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Mii CFLStoreData (CTR Face Library Store Data) structure"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CFLStoreData {
    pub miiData: MiiData,
    pub pad: [u8_; 2usize],
    pub crc16: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CFLStoreData"][::core::mem::size_of::<CFLStoreData>() - 96usize];
    ["Alignment of CFLStoreData"][::core::mem::align_of::<CFLStoreData>() - 1usize];
    ["Offset of field: CFLStoreData::miiData"]
        [::core::mem::offset_of!(CFLStoreData, miiData) - 0usize];
    ["Offset of field: CFLStoreData::pad"][::core::mem::offset_of!(CFLStoreData, pad) - 92usize];
    ["Offset of field: CFLStoreData::crc16"]
        [::core::mem::offset_of!(CFLStoreData, crc16) - 94usize];
};
#[doc = "Birth date structure"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BirthDate {
    pub year: u16_,
    pub month: u8_,
    pub day: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BirthDate"][::core::mem::size_of::<BirthDate>() - 4usize];
    ["Alignment of BirthDate"][::core::mem::align_of::<BirthDate>() - 1usize];
    ["Offset of field: BirthDate::year"][::core::mem::offset_of!(BirthDate, year) - 0usize];
    ["Offset of field: BirthDate::month"][::core::mem::offset_of!(BirthDate, month) - 2usize];
    ["Offset of field: BirthDate::day"][::core::mem::offset_of!(BirthDate, day) - 3usize];
};
#[doc = "Account info structure"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AccountInfo {
    pub persistentId: u32_,
    pub pad: [u8_; 4usize],
    pub transferableIdBase: u64_,
    pub mii: CFLStoreData,
    pub screenName: MiiScreenName,
    pub accountId: [::libc::c_char; 17usize],
    pub pad2: u8_,
    pub birthDate: BirthDate,
    pub principalId: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AccountInfo"][::core::mem::size_of::<AccountInfo>() - 160usize];
    ["Alignment of AccountInfo"][::core::mem::align_of::<AccountInfo>() - 1usize];
    ["Offset of field: AccountInfo::persistentId"]
        [::core::mem::offset_of!(AccountInfo, persistentId) - 0usize];
    ["Offset of field: AccountInfo::pad"][::core::mem::offset_of!(AccountInfo, pad) - 4usize];
    ["Offset of field: AccountInfo::transferableIdBase"]
        [::core::mem::offset_of!(AccountInfo, transferableIdBase) - 8usize];
    ["Offset of field: AccountInfo::mii"][::core::mem::offset_of!(AccountInfo, mii) - 16usize];
    ["Offset of field: AccountInfo::screenName"]
        [::core::mem::offset_of!(AccountInfo, screenName) - 112usize];
    ["Offset of field: AccountInfo::accountId"]
        [::core::mem::offset_of!(AccountInfo, accountId) - 134usize];
    ["Offset of field: AccountInfo::pad2"][::core::mem::offset_of!(AccountInfo, pad2) - 151usize];
    ["Offset of field: AccountInfo::birthDate"]
        [::core::mem::offset_of!(AccountInfo, birthDate) - 152usize];
    ["Offset of field: AccountInfo::principalId"]
        [::core::mem::offset_of!(AccountInfo, principalId) - 156usize];
};
#[doc = "Account Timezone structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AccountTimezone {
    pub timezoneArea: [::libc::c_char; 65usize],
    pub pad: [::libc::c_char; 3usize],
    pub timezoneId: [::libc::c_char; 65usize],
    pub pad2: [::libc::c_char; 3usize],
    pub utcOffset: s64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AccountTimezone"][::core::mem::size_of::<AccountTimezone>() - 144usize];
    ["Alignment of AccountTimezone"][::core::mem::align_of::<AccountTimezone>() - 1usize];
    ["Offset of field: AccountTimezone::timezoneArea"]
        [::core::mem::offset_of!(AccountTimezone, timezoneArea) - 0usize];
    ["Offset of field: AccountTimezone::pad"]
        [::core::mem::offset_of!(AccountTimezone, pad) - 65usize];
    ["Offset of field: AccountTimezone::timezoneId"]
        [::core::mem::offset_of!(AccountTimezone, timezoneId) - 68usize];
    ["Offset of field: AccountTimezone::pad2"]
        [::core::mem::offset_of!(AccountTimezone, pad2) - 133usize];
    ["Offset of field: AccountTimezone::utcOffset"]
        [::core::mem::offset_of!(AccountTimezone, utcOffset) - 136usize];
};
impl Default for AccountTimezone {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Timezone List structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TimezoneList {
    pub capacity: u32_,
    pub count: u32_,
    pub timezones: [AccountTimezone; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TimezoneList"][::core::mem::size_of::<TimezoneList>() - 4616usize];
    ["Alignment of TimezoneList"][::core::mem::align_of::<TimezoneList>() - 1usize];
    ["Offset of field: TimezoneList::capacity"]
        [::core::mem::offset_of!(TimezoneList, capacity) - 0usize];
    ["Offset of field: TimezoneList::count"][::core::mem::offset_of!(TimezoneList, count) - 4usize];
    ["Offset of field: TimezoneList::timezones"]
        [::core::mem::offset_of!(TimezoneList, timezones) - 8usize];
};
impl Default for TimezoneList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "EULA Info structure"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EulaInfo {
    #[doc = "< ISO 3166-1 A-2 country code"]
    pub countryCode: [::libc::c_char; 3usize],
    #[doc = "< ISO 639 Set 1 language code"]
    pub languageCode: [::libc::c_char; 3usize],
    pub eulaVersion: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EulaInfo"][::core::mem::size_of::<EulaInfo>() - 8usize];
    ["Alignment of EulaInfo"][::core::mem::align_of::<EulaInfo>() - 1usize];
    ["Offset of field: EulaInfo::countryCode"]
        [::core::mem::offset_of!(EulaInfo, countryCode) - 0usize];
    ["Offset of field: EulaInfo::languageCode"]
        [::core::mem::offset_of!(EulaInfo, languageCode) - 3usize];
    ["Offset of field: EulaInfo::eulaVersion"]
        [::core::mem::offset_of!(EulaInfo, eulaVersion) - 6usize];
};
#[doc = "Existent Server Account Data structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ExistentServerAccountData {
    pub hasMii: bool,
    pub pad: [u8_; 3usize],
    pub miiData: CFLStoreData,
    pub principalId: u32_,
    pub coppaRequiredFlag: bool,
    pub pad2: [u8_; 3usize],
    pub coppaMailData: CoppaCodeMailData,
    pub pad3: u8_,
    pub birthDate: BirthDate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExistentServerAccountData"]
        [::core::mem::size_of::<ExistentServerAccountData>() - 376usize];
    ["Alignment of ExistentServerAccountData"]
        [::core::mem::align_of::<ExistentServerAccountData>() - 1usize];
    ["Offset of field: ExistentServerAccountData::hasMii"]
        [::core::mem::offset_of!(ExistentServerAccountData, hasMii) - 0usize];
    ["Offset of field: ExistentServerAccountData::pad"]
        [::core::mem::offset_of!(ExistentServerAccountData, pad) - 1usize];
    ["Offset of field: ExistentServerAccountData::miiData"]
        [::core::mem::offset_of!(ExistentServerAccountData, miiData) - 4usize];
    ["Offset of field: ExistentServerAccountData::principalId"]
        [::core::mem::offset_of!(ExistentServerAccountData, principalId) - 100usize];
    ["Offset of field: ExistentServerAccountData::coppaRequiredFlag"]
        [::core::mem::offset_of!(ExistentServerAccountData, coppaRequiredFlag) - 104usize];
    ["Offset of field: ExistentServerAccountData::pad2"]
        [::core::mem::offset_of!(ExistentServerAccountData, pad2) - 105usize];
    ["Offset of field: ExistentServerAccountData::coppaMailData"]
        [::core::mem::offset_of!(ExistentServerAccountData, coppaMailData) - 108usize];
    ["Offset of field: ExistentServerAccountData::pad3"]
        [::core::mem::offset_of!(ExistentServerAccountData, pad3) - 371usize];
    ["Offset of field: ExistentServerAccountData::birthDate"]
        [::core::mem::offset_of!(ExistentServerAccountData, birthDate) - 372usize];
};
impl Default for ExistentServerAccountData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "EULA entry header structure"]
#[repr(C, packed)]
pub struct EulaEntry {
    #[doc = "< ISO 3166-1 A-2 country code"]
    pub countryCode: [::libc::c_char; 3usize],
    pub pad: u8_,
    #[doc = "< ISO 639 Set 1 language code"]
    pub languageCode: [::libc::c_char; 3usize],
    pub pad2: u8_,
    pub eulaVersion: u16_,
    pub pad3: [u8_; 2usize],
    #[doc = "< Offset of next EULA entry, relative to full data blob."]
    pub nextEntryOffset: u32_,
    #[doc = "< Offset of the EulaType within textData."]
    pub eulaTypeOffset: u32_,
    #[doc = "< Offset of the AgreeText within textData."]
    pub agreeTextOffset: u32_,
    #[doc = "< Offset of the NonAgreeText within textData."]
    pub nonAgreeTextOffset: u32_,
    #[doc = "< Offset of the LanguageName within textData."]
    pub languageNameOffset: u32_,
    #[doc = "< Offset of the MainTitle within textData."]
    pub mainTitleOffset: u32_,
    #[doc = "< Offset of the MainText within textData."]
    pub mainTextOffset: u32_,
    #[doc = "< Offset of the SubTitle within textData."]
    pub subTitleOffset: u32_,
    #[doc = "< Offset of the SubText within textData."]
    pub subTextOffset: u32_,
    pub textData: __IncompleteArrayField<::libc::c_char>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EulaEntry"][::core::mem::size_of::<EulaEntry>() - 48usize];
    ["Alignment of EulaEntry"][::core::mem::align_of::<EulaEntry>() - 1usize];
    ["Offset of field: EulaEntry::countryCode"]
        [::core::mem::offset_of!(EulaEntry, countryCode) - 0usize];
    ["Offset of field: EulaEntry::pad"][::core::mem::offset_of!(EulaEntry, pad) - 3usize];
    ["Offset of field: EulaEntry::languageCode"]
        [::core::mem::offset_of!(EulaEntry, languageCode) - 4usize];
    ["Offset of field: EulaEntry::pad2"][::core::mem::offset_of!(EulaEntry, pad2) - 7usize];
    ["Offset of field: EulaEntry::eulaVersion"]
        [::core::mem::offset_of!(EulaEntry, eulaVersion) - 8usize];
    ["Offset of field: EulaEntry::pad3"][::core::mem::offset_of!(EulaEntry, pad3) - 10usize];
    ["Offset of field: EulaEntry::nextEntryOffset"]
        [::core::mem::offset_of!(EulaEntry, nextEntryOffset) - 12usize];
    ["Offset of field: EulaEntry::eulaTypeOffset"]
        [::core::mem::offset_of!(EulaEntry, eulaTypeOffset) - 16usize];
    ["Offset of field: EulaEntry::agreeTextOffset"]
        [::core::mem::offset_of!(EulaEntry, agreeTextOffset) - 20usize];
    ["Offset of field: EulaEntry::nonAgreeTextOffset"]
        [::core::mem::offset_of!(EulaEntry, nonAgreeTextOffset) - 24usize];
    ["Offset of field: EulaEntry::languageNameOffset"]
        [::core::mem::offset_of!(EulaEntry, languageNameOffset) - 28usize];
    ["Offset of field: EulaEntry::mainTitleOffset"]
        [::core::mem::offset_of!(EulaEntry, mainTitleOffset) - 32usize];
    ["Offset of field: EulaEntry::mainTextOffset"]
        [::core::mem::offset_of!(EulaEntry, mainTextOffset) - 36usize];
    ["Offset of field: EulaEntry::subTitleOffset"]
        [::core::mem::offset_of!(EulaEntry, subTitleOffset) - 40usize];
    ["Offset of field: EulaEntry::subTextOffset"]
        [::core::mem::offset_of!(EulaEntry, subTextOffset) - 44usize];
    ["Offset of field: EulaEntry::textData"]
        [::core::mem::offset_of!(EulaEntry, textData) - 48usize];
};
impl Default for EulaEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Support Context structure"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SupportContext {
    #[doc = "< Account ID of the account."]
    pub accountId: AccountId,
    pub pad: [u8_; 3usize],
    #[doc = "< Serial number of the console (only digits)."]
    pub serialNumber: u32_,
    pub principalId: u32_,
    #[doc = "< Random number based on the principalId and serialNumber."]
    pub randomNumber: u16_,
    pub pad2: [u8_; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SupportContext"][::core::mem::size_of::<SupportContext>() - 32usize];
    ["Alignment of SupportContext"][::core::mem::align_of::<SupportContext>() - 1usize];
    ["Offset of field: SupportContext::accountId"]
        [::core::mem::offset_of!(SupportContext, accountId) - 0usize];
    ["Offset of field: SupportContext::pad"]
        [::core::mem::offset_of!(SupportContext, pad) - 17usize];
    ["Offset of field: SupportContext::serialNumber"]
        [::core::mem::offset_of!(SupportContext, serialNumber) - 20usize];
    ["Offset of field: SupportContext::principalId"]
        [::core::mem::offset_of!(SupportContext, principalId) - 24usize];
    ["Offset of field: SupportContext::randomNumber"]
        [::core::mem::offset_of!(SupportContext, randomNumber) - 28usize];
    ["Offset of field: SupportContext::pad2"]
        [::core::mem::offset_of!(SupportContext, pad2) - 30usize];
};
#[doc = "EULA list structure"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct EulaList {
    #[doc = "< Number of entries within the list."]
    pub numEntries: u8_,
    #[doc = "< EULA Entries (dynamically sized)"]
    pub entries: __IncompleteArrayField<u8_>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EulaList"][::core::mem::size_of::<EulaList>() - 1usize];
    ["Alignment of EulaList"][::core::mem::align_of::<EulaList>() - 1usize];
    ["Offset of field: EulaList::numEntries"]
        [::core::mem::offset_of!(EulaList, numEntries) - 0usize];
    ["Offset of field: EulaList::entries"][::core::mem::offset_of!(EulaList, entries) - 1usize];
};
#[doc = "Device Info structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DeviceInfo {
    pub deviceId: u32_,
    pub serialNumber: [::libc::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DeviceInfo"][::core::mem::size_of::<DeviceInfo>() - 20usize];
    ["Alignment of DeviceInfo"][::core::mem::align_of::<DeviceInfo>() - 4usize];
    ["Offset of field: DeviceInfo::deviceId"]
        [::core::mem::offset_of!(DeviceInfo, deviceId) - 0usize];
    ["Offset of field: DeviceInfo::serialNumber"]
        [::core::mem::offset_of!(DeviceInfo, serialNumber) - 4usize];
};
#[doc = "NEX service token structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NexServiceToken {
    pub serviceToken: [::libc::c_char; 513usize],
    pub pad: [u8_; 3usize],
    pub password: [::libc::c_char; 65usize],
    pub pad2: [u8_; 3usize],
    pub serverHost: [::libc::c_char; 16usize],
    pub serverPort: u16_,
    pub pad3: [u8_; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NexServiceToken"][::core::mem::size_of::<NexServiceToken>() - 604usize];
    ["Alignment of NexServiceToken"][::core::mem::align_of::<NexServiceToken>() - 2usize];
    ["Offset of field: NexServiceToken::serviceToken"]
        [::core::mem::offset_of!(NexServiceToken, serviceToken) - 0usize];
    ["Offset of field: NexServiceToken::pad"]
        [::core::mem::offset_of!(NexServiceToken, pad) - 513usize];
    ["Offset of field: NexServiceToken::password"]
        [::core::mem::offset_of!(NexServiceToken, password) - 516usize];
    ["Offset of field: NexServiceToken::pad2"]
        [::core::mem::offset_of!(NexServiceToken, pad2) - 581usize];
    ["Offset of field: NexServiceToken::serverHost"]
        [::core::mem::offset_of!(NexServiceToken, serverHost) - 584usize];
    ["Offset of field: NexServiceToken::serverPort"]
        [::core::mem::offset_of!(NexServiceToken, serverPort) - 600usize];
    ["Offset of field: NexServiceToken::pad3"]
        [::core::mem::offset_of!(NexServiceToken, pad3) - 602usize];
};
impl Default for NexServiceToken {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Credit Card Info structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreditCardInfo {
    pub cardType: u8_,
    pub cardNumber: [::libc::c_char; 17usize],
    pub securityCode: [::libc::c_char; 4usize],
    pub expirationMonth: u8_,
    pub expirationYear: u8_,
    pub postalCode: [::libc::c_char; 7usize],
    pub mailAddress: AccountMailAddress,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CreditCardInfo"][::core::mem::size_of::<CreditCardInfo>() - 288usize];
    ["Alignment of CreditCardInfo"][::core::mem::align_of::<CreditCardInfo>() - 1usize];
    ["Offset of field: CreditCardInfo::cardType"]
        [::core::mem::offset_of!(CreditCardInfo, cardType) - 0usize];
    ["Offset of field: CreditCardInfo::cardNumber"]
        [::core::mem::offset_of!(CreditCardInfo, cardNumber) - 1usize];
    ["Offset of field: CreditCardInfo::securityCode"]
        [::core::mem::offset_of!(CreditCardInfo, securityCode) - 18usize];
    ["Offset of field: CreditCardInfo::expirationMonth"]
        [::core::mem::offset_of!(CreditCardInfo, expirationMonth) - 22usize];
    ["Offset of field: CreditCardInfo::expirationYear"]
        [::core::mem::offset_of!(CreditCardInfo, expirationYear) - 23usize];
    ["Offset of field: CreditCardInfo::postalCode"]
        [::core::mem::offset_of!(CreditCardInfo, postalCode) - 24usize];
    ["Offset of field: CreditCardInfo::mailAddress"]
        [::core::mem::offset_of!(CreditCardInfo, mailAddress) - 31usize];
};
impl Default for CreditCardInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "V1 Independent service token structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndependentServiceTokenV1 {
    #[doc = "< base64"]
    pub token: [::libc::c_char; 513usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IndependentServiceTokenV1"]
        [::core::mem::size_of::<IndependentServiceTokenV1>() - 513usize];
    ["Alignment of IndependentServiceTokenV1"]
        [::core::mem::align_of::<IndependentServiceTokenV1>() - 1usize];
    ["Offset of field: IndependentServiceTokenV1::token"]
        [::core::mem::offset_of!(IndependentServiceTokenV1, token) - 0usize];
};
impl Default for IndependentServiceTokenV1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "V2 Independent service token structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndependentServiceTokenV2 {
    #[doc = "< base64"]
    pub token: [::libc::c_char; 513usize],
    #[doc = "< base64"]
    pub iv: [::libc::c_char; 25usize],
    #[doc = "< base64"]
    pub signature: [::libc::c_char; 345usize],
    pub nfsTypeStr: NfsTypeStr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IndependentServiceTokenV2"]
        [::core::mem::size_of::<IndependentServiceTokenV2>() - 886usize];
    ["Alignment of IndependentServiceTokenV2"]
        [::core::mem::align_of::<IndependentServiceTokenV2>() - 1usize];
    ["Offset of field: IndependentServiceTokenV2::token"]
        [::core::mem::offset_of!(IndependentServiceTokenV2, token) - 0usize];
    ["Offset of field: IndependentServiceTokenV2::iv"]
        [::core::mem::offset_of!(IndependentServiceTokenV2, iv) - 513usize];
    ["Offset of field: IndependentServiceTokenV2::signature"]
        [::core::mem::offset_of!(IndependentServiceTokenV2, signature) - 538usize];
    ["Offset of field: IndependentServiceTokenV2::nfsTypeStr"]
        [::core::mem::offset_of!(IndependentServiceTokenV2, nfsTypeStr) - 883usize];
};
impl Default for IndependentServiceTokenV2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Account server types structure (raw format)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AccountServerTypes {
    #[doc = "< NNAS (Nintendo Network Authentication Server) type"]
    pub nnasType: u8_,
    #[doc = "< NFS (Nintendo Friend Server) type"]
    pub nfsType: u8_,
    #[doc = "< NFS (Nintendo Friend Server) number"]
    pub nfsNo: u8_,
    pub pad: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AccountServerTypes"][::core::mem::size_of::<AccountServerTypes>() - 4usize];
    ["Alignment of AccountServerTypes"][::core::mem::align_of::<AccountServerTypes>() - 1usize];
    ["Offset of field: AccountServerTypes::nnasType"]
        [::core::mem::offset_of!(AccountServerTypes, nnasType) - 0usize];
    ["Offset of field: AccountServerTypes::nfsType"]
        [::core::mem::offset_of!(AccountServerTypes, nfsType) - 1usize];
    ["Offset of field: AccountServerTypes::nfsNo"]
        [::core::mem::offset_of!(AccountServerTypes, nfsNo) - 2usize];
    ["Offset of field: AccountServerTypes::pad"]
        [::core::mem::offset_of!(AccountServerTypes, pad) - 3usize];
};
#[doc = "Account server types structure (string format)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccountServerTypesStr {
    #[doc = "< NNAS (Nintendo Network Authentication Server) subdomain"]
    pub nnasSubdomain: ActNnasSubdomain,
    #[doc = "< NFS (Nintendo Friend Server) type string (letter + number)"]
    pub nfsTypeStr: NfsTypeStr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AccountServerTypesStr"][::core::mem::size_of::<AccountServerTypesStr>() - 36usize];
    ["Alignment of AccountServerTypesStr"]
        [::core::mem::align_of::<AccountServerTypesStr>() - 1usize];
    ["Offset of field: AccountServerTypesStr::nnasSubdomain"]
        [::core::mem::offset_of!(AccountServerTypesStr, nnasSubdomain) - 0usize];
    ["Offset of field: AccountServerTypesStr::nfsTypeStr"]
        [::core::mem::offset_of!(AccountServerTypesStr, nfsTypeStr) - 33usize];
};
impl Default for AccountServerTypesStr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Account access token structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccountAccessToken {
    #[doc = "< AccountAccessTokenState enum"]
    pub state: u8_,
    pub accessToken: [::libc::c_char; 33usize],
    pub refreshToken: [::libc::c_char; 41usize],
    pub pad: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AccountAccessToken"][::core::mem::size_of::<AccountAccessToken>() - 76usize];
    ["Alignment of AccountAccessToken"][::core::mem::align_of::<AccountAccessToken>() - 1usize];
    ["Offset of field: AccountAccessToken::state"]
        [::core::mem::offset_of!(AccountAccessToken, state) - 0usize];
    ["Offset of field: AccountAccessToken::accessToken"]
        [::core::mem::offset_of!(AccountAccessToken, accessToken) - 1usize];
    ["Offset of field: AccountAccessToken::refreshToken"]
        [::core::mem::offset_of!(AccountAccessToken, refreshToken) - 34usize];
    ["Offset of field: AccountAccessToken::pad"]
        [::core::mem::offset_of!(AccountAccessToken, pad) - 75usize];
};
impl Default for AccountAccessToken {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes ACT services.\n # Arguments\n\n* `forceUser` - Whether or not to force using the user service act:u instead of the default (admin service act:a)."]
    pub fn actInit(forceUser: bool) -> Result;
}
unsafe extern "C" {
    #[doc = "Exits ACT services."]
    pub fn actExit();
}
unsafe extern "C" {
    #[doc = "Get the ACT user/admin service handle."]
    pub fn actGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the current ACT session.\n # Arguments\n\n* `sdkVersion` - The SDK version of the client process.\n * `sharedMemSize` - The size of the shared memory block.\n * `sharedMem` - Handle to the shared memory block."]
    pub fn ACT_Initialize(sdkVersion: u32_, sharedMemSize: u32_, sharedMem: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns a support error code (XXX-YYYY) for the given ACT result code.\n # Arguments\n\n* `code` - The result code to convert."]
    pub fn ACT_ResultToErrorCode(code: Result) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the result of the last internal operation."]
    pub fn ACT_GetLastResponseResult() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Cancels any currently running async operation."]
    pub fn ACT_Cancel() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrieves information not specific to any one account.\n # Arguments\n\n* `output` - Pointer to buffer to output the data to.\n * `outputSize` - Size of the output buffer.\n * `infoType` - The type of data to retrieve."]
    pub fn ACT_GetCommonInfo(
        output: *mut ::libc::c_void,
        outputSize: u32_,
        infoType: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrieves information of a certain account.\n # Arguments\n\n* `output` - Pointer to buffer to output the data to.\n * `outputSize` - Size of the output buffer.\n * `accountSlot` - The account slot number of the account to retrieve information for.\n * `infoType` - The type of data to retrieve."]
    pub fn ACT_GetAccountInfo(
        output: *mut ::libc::c_void,
        outputSize: u32_,
        accountSlot: u8_,
        infoType: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns the data resulting from an async request.\n # Arguments\n\n* `outReadSize` - Pointer to output the number of retrieved bytes to.\n * `output` - Pointer to buffer to output the data to.\n * `outputSize` - Size of the output buffer.\n * `requestType` - The type of async request to retrieve data for."]
    pub fn ACT_GetAsyncResult(
        outReadSize: *mut u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
        requestType: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets one of the Mii images of a certain account.\n # Arguments\n\n* `outSize` - Pointer to output the raw size of the image to.\n * `output` - Pointer to output the image data to.\n * `outputSize` - Size of the output buffer.\n * `accountSlot` - The account slot number of the account to get the Mii image for.\n * `miiImageType` - The type of the Mii image to get."]
    pub fn ACT_GetMiiImage(
        outSize: *mut u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
        accountSlot: u8_,
        miiImageType: u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the NFS (Nintendo Friend Server) password for a certain account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to set the NfsPassword for.\n * `password` - Pointer to the new NFS password to use."]
    pub fn ACT_SetNfsPassword(accountSlot: u8_, password: *mut ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the `IsApplicationUpdateRequired` field in the internal account manager.\n # Arguments\n\n* `required` - The new value to use."]
    pub fn ACT_SetIsApplicationUpdateRequired(required: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acquires a list of EULA agreements for the specified country.\n # Arguments\n\n* `countryCode` - The country code of the country to acquire EULA agreements for.\n * `completionEvent` - The event handle to signal when the request has finished."]
    pub fn ACT_AcquireEulaList(countryCode: u8_, completionEvent: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acquires a list of timezones for the specified country and language combination.\n # Arguments\n\n* `countryCode` - The country code of the country to acquire time zones for.\n * `language` - code The language code of the language to acquire the time zones in.\n * `completionEvent` - The event handle to signal when the request has finished."]
    pub fn ACT_AcquireTimezoneList(
        countryCode: u8_,
        languageCode: u8_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Generates a UUID.\n # Arguments\n\n* `uuid` - Pointer to output the generated UUID to.\n * `uniqueId` - The unique ID to use during generation. Special values include `ACT_UUID_REGULAR` and `ACT_UUID_CURRENT_PROCESS`."]
    pub fn ACT_GenerateUuid(uuid: *mut ActUuid, uniqueId: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a specific account's UUID.\n # Arguments\n\n* `uuid` - Pointer to output the UUID to.\n * `uniqueId` - The unique ID to use during the retrieval of the UUID. Special values include `ACT_UUID_REGULAR` and `ACT_UUID_CURRENT_PROCESS`."]
    pub fn ACT_GetUuid(uuid: *mut ActUuid, accountSlot: u8_, uniqueId: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Finds the account slot number of the account having the specified UUID.\n # Arguments\n\n* `accountSlot` - Pointer to output the account slot number to.\n * `uuid` - Pointer to the UUID to find the account slot number for.\n * `uniqueId` - The unique ID to use during internal UUID generation. Special values include `ACT_UUID_REGULAR` and `ACT_UUID_CURRENT_PROCESS`."]
    pub fn ACT_FindSlotNoByUuid(
        accountSlot: *mut u8_,
        uuid: *mut ActUuid,
        uniqueId: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Saves all pending changes to the ACT system save data."]
    pub fn ACT_Save() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns a TransferableID for a certain account.\n # Arguments\n\n* `transferableId` - Pointer to output the generated TransferableID to.\n * `accountSlot` - The account slot number of the account to generate the TransferableID for. Special values include `ACT_TRANSFERABLE_ID_BASE_COMMON` and `ACT_TRANSFERABLE_ID_BASE_CURRENT_ACCOUNT`.\n * `saltValue` - The value to use as a salt during generation."]
    pub fn ACT_GetTransferableId(
        transferableId: *mut u64_,
        accountSlot: u8_,
        saltValue: u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acquires an account-specific service token for a NEX server.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to use for acquiring the token.\n * `serverId` - The NEX server ID to request a service token for.\n * `doParentalControlsCheck` - Whether or not to perform a parental controls check before requesting the token. (unused)\n * `callerProcessId` - The process ID of the process requesting the token.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACT_AcquireNexServiceToken(
        accountSlot: u8_,
        serverId: u32_,
        doParentralControlsCheck: bool,
        callerProcessId: u32_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a NEX service token requested using ACT_AcquireNexServiceToken.\n # Arguments\n\n* `token` - Pointer to output the NEX service token data to."]
    pub fn ACT_GetNexServiceToken(token: *mut NexServiceToken) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Requests a V1 independent service token for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to request the token with.\n * `clientId` - The client ID to use for requesting the independent service token.\n * `cacheDuration` - The duration in seconds to cache the token. If a token was requested within the past cacheDuration seconds, this command returns that token instead of requesting a new one. Passing 0 will cause ACT to always request a new token.\n * `doParentalControlsCheck` - Whether or not to perform a parental controls check before requesting the token. (unused)\n * `shared` - Whether or not this token should be shared with other processes. If set to false, it will only be accessible to the process with the given process ID.\n * `callerProcessId` - The process ID of the process requesting the token.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACT_AcquireIndependentServiceToken(
        accountSlot: u8_,
        clientId: *mut ::libc::c_char,
        cacheDuration: u32_,
        doParentalControlsCheck: bool,
        shared: bool,
        callerProcessId: u32_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a V1 independent service token requested using ACT_AcquireIndependentServiceToken.\n # Arguments\n\n* `token` - Pointer to output the V1 independent service token to."]
    pub fn ACT_GetIndependentServiceToken(token: *mut IndependentServiceTokenV1) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acquires account information for the specified account.\n # Arguments\n\n* `accountSlot` - The account slot number to acquire information for.\n * `infoType` - The type of info to obtain. (only INFO_TYPE_MAIL_ADDRESS is supported.)\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACT_AcquireAccountInfo(
        accountSlot: u8_,
        infoType: u32_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acquires account IDs from a list of principal IDs.\n # Arguments\n\n* `principalIds` - Pointer to the input principal IDs.\n * `principalIdsSize` - Size of the input principal IDs buffer.\n * `unk` - Unknown value. Must be 0.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACT_AcquireAccountIdByPrincipalId(
        principalIds: *mut u32_,
        principalIdsSize: u32_,
        unk: u8_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acquires principal IDs from a list of account IDs.\n # Arguments\n\n* `accountIds` - Pointer to input account IDs.\n * `accountIdsSize` - Size of the input account IDs buffer.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACT_AcquirePrincipalIdByAccountId(
        accountIds: *mut AccountId,
        accountIdsSize: u32_,
        completionHandle: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acquires Miis corresponding to a given list of persistent IDs.\n # Arguments\n\n* `persistentIds` - Pointer to input persistent IDs to use.\n * `persistentIdsSize` - Size of the input persistent IDs buffer.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACT_AcquireMii(
        persistentIds: *mut u32_,
        persistentIdsSize: u32_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acquires raw (XML) account info for the specified account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to acquire raw info for."]
    pub fn ACT_AcquireAccountInfoRaw(accountSlot: u8_, completionEvent: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a cached V1 independent service token for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to get the token for.\n * `clientId` - The client ID to use for the cache lookup.\n * `cacheDuration` - The duration in seconds ago this token must have been requested in at least for it to be eligible for retrieval.\n * `doParentalControlsCheck` - Whether or not to perform a parental controls check before getting the token. (unused)\n * `shared` - Whether or not to only look for shared (non-process-specific) tokens in the cache."]
    pub fn ACT_GetCachedIndependentServiceToken(
        token: *mut IndependentServiceTokenV1,
        accountSlot: u8_,
        clientId: *mut ::libc::c_char,
        cacheDuration: u32_,
        doParentralControlsCheck: bool,
        shared: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Inquires whether or not the given email address is available for creating a new account.\n # Arguments\n\n* `mailAddress` - Pointer to the input email address to check.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACT_InquireMailAddressAvailability(
        mailAddress: *mut AccountMailAddress,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acquires the EULA for the given country and language combination.\n # Arguments\n\n* `countryCode` - The country code of the country for the EULA.\n * `languageCode` - The 2-character ISO 639 Set 1 language code for the EULA.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACT_AcquireEula(
        countryCode: u8_,
        languageCode: *mut ::libc::c_char,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acquires a list of languages the EULA is available in for a given country.\n # Arguments\n\n* `countryCode` - The country code to acquire the EULA language list for.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACT_AcquireEulaLanguageList(countryCode: u8_, completionEvent: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Requests a V2 independent service token for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to request the token with.\n * `clientId` - The client ID to use for requesting the independent service token.\n * `cacheDuration` - The duration in seconds to cache the token. If a token was requested within the past cacheDuration seconds, this command returns that token instead of requesting a new one. Passing 0 will cause ACT to always request a new token.\n * `doParentalControlsCheck` - Whether or not to perform a parental controls check before requesting the token. (unused)\n * `shared` - Whether or not this token should be shared with other processes. If set to false, it will only be accessible to the process with the given process ID.\n * `callerProcessId` - The process ID of the process requesting the token.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACT_AcquireIndependentServiceTokenV2(
        accountSlot: u8_,
        clientId: *mut ::libc::c_char,
        cacheDuration: u32_,
        doParentalControlsCheck: bool,
        shared: bool,
        callerProcessId: u32_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a V2 independent service token requested using ACT_AcquireIndependentServiceTokenV2.\n # Arguments\n\n* `token` - Pointer to output the V2 independent service token to."]
    pub fn ACT_GetIndependentServiceTokenV2(token: *mut IndependentServiceTokenV2) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a cached V2 independent service token for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to get the token for.\n * `clientId` - The client ID to use for the cache lookup.\n * `cacheDuration` - The duration in seconds ago this token must have been requested in at least for it to be eligible for retrieval.\n * `doParentalControlsCheck` - Whether or not to perform a parental controls check before getting the token. (unused)\n * `shared` - Whether or not to only look for shared (non-process-specific) tokens in the cache."]
    pub fn ACT_GetCachedIndependentServiceTokenV2(
        token: *mut IndependentServiceTokenV2,
        accountSlot: u8_,
        clientId: *mut ::libc::c_char,
        cacheDuration: u32_,
        doParentralControlsCheck: bool,
        shared: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Swaps the account slot numbers of two accounts.\n # Arguments\n\n* `accountSlot1` - The first account slot number.\n * `accountSlot2` - The second account slot number."]
    pub fn ACTA_SwapAccounts(accountSlot1: u8_, accountSlot2: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a new local console account."]
    pub fn ACTA_CreateConsoleAccount() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets a local console account as committed.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to set as committed."]
    pub fn ACTA_CommitConsoleAccount(accountSlot: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Clears (but does not delete) account data for the given account slot. The FpLocalAccountId will not be cleared.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to clear.\n * `completely` - Whether or not to also clear the AssignedAccountId and AssignedPrincipalId in the account data."]
    pub fn ACTA_UnbindServerAccount(accountSlot: u8_, completely: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes a local console account.\n # Arguments\n\n* `accountSlot` - The account slot number of the local console account to delete."]
    pub fn ACTA_DeleteConsoleAccount(accountSlot: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Loads (\"logs in to\") a local console account.\n # Arguments\n\n* `accountSlot` - The account slot number of the local console account to load.\n * `doPasswordCheck` - Whether or not the check the input password, or if one isn't provided, the cached password (if enabled).\n * `password` - Pointer to the input password.\n * `useNullPassword` - Whether or not to forcefully use NULL as the password (= no password).\n * `dryRun` - Whether or not to execute this command as a \"dry run,\" not actually changing the current account to specified one."]
    pub fn ACTA_LoadConsoleAccount(
        accountSlot: u8_,
        doPasswordCheck: bool,
        password: *mut AccountPassword,
        useNullPassword: bool,
        dryRun: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unloads the currently loaded local console account."]
    pub fn ACTA_UnloadConsoleAccount() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Enables or disables the account password cache for a specific account. When the account password cache is enabled, entering the password is not required to log into the account.\n # Arguments\n\n* `accountSlot` - The account slot number to enable/disable the account password cache for.\n * `enabled` - Whether or not to enable the account password cache."]
    pub fn ACTA_EnableAccountPasswordCache(accountSlot: u8_, enabled: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the default account that is loaded when the ACT module is initialized.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to set as the default."]
    pub fn ACTA_SetDefaultAccount(accountSlot: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Replaces the AccountId with the AssignedAccountId for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to perform this replacement for."]
    pub fn ACTA_ReplaceAccountId(accountSlot: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a support context for a specific account.\n # Arguments\n\n* `supportContext` - Pointer to write the support context data to.\n * `accountSlot` - The account slot number of the account to create the support context for."]
    pub fn ACTA_GetSupportContext(supportContext: *mut SupportContext, accountSlot: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets server environment settings for a specific account. This will also update CFG configuration block 0x150002 accordingly.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to set the host server settings for.\n * `nnasType` - The NNAS (Nintendo Network Authentication Server) type.\n * `nfsType` - The NFS (Nintendo Friend Server) type.\n * `nfsNo` - The NFS (Nintendo Friend Server) number."]
    pub fn ACTA_SetHostServerSettings(
        accountSlot: u8_,
        nnasType: u8_,
        nfsType: u8_,
        nfsNo: u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets default server environment settings. This will also update CFG configuration block 0x150002 accordingly.\n # Arguments\n\n* `nnasType` - The NNAS (Nintendo Network Authentication Server) type.\n * `nfsType` - The NFS (Nintendo Friend Server) type.\n * `nfsNo` - The NFS (Nintendo Friend Server) number."]
    pub fn ACTA_SetDefaultHostServerSettings(nnasType: u8_, nfsType: u8_, nfsNo: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets server environment settings (in string form) for a specific account. This will also update CFG configuration block 0x150002 accordingly.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to set the host server settings for.\n * `nnasSubdomain` - Pointer to the new NNAS (Nintendo Network Authentication Server) subdomain to use.\n * `nfsTypeStr` - Pointer to the new NFS (Nintendo Friend Server) type to use."]
    pub fn ACTA_SetHostServerSettingsStr(
        accountSlot: u8_,
        nnasSubdomain: *mut ActNnasSubdomain,
        nfsTypeStr: *mut NfsTypeStr,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets default server environment settings (in string form). This will also update CFG configuration block 0x150002 accordingly.\n # Arguments\n\n* `nnasSubdomain` - Pointer to the new NNAS (Nintendo Network Authentication Server) subdomain to use.\n * `nfsTypeStr` - Pointer to the new NFS (Nintendo Friend Server) type to use."]
    pub fn ACTA_SetDefaultHostServerSettingsStr(
        nnasSubdomain: *mut ActNnasSubdomain,
        nfsTypeStr: *mut NfsTypeStr,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the internal base value for generating new persistent IDs.\n # Arguments\n\n* `head` - The new base value to use."]
    pub fn ACTA_SetPersistentIdHead(head: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the internal base value for generating new transferable IDs.\n # Arguments\n\n* `counter` - The new base value to use."]
    pub fn ACTA_SetTransferableIdCounter(counter: u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates a specific account's Mii data and screen name.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to update the Mii and screen name of.\n * `miiData` - Pointer to the new Mii data to use.\n * `screenName` - Pointer to the new screen name to use."]
    pub fn ACTA_UpdateMiiData(
        accountSlot: u8_,
        miiData: *mut CFLStoreData,
        screenName: *mut MiiScreenName,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates a Mii image of a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to update the Mii image for.\n * `miiImageType` - The type of Mii image to update.\n * `image` - Pointer to the Mii image data to use.\n * `imageSize` - Size of the Mii image data."]
    pub fn ACTA_UpdateMiiImage(
        accountSlot: u8_,
        miiImageType: u8_,
        image: *mut ::libc::c_void,
        imageSize: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks whether or not the given account ID is available for creating a new server account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to perform the check for.\n * `accountId` - Pointer to the input account ID to check.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_InquireAccountIdAvailability(
        accountSlot: u8_,
        accountId: *mut AccountId,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Links a new server account to a local console account. In other words, this creates and links an NNID.\n # Arguments\n\n* `accountSlot` - The account slot number of the local console account to bind.\n * `accountId` - Pointer to the account ID to use for the new server account.\n * `mailAddress` - Pointer to the email address to use for the new server account.\n * `password` - Pointer to the password to use for the new server account.\n * `isParentEmail` - Whether or not the input email address is a parental email address.\n * `marketingFlag` - Whether or not the user has consented to receiving marketing emails. (\"Customized Email Offers\")\n * `offDeviceFlag` - Whether or not the user has allowed using the server account from other devices. (\"Access from PCs and Other Devices\")\n * `birthDateTimestamp` - A birth date timestamp in the format milliseconds elapsed since 01.01.2000 00:00:00 UTC.\n * `parentalConsentTimestamp` - When parental consent is required, the timestamp of parental consent in the format milliseconds elapsed since 01.01.2000 00:00:00 UTC.\n * `parentalConsentId` - When parental consent is required, the resulting ID corresponding to the consent.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_BindToNewServerAccount(
        accountSlot: u8_,
        accountId: *mut AccountId,
        mailAddress: *mut AccountMailAddress,
        password: *mut AccountPassword,
        isParentEmail: bool,
        marketingFlag: bool,
        offDeviceFlag: bool,
        birthDateTimestatmp: s64,
        gender: u8_,
        region: u32_,
        timezone: *mut AccountTimezone,
        eulaInfo: *mut EulaInfo,
        parentalConsentTimestamp: s64,
        parentalConsentId: u32_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Links a local console account to an existing server account. In other words, this links an existing NNID.\n # Arguments\n\n* `accountSlot` - The account slot number of the local console account to bind.\n * `accountId` - Pointer to the account ID of the existing server account.\n * `mailAddress` - Pointer to the email address of the existing server account.\n * `password` - Pointer to the password of the existing server account.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_BindToExistentServerAccount(
        accountSlot: u8_,
        accountId: *mut AccountId,
        mailAddress: *mut AccountMailAddress,
        password: *mut AccountPassword,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acquires information about an existing server account.\n # Arguments\n\n* `accountSlot` - The account slot number of the local console account to use for the request.\n * `accountId` - Pointer to the account ID of the existing server account.\n * `mailAddress` - Pointer to the email address of the existing server account.\n * `password` - Pointer to the password of the existing server account.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_InquireBindingToExistentServerAccount(
        accountSlot: u8_,
        accountId: *mut AccountId,
        mailAddress: *mut AccountMailAddress,
        password: *mut AccountPassword,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes a server account. In other words, this deletes an NNID (server-side).\n # Arguments\n\n* `accountSlot` - The account slot number of the local console account bound to the server account to delete.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_DeleteServerAccount(accountSlot: u8_, completionEvent: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acquires an account token for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to acquire the account token for.\n * `password` - Pointer to the password of the account.\n * `useNullPassword` - Whether or not to force NULL as the password (no password). This will cause the account password cache to be used instead, if it is enabled.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_AcquireAccountTokenEx(
        accountSlot: u8_,
        password: *mut AccountPassword,
        useNullPassword: bool,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Submits a EULA agreement to the account server.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to use to submit the agreement.\n * `eulaInfo` - Pointer to a EULA information structure describing the agreed EULA.\n * `agreementTimestamp` - A timestamp in the format milliseconds elapsed since 01.01.2000 00:00:00 UTC of when the user agreed to the EULA.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_AgreeEula(
        accountSlot: u8_,
        eulaInfo: *mut EulaInfo,
        agreementTimestamp: s64,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reloads account information from the server for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to reload information for.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_SyncAccountInfo(accountSlot: u8_, completionEvent: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Invalidates a specific account's access token in different ways.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to invalidate the access token for.\n * `invalidationMask` - A bitfield of the actions to take to invalidate the access token."]
    pub fn ACTA_InvalidateAccountToken(accountSlot: u8_, invalidationActionMask: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates the account password for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to update the password for.\n * `password` - Pointer to the new password to use.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_UpdateAccountPassword(
        accountSlot: u8_,
        newPassword: *mut AccountPassword,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Requests the issuing of a temporary password (valid for 24 hours) to the email address associated with a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to issue the temporary password for.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_ReissueAccountPassword(accountSlot: u8_, completionEvent: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the account password input for a specific account. This value is not stored in the save data and only resides in memory. Following up a call to this command with a call to ACTA_EnableAccountPasswordCache will lead to the account password cache being updated."]
    pub fn ACTA_SetAccountPasswordInput(
        accountSlot: u8_,
        passwordInput: *mut AccountPassword,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Uploads the Mii data of a specific account to the account server.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to upload the Mii for.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_UploadMii(accountSlot: u8_, completionEvent: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Inactivates the device association for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to inactive the device association for.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_InactivateDeviceAssociation(accountSlot: u8_, completionEvent: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Validates the email address of a specific account using the code received via the confirmation email.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to validate the email address for.\n * `confirmationCode` - The confirmation code received via email.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_ValidateMailAddress(
        accountSlot: u8_,
        confirmationCode: u32_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Requests parental approval for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to request parental approval for.\n * `parentalEmail` - Pointer to a parental email to use for parental consent.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_SendPostingApprovalMail(
        accountSlot: u8_,
        parentalEmail: *mut AccountMailAddress,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Requests the email address confirmation mail to be resent for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account for which the confirmation mail should be resent.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_SendConfirmationMail(accountSlot: u8_, completionEvent: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Registers a parental email address to be used in case the parental controls PIN has been forgotten for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to register the fallback parental email for.\n * `parentalEmail` - Pointer to the parental email to use.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_SendConfirmationMailForPin(
        accountSlot: u8_,
        parentalEmail: *mut AccountMailAddress,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sends the master key for resetting parental controls to a parental email for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number for the account to be used for this operation.\n * `masterKey` - The master key to send to the parental email address.\n * `parentalEmail` - Pointer to the parental email address to send the master key to.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_SendMasterKeyMailForPin(
        accountSlot: u8_,
        masterKey: u32_,
        parentalEmail: *mut AccountMailAddress,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Requests COPPA parental consent using credit card information.\n # Arguments\n\n* `accountSlot` - The account slot number for the account to request approval for.\n * `cardInfo` - Pointer to the credit card information to use for the approval process.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_ApproveByCreditCard(
        accountSlot: u8_,
        cardInfo: *mut CreditCardInfo,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Requests a COPPA code for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number for the account to send the request for.\n * `principalId` - The principalId of the account to send the request for.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_SendCoppaCodeMail(
        accountSlot: u8_,
        principalId: u32_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Set a flag in a specifc account's data that determines whether or not it is necessary to upload the account Mii data to the account server.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to set the flag for.\n * `isDirty` - Whether or not the Mii data should be reuploaded to the account server."]
    pub fn ACTA_SetIsMiiUpdated(accountSlot: u8_, isDirty: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes a server account transfer of a specific account to another device.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to transfer the server account of.\n * `newDevice` - Pointer to device info of the target device.\n * `operatorData` - Pointer to operator data for the transfer.\n * `operatorSize` - Size of the operator data buffer (max: 0x100)\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_ReserveTransfer(
        accountSlot: u8_,
        newDevice: *mut DeviceInfo,
        operatorData: *mut ::libc::c_char,
        operatorSize: u32_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Finalizes a server account transfer of a specifc account to another device.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to complete the transfer for.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_CompleteTransfer(accountSlot: u8_, completionEvent: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Inactivates the account-device association for a specific account. In other words, this deletes an NNID.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to perform this action on.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_InactivateAccountDeviceAssociation(
        accountSlot: u8_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Set the internal network time field.\n # Arguments\n\n* `timestamp` - The new server time timestamp to use. The timestamp format is milliseconds elapsed since 01.01.2000 00:00:00 UTC."]
    pub fn ACTA_SetNetworkTime(timestamp: s64) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates the account info of a specific account using raw XML data.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to update information for.\n * `xmlData` - Pointer to the input XML data.\n * `xmlDataSize` - Size of the input XML data.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_UpdateAccountInfo(
        accountSlot: u8_,
        xmlData: *mut ::libc::c_char,
        xmlDataSize: u32_,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates the email address of a specific account.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to update the email address for.\n * `newEmail` - Pointer to the new email address to use.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_UpdateAccountMailAddress(
        accountSlot: u8_,
        newEmail: *mut AccountMailAddress,
        completionEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes the device association for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot of the account to perform this action on.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_DeleteDeviceAssociation(accountSlot: u8_, completionEvent: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes the account-device association for a specific account.\n # Arguments\n\n* `accountSlot` - The account slot of the account to perform this action on.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_DeleteAccountDeviceAssociation(accountSlot: u8_, completionEvent: Handle)
    -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Cancels a pending server account transfer of a specific account to another device.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to cancel the transfer for.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_CancelTransfer(accountSlot: u8_, completionEvent: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Cancels any running HTTP requests, saves all pending changes to the system save data, then signals unloadFinishedEvent. Then, waits for remountAndBlockEvent, and once this has been signaled, remounts the system save, and blocks subsequent attempts to save the system save data (which can be bypassed by entering and exiting sleep mode).\n # Arguments\n\n* `unloadFinishedEvent` - The event handle for ACT to signal once it has saved pending changes and has unmounted its system save.\n * `remountAndBlockEvent` - The event handle for the caller to signal once ACT should remount its save data and block subsequent save attempts."]
    pub fn ACTA_ReloadAndBlockSaveData(
        unloadFinishedEvent: Handle,
        remountAndBlockEvent: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes server-side account deletion for a specific account. In other words, this deletes an NNID.\n # Arguments\n\n* `accountSlot` - The account slot number of the account to perform this action on.\n * `completionEvent` - The event handle to signal once the request has finished."]
    pub fn ACTA_ReserveServerAccountDeletion(accountSlot: u8_, completionEvent: Handle) -> Result;
}
#[doc = "< Open for reading."]
pub const FS_OPEN_READ: _bindgen_ty_11 = 1;
#[doc = "< Open for writing."]
pub const FS_OPEN_WRITE: _bindgen_ty_11 = 2;
#[doc = "< Create file."]
pub const FS_OPEN_CREATE: _bindgen_ty_11 = 4;
#[doc = "Open flags."]
pub type _bindgen_ty_11 = ::libc::c_uchar;
#[doc = "< Flush."]
pub const FS_WRITE_FLUSH: _bindgen_ty_12 = 1;
#[doc = "< Update file timestamp."]
pub const FS_WRITE_UPDATE_TIME: _bindgen_ty_12 = 256;
#[doc = "Write flags."]
pub type _bindgen_ty_12 = ::libc::c_ushort;
#[doc = "< Directory."]
pub const FS_ATTRIBUTE_DIRECTORY: _bindgen_ty_13 = 1;
#[doc = "< Hidden."]
pub const FS_ATTRIBUTE_HIDDEN: _bindgen_ty_13 = 256;
#[doc = "< Archive."]
pub const FS_ATTRIBUTE_ARCHIVE: _bindgen_ty_13 = 65536;
#[doc = "< Read-only."]
pub const FS_ATTRIBUTE_READ_ONLY: _bindgen_ty_13 = 16777216;
#[doc = "Attribute flags."]
pub type _bindgen_ty_13 = ::libc::c_uint;
#[doc = "< NAND."]
pub const MEDIATYPE_NAND: FS_MediaType = 0;
#[doc = "< SD card."]
pub const MEDIATYPE_SD: FS_MediaType = 1;
#[doc = "< Game card."]
pub const MEDIATYPE_GAME_CARD: FS_MediaType = 2;
#[doc = "Media types."]
pub type FS_MediaType = ::libc::c_uchar;
#[doc = "< CTR NAND."]
pub const SYSTEM_MEDIATYPE_CTR_NAND: FS_SystemMediaType = 0;
#[doc = "< TWL NAND."]
pub const SYSTEM_MEDIATYPE_TWL_NAND: FS_SystemMediaType = 1;
#[doc = "< SD card."]
pub const SYSTEM_MEDIATYPE_SD: FS_SystemMediaType = 2;
#[doc = "< TWL Photo."]
pub const SYSTEM_MEDIATYPE_TWL_PHOTO: FS_SystemMediaType = 3;
#[doc = "System media types."]
pub type FS_SystemMediaType = ::libc::c_uchar;
#[doc = "< RomFS archive."]
pub const ARCHIVE_ROMFS: FS_ArchiveID = 3;
#[doc = "< Save data archive."]
pub const ARCHIVE_SAVEDATA: FS_ArchiveID = 4;
#[doc = "< Ext data archive."]
pub const ARCHIVE_EXTDATA: FS_ArchiveID = 6;
#[doc = "< Shared ext data archive."]
pub const ARCHIVE_SHARED_EXTDATA: FS_ArchiveID = 7;
#[doc = "< System save data archive."]
pub const ARCHIVE_SYSTEM_SAVEDATA: FS_ArchiveID = 8;
#[doc = "< SDMC archive."]
pub const ARCHIVE_SDMC: FS_ArchiveID = 9;
#[doc = "< Write-only SDMC archive."]
pub const ARCHIVE_SDMC_WRITE_ONLY: FS_ArchiveID = 10;
#[doc = "< BOSS ext data archive."]
pub const ARCHIVE_BOSS_EXTDATA: FS_ArchiveID = 305419896;
#[doc = "< Card SPI FS archive."]
pub const ARCHIVE_CARD_SPIFS: FS_ArchiveID = 305419897;
#[doc = "< Ext data and BOSS ext data archive."]
pub const ARCHIVE_EXTDATA_AND_BOSS_EXTDATA: FS_ArchiveID = 305419899;
#[doc = "< System save data archive."]
pub const ARCHIVE_SYSTEM_SAVEDATA2: FS_ArchiveID = 305419900;
#[doc = "< Read-write NAND archive."]
pub const ARCHIVE_NAND_RW: FS_ArchiveID = 305419901;
#[doc = "< Read-only NAND archive."]
pub const ARCHIVE_NAND_RO: FS_ArchiveID = 305419902;
#[doc = "< Read-only write access NAND archive."]
pub const ARCHIVE_NAND_RO_WRITE_ACCESS: FS_ArchiveID = 305419903;
#[doc = "< User save data and ExeFS/RomFS archive."]
pub const ARCHIVE_SAVEDATA_AND_CONTENT: FS_ArchiveID = 591751050;
#[doc = "< User save data and ExeFS/RomFS archive (only ExeFS for fs:LDR)."]
pub const ARCHIVE_SAVEDATA_AND_CONTENT2: FS_ArchiveID = 591751054;
#[doc = "< NAND CTR FS archive."]
pub const ARCHIVE_NAND_CTR_FS: FS_ArchiveID = 1450741931;
#[doc = "< TWL PHOTO archive."]
pub const ARCHIVE_TWL_PHOTO: FS_ArchiveID = 1450741932;
#[doc = "< TWL SOUND archive."]
pub const ARCHIVE_TWL_SOUND: FS_ArchiveID = 1450741933;
#[doc = "< NAND TWL FS archive."]
pub const ARCHIVE_NAND_TWL_FS: FS_ArchiveID = 1450741934;
#[doc = "< NAND W FS archive."]
pub const ARCHIVE_NAND_W_FS: FS_ArchiveID = 1450741935;
#[doc = "< Game card save data archive."]
pub const ARCHIVE_GAMECARD_SAVEDATA: FS_ArchiveID = 1450741937;
#[doc = "< User save data archive."]
pub const ARCHIVE_USER_SAVEDATA: FS_ArchiveID = 1450741938;
#[doc = "< Demo save data archive."]
pub const ARCHIVE_DEMO_SAVEDATA: FS_ArchiveID = 1450741940;
#[doc = "Archive IDs."]
pub type FS_ArchiveID = ::libc::c_uint;
#[doc = "< Invalid path."]
pub const PATH_INVALID: FS_PathType = 0;
#[doc = "< Empty path."]
pub const PATH_EMPTY: FS_PathType = 1;
#[doc = "< Binary path. Meaning is per-archive."]
pub const PATH_BINARY: FS_PathType = 2;
#[doc = "< ASCII text path."]
pub const PATH_ASCII: FS_PathType = 3;
#[doc = "< UTF-16 text path."]
pub const PATH_UTF16: FS_PathType = 4;
#[doc = "Path types."]
pub type FS_PathType = ::libc::c_uchar;
#[doc = "< SD application."]
pub const SECUREVALUE_SLOT_SD: FS_SecureValueSlot = 4096;
#[doc = "Secure value slot."]
pub type FS_SecureValueSlot = ::libc::c_ushort;
#[doc = "< 512KHz."]
pub const BAUDRATE_512KHZ: FS_CardSpiBaudRate = 0;
#[doc = "< 1MHz."]
pub const BAUDRATE_1MHZ: FS_CardSpiBaudRate = 1;
#[doc = "< 2MHz."]
pub const BAUDRATE_2MHZ: FS_CardSpiBaudRate = 2;
#[doc = "< 4MHz."]
pub const BAUDRATE_4MHZ: FS_CardSpiBaudRate = 3;
#[doc = "< 8MHz."]
pub const BAUDRATE_8MHZ: FS_CardSpiBaudRate = 4;
#[doc = "< 16MHz."]
pub const BAUDRATE_16MHZ: FS_CardSpiBaudRate = 5;
#[doc = "Card SPI baud rate."]
pub type FS_CardSpiBaudRate = ::libc::c_uchar;
#[doc = "< 1-bit."]
pub const BUSMODE_1BIT: FS_CardSpiBusMode = 0;
#[doc = "< 4-bit."]
pub const BUSMODE_4BIT: FS_CardSpiBusMode = 1;
#[doc = "Card SPI bus mode."]
pub type FS_CardSpiBusMode = ::libc::c_uchar;
#[doc = "< Update."]
pub const SPECIALCONTENT_UPDATE: FS_SpecialContentType = 1;
#[doc = "< Manual."]
pub const SPECIALCONTENT_MANUAL: FS_SpecialContentType = 2;
#[doc = "< DLP child."]
pub const SPECIALCONTENT_DLP_CHILD: FS_SpecialContentType = 3;
#[doc = "Card SPI bus mode."]
pub type FS_SpecialContentType = ::libc::c_uchar;
#[doc = "< CTR card."]
pub const CARD_CTR: FS_CardType = 0;
#[doc = "< TWL card."]
pub const CARD_TWL: FS_CardType = 1;
pub type FS_CardType = ::libc::c_uchar;
pub const FS_ACTION_UNKNOWN: FS_Action = 0;
#[doc = "FS control actions."]
pub type FS_Action = ::libc::c_uchar;
#[doc = "< Commits save data changes. No inputs/outputs."]
pub const ARCHIVE_ACTION_COMMIT_SAVE_DATA: FS_ArchiveAction = 0;
#[doc = "< Retrieves a file's last-modified timestamp. In: \"u16*, UTF-16 Path\", Out: \"u64, Time Stamp\"."]
pub const ARCHIVE_ACTION_GET_TIMESTAMP: FS_ArchiveAction = 1;
pub const ARCHIVE_ACTION_UNKNOWN: FS_ArchiveAction = 30877;
#[doc = "Archive control actions."]
pub type FS_ArchiveAction = ::libc::c_ushort;
#[doc = "< Deletes a save's secure value. In: \"u64, ((SecureValueSlot << 32) | (TitleUniqueId << 8) | TitleVariation)\", Out: \"u8, Value Existed\""]
pub const SECURESAVE_ACTION_DELETE: FS_SecureSaveAction = 0;
#[doc = "< Formats a save. No inputs/outputs."]
pub const SECURESAVE_ACTION_FORMAT: FS_SecureSaveAction = 1;
#[doc = "Secure save control actions."]
pub type FS_SecureSaveAction = ::libc::c_uchar;
pub const FILE_ACTION_UNKNOWN: FS_FileAction = 0;
#[doc = "File control actions."]
pub type FS_FileAction = ::libc::c_uchar;
pub const DIRECTORY_ACTION_UNKNOWN: FS_DirectoryAction = 0;
#[doc = "Directory control actions."]
pub type FS_DirectoryAction = ::libc::c_uchar;
#[doc = "Directory entry."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_DirectoryEntry {
    #[doc = "< UTF-16 directory name."]
    pub name: [u16_; 262usize],
    #[doc = "< File name."]
    pub shortName: [::libc::c_char; 10usize],
    #[doc = "< File extension."]
    pub shortExt: [::libc::c_char; 4usize],
    #[doc = "< Valid flag. (Always 1)"]
    pub valid: u8_,
    #[doc = "< Reserved."]
    pub reserved: u8_,
    #[doc = "< Attributes."]
    pub attributes: u32_,
    #[doc = "< File size."]
    pub fileSize: u64_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FS_DirectoryEntry"][::core::mem::size_of::<FS_DirectoryEntry>() - 552usize];
    ["Alignment of FS_DirectoryEntry"][::core::mem::align_of::<FS_DirectoryEntry>() - 8usize];
    ["Offset of field: FS_DirectoryEntry::name"]
        [::core::mem::offset_of!(FS_DirectoryEntry, name) - 0usize];
    ["Offset of field: FS_DirectoryEntry::shortName"]
        [::core::mem::offset_of!(FS_DirectoryEntry, shortName) - 524usize];
    ["Offset of field: FS_DirectoryEntry::shortExt"]
        [::core::mem::offset_of!(FS_DirectoryEntry, shortExt) - 534usize];
    ["Offset of field: FS_DirectoryEntry::valid"]
        [::core::mem::offset_of!(FS_DirectoryEntry, valid) - 538usize];
    ["Offset of field: FS_DirectoryEntry::reserved"]
        [::core::mem::offset_of!(FS_DirectoryEntry, reserved) - 539usize];
    ["Offset of field: FS_DirectoryEntry::attributes"]
        [::core::mem::offset_of!(FS_DirectoryEntry, attributes) - 540usize];
    ["Offset of field: FS_DirectoryEntry::fileSize"]
        [::core::mem::offset_of!(FS_DirectoryEntry, fileSize) - 544usize];
};
impl Default for FS_DirectoryEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Archive resource information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FS_ArchiveResource {
    #[doc = "< Size of each sector, in bytes."]
    pub sectorSize: u32_,
    #[doc = "< Size of each cluster, in bytes."]
    pub clusterSize: u32_,
    #[doc = "< Total number of clusters."]
    pub totalClusters: u32_,
    #[doc = "< Number of free clusters."]
    pub freeClusters: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FS_ArchiveResource"][::core::mem::size_of::<FS_ArchiveResource>() - 16usize];
    ["Alignment of FS_ArchiveResource"][::core::mem::align_of::<FS_ArchiveResource>() - 4usize];
    ["Offset of field: FS_ArchiveResource::sectorSize"]
        [::core::mem::offset_of!(FS_ArchiveResource, sectorSize) - 0usize];
    ["Offset of field: FS_ArchiveResource::clusterSize"]
        [::core::mem::offset_of!(FS_ArchiveResource, clusterSize) - 4usize];
    ["Offset of field: FS_ArchiveResource::totalClusters"]
        [::core::mem::offset_of!(FS_ArchiveResource, totalClusters) - 8usize];
    ["Offset of field: FS_ArchiveResource::freeClusters"]
        [::core::mem::offset_of!(FS_ArchiveResource, freeClusters) - 12usize];
};
#[doc = "Program information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_ProgramInfo {
    #[doc = "< Program ID."]
    pub programId: u64_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Padding."]
    pub padding: [u8_; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FS_ProgramInfo"][::core::mem::size_of::<FS_ProgramInfo>() - 16usize];
    ["Alignment of FS_ProgramInfo"][::core::mem::align_of::<FS_ProgramInfo>() - 8usize];
    ["Offset of field: FS_ProgramInfo::programId"]
        [::core::mem::offset_of!(FS_ProgramInfo, programId) - 0usize];
    ["Offset of field: FS_ProgramInfo::padding"]
        [::core::mem::offset_of!(FS_ProgramInfo, padding) - 9usize];
};
impl Default for FS_ProgramInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FS_ProgramInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mediaType_raw(this: *const Self) -> FS_MediaType {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mediaType_raw(this: *mut Self, val: FS_MediaType) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u8 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Product information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FS_ProductInfo {
    #[doc = "< Product code."]
    pub productCode: [::libc::c_char; 16usize],
    #[doc = "< Company code."]
    pub companyCode: [::libc::c_char; 2usize],
    #[doc = "< Remaster version."]
    pub remasterVersion: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FS_ProductInfo"][::core::mem::size_of::<FS_ProductInfo>() - 20usize];
    ["Alignment of FS_ProductInfo"][::core::mem::align_of::<FS_ProductInfo>() - 2usize];
    ["Offset of field: FS_ProductInfo::productCode"]
        [::core::mem::offset_of!(FS_ProductInfo, productCode) - 0usize];
    ["Offset of field: FS_ProductInfo::companyCode"]
        [::core::mem::offset_of!(FS_ProductInfo, companyCode) - 16usize];
    ["Offset of field: FS_ProductInfo::remasterVersion"]
        [::core::mem::offset_of!(FS_ProductInfo, remasterVersion) - 18usize];
};
#[doc = "Integrity verification seed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_IntegrityVerificationSeed {
    #[doc = "< AES-CBC MAC over a SHA256 hash, which hashes the first 0x110-bytes of the cleartext SEED."]
    pub aesCbcMac: [u8_; 16usize],
    #[doc = "< The \"nand/private/movable.sed\", encrypted with AES-CTR using the above MAC for the counter."]
    pub movableSed: [u8_; 288usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FS_IntegrityVerificationSeed"]
        [::core::mem::size_of::<FS_IntegrityVerificationSeed>() - 304usize];
    ["Alignment of FS_IntegrityVerificationSeed"]
        [::core::mem::align_of::<FS_IntegrityVerificationSeed>() - 1usize];
    ["Offset of field: FS_IntegrityVerificationSeed::aesCbcMac"]
        [::core::mem::offset_of!(FS_IntegrityVerificationSeed, aesCbcMac) - 0usize];
    ["Offset of field: FS_IntegrityVerificationSeed::movableSed"]
        [::core::mem::offset_of!(FS_IntegrityVerificationSeed, movableSed) - 16usize];
};
impl Default for FS_IntegrityVerificationSeed {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Ext save data information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FS_ExtSaveDataInfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Unknown."]
    pub unknown: u8_,
    #[doc = "< Reserved."]
    pub reserved1: u16_,
    #[doc = "< Save ID."]
    pub saveId: u64_,
    #[doc = "< Reserved."]
    pub reserved2: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FS_ExtSaveDataInfo"][::core::mem::size_of::<FS_ExtSaveDataInfo>() - 16usize];
    ["Alignment of FS_ExtSaveDataInfo"][::core::mem::align_of::<FS_ExtSaveDataInfo>() - 1usize];
    ["Offset of field: FS_ExtSaveDataInfo::unknown"]
        [::core::mem::offset_of!(FS_ExtSaveDataInfo, unknown) - 1usize];
    ["Offset of field: FS_ExtSaveDataInfo::reserved1"]
        [::core::mem::offset_of!(FS_ExtSaveDataInfo, reserved1) - 2usize];
    ["Offset of field: FS_ExtSaveDataInfo::saveId"]
        [::core::mem::offset_of!(FS_ExtSaveDataInfo, saveId) - 4usize];
    ["Offset of field: FS_ExtSaveDataInfo::reserved2"]
        [::core::mem::offset_of!(FS_ExtSaveDataInfo, reserved2) - 12usize];
};
impl Default for FS_ExtSaveDataInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FS_ExtSaveDataInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mediaType_raw(this: *const Self) -> FS_MediaType {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mediaType_raw(this: *mut Self, val: FS_MediaType) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u8 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "System save data information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_SystemSaveDataInfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Unknown."]
    pub unknown: u8_,
    #[doc = "< Reserved."]
    pub reserved: u16_,
    #[doc = "< Save ID."]
    pub saveId: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FS_SystemSaveDataInfo"][::core::mem::size_of::<FS_SystemSaveDataInfo>() - 8usize];
    ["Alignment of FS_SystemSaveDataInfo"]
        [::core::mem::align_of::<FS_SystemSaveDataInfo>() - 4usize];
    ["Offset of field: FS_SystemSaveDataInfo::unknown"]
        [::core::mem::offset_of!(FS_SystemSaveDataInfo, unknown) - 1usize];
    ["Offset of field: FS_SystemSaveDataInfo::reserved"]
        [::core::mem::offset_of!(FS_SystemSaveDataInfo, reserved) - 2usize];
    ["Offset of field: FS_SystemSaveDataInfo::saveId"]
        [::core::mem::offset_of!(FS_SystemSaveDataInfo, saveId) - 4usize];
};
impl Default for FS_SystemSaveDataInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FS_SystemSaveDataInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mediaType_raw(this: *const Self) -> FS_MediaType {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mediaType_raw(this: *mut Self, val: FS_MediaType) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u8 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Device move context."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FS_DeviceMoveContext {
    #[doc = "< IVs."]
    pub ivs: [u8_; 16usize],
    #[doc = "< Encrypt parameter."]
    pub encryptParameter: [u8_; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FS_DeviceMoveContext"][::core::mem::size_of::<FS_DeviceMoveContext>() - 32usize];
    ["Alignment of FS_DeviceMoveContext"][::core::mem::align_of::<FS_DeviceMoveContext>() - 1usize];
    ["Offset of field: FS_DeviceMoveContext::ivs"]
        [::core::mem::offset_of!(FS_DeviceMoveContext, ivs) - 0usize];
    ["Offset of field: FS_DeviceMoveContext::encryptParameter"]
        [::core::mem::offset_of!(FS_DeviceMoveContext, encryptParameter) - 16usize];
};
#[doc = "Filesystem path data, detailing the specific target of an operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_Path {
    #[doc = "< FS path type."]
    pub type_: FS_PathType,
    #[doc = "< FS path size."]
    pub size: u32_,
    #[doc = "< Pointer to FS path data."]
    pub data: *const ::libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FS_Path"][::core::mem::size_of::<FS_Path>() - 12usize];
    ["Alignment of FS_Path"][::core::mem::align_of::<FS_Path>() - 4usize];
    ["Offset of field: FS_Path::type_"][::core::mem::offset_of!(FS_Path, type_) - 0usize];
    ["Offset of field: FS_Path::size"][::core::mem::offset_of!(FS_Path, size) - 4usize];
    ["Offset of field: FS_Path::data"][::core::mem::offset_of!(FS_Path, data) - 8usize];
};
impl Default for FS_Path {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "SDMC/NAND speed information"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FS_SdMmcSpeedInfo {
    #[doc = "< Whether or not High Speed Mode is enabled."]
    pub highSpeedModeEnabled: bool,
    #[doc = "< Whether or not a clock divider of 2 is being used."]
    pub usesHighestClockRate: bool,
    #[doc = "< The value of the SD_CLK_CTRL register."]
    pub sdClkCtrl: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FS_SdMmcSpeedInfo"][::core::mem::size_of::<FS_SdMmcSpeedInfo>() - 4usize];
    ["Alignment of FS_SdMmcSpeedInfo"][::core::mem::align_of::<FS_SdMmcSpeedInfo>() - 2usize];
    ["Offset of field: FS_SdMmcSpeedInfo::highSpeedModeEnabled"]
        [::core::mem::offset_of!(FS_SdMmcSpeedInfo, highSpeedModeEnabled) - 0usize];
    ["Offset of field: FS_SdMmcSpeedInfo::usesHighestClockRate"]
        [::core::mem::offset_of!(FS_SdMmcSpeedInfo, usesHighestClockRate) - 1usize];
    ["Offset of field: FS_SdMmcSpeedInfo::sdClkCtrl"]
        [::core::mem::offset_of!(FS_SdMmcSpeedInfo, sdClkCtrl) - 2usize];
};
#[doc = "Filesystem archive handle, providing access to a filesystem's contents."]
pub type FS_Archive = u64_;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes FS."]
    pub fn fsInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits FS."]
    pub fn fsExit();
}
unsafe extern "C" {
    #[doc = "Sets the FSUSER session to use in the current thread.\n # Arguments\n\n* `session` - The handle of the FSUSER session to use."]
    pub fn fsUseSession(session: Handle);
}
unsafe extern "C" {
    #[doc = "Disables the FSUSER session override in the current thread."]
    pub fn fsEndUseSession();
}
unsafe extern "C" {
    #[doc = "Exempts an archive from using alternate FS session handles provided with fsUseSession\n Instead, the archive will use the default FS session handle, opened with srvGetSessionHandle\n # Arguments\n\n* `archive` - Archive to exempt."]
    pub fn fsExemptFromSession(archive: FS_Archive);
}
unsafe extern "C" {
    #[doc = "Unexempts an archive from using alternate FS session handles provided with fsUseSession\n # Arguments\n\n* `archive` - Archive to remove from the exemption list."]
    pub fn fsUnexemptFromSession(archive: FS_Archive);
}
unsafe extern "C" {
    #[doc = "Creates an FS_Path instance.\n # Arguments\n\n* `type` - Type of path.\n * `path` - Path to use.\n # Returns\n\nThe created FS_Path instance."]
    pub fn fsMakePath(type_: FS_PathType, path: *const ::libc::c_void) -> FS_Path;
}
unsafe extern "C" {
    #[doc = "Gets the current FS session handle.\n # Returns\n\nThe current FS session handle."]
    pub fn fsGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on the filesystem.\n # Arguments\n\n* `action` - Action to perform.\n * `input` - Buffer to read input from.\n * `inputSize` - Size of the input.\n * `output` - Buffer to write output to.\n * `outputSize` - Size of the output."]
    pub fn FSUSER_Control(
        action: FS_Action,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes a FSUSER session.\n # Arguments\n\n* `session` - The handle of the FSUSER session to initialize."]
    pub fn FSUSER_Initialize(session: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens a file.\n # Arguments\n\n* `out` - Pointer to output the file handle to.\n * `archive` - Archive containing the file.\n * `path` - Path of the file.\n * `openFlags` - Flags to open the file with.\n * `attributes` - Attributes of the file."]
    pub fn FSUSER_OpenFile(
        out: *mut Handle,
        archive: FS_Archive,
        path: FS_Path,
        openFlags: u32_,
        attributes: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens a file directly, bypassing the requirement of an opened archive handle.\n # Arguments\n\n* `out` - Pointer to output the file handle to.\n * `archiveId` - ID of the archive containing the file.\n * `archivePath` - Path of the archive containing the file.\n * `filePath` - Path of the file.\n * `openFlags` - Flags to open the file with.\n * `attributes` - Attributes of the file."]
    pub fn FSUSER_OpenFileDirectly(
        out: *mut Handle,
        archiveId: FS_ArchiveID,
        archivePath: FS_Path,
        filePath: FS_Path,
        openFlags: u32_,
        attributes: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes a file.\n # Arguments\n\n* `archive` - Archive containing the file.\n * `path` - Path of the file."]
    pub fn FSUSER_DeleteFile(archive: FS_Archive, path: FS_Path) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Renames a file.\n # Arguments\n\n* `srcArchive` - Archive containing the source file.\n * `srcPath` - Path of the source file.\n * `dstArchive` - Archive containing the destination file.\n * `dstPath` - Path of the destination file."]
    pub fn FSUSER_RenameFile(
        srcArchive: FS_Archive,
        srcPath: FS_Path,
        dstArchive: FS_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes a directory, failing if it is not empty.\n # Arguments\n\n* `archive` - Archive containing the directory.\n * `path` - Path of the directory."]
    pub fn FSUSER_DeleteDirectory(archive: FS_Archive, path: FS_Path) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes a directory, also deleting its contents.\n # Arguments\n\n* `archive` - Archive containing the directory.\n * `path` - Path of the directory."]
    pub fn FSUSER_DeleteDirectoryRecursively(archive: FS_Archive, path: FS_Path) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a file.\n # Arguments\n\n* `archive` - Archive to create the file in.\n * `path` - Path of the file.\n * `attributes` - Attributes of the file.\n * `fileSize` - Size of the file."]
    pub fn FSUSER_CreateFile(
        archive: FS_Archive,
        path: FS_Path,
        attributes: u32_,
        fileSize: u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a directory\n # Arguments\n\n* `archive` - Archive to create the directory in.\n * `path` - Path of the directory.\n * `attributes` - Attributes of the directory."]
    pub fn FSUSER_CreateDirectory(archive: FS_Archive, path: FS_Path, attributes: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Renames a directory.\n # Arguments\n\n* `srcArchive` - Archive containing the source directory.\n * `srcPath` - Path of the source directory.\n * `dstArchive` - Archive containing the destination directory.\n * `dstPath` - Path of the destination directory."]
    pub fn FSUSER_RenameDirectory(
        srcArchive: FS_Archive,
        srcPath: FS_Path,
        dstArchive: FS_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens a directory.\n # Arguments\n\n* `out` - Pointer to output the directory handle to.\n * `archive` - Archive containing the directory.\n * `path` - Path of the directory."]
    pub fn FSUSER_OpenDirectory(out: *mut Handle, archive: FS_Archive, path: FS_Path) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens an archive.\n # Arguments\n\n* `archive` - Pointer to output the opened archive to.\n * `id` - ID of the archive.\n * `path` - Path of the archive."]
    pub fn FSUSER_OpenArchive(archive: *mut FS_Archive, id: FS_ArchiveID, path: FS_Path) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on an archive.\n # Arguments\n\n* `archive` - Archive to control.\n * `action` - Action to perform.\n * `input` - Buffer to read input from.\n * `inputSize` - Size of the input.\n * `output` - Buffer to write output to.\n * `outputSize` - Size of the output."]
    pub fn FSUSER_ControlArchive(
        archive: FS_Archive,
        action: FS_ArchiveAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Closes an archive.\n # Arguments\n\n* `archive` - Archive to close."]
    pub fn FSUSER_CloseArchive(archive: FS_Archive) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the number of free bytes within an archive.\n # Arguments\n\n* `freeBytes` - Pointer to output the free bytes to.\n * `archive` - Archive to check."]
    pub fn FSUSER_GetFreeBytes(freeBytes: *mut u64_, archive: FS_Archive) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the inserted card type.\n # Arguments\n\n* `type` - Pointer to output the card type to."]
    pub fn FSUSER_GetCardType(type_: *mut FS_CardType) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC archive resource information.\n # Arguments\n\n* `archiveResource` - Pointer to output the archive resource information to."]
    pub fn FSUSER_GetSdmcArchiveResource(archiveResource: *mut FS_ArchiveResource) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the NAND archive resource information.\n # Arguments\n\n* `archiveResource` - Pointer to output the archive resource information to."]
    pub fn FSUSER_GetNandArchiveResource(archiveResource: *mut FS_ArchiveResource) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the last SDMC fatfs error.\n # Arguments\n\n* `error` - Pointer to output the error to."]
    pub fn FSUSER_GetSdmcFatfsError(error: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether an SD card is detected.\n # Arguments\n\n* `detected` - Pointer to output the detection status to."]
    pub fn FSUSER_IsSdmcDetected(detected: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether the SD card is writable.\n # Arguments\n\n* `writable` - Pointer to output the writable status to."]
    pub fn FSUSER_IsSdmcWritable(writable: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC CID.\n # Arguments\n\n* `out` - Pointer to output the CID to.\n * `length` - Length of the CID buffer. (should be 0x10)"]
    pub fn FSUSER_GetSdmcCid(out: *mut u8_, length: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the NAND CID.\n # Arguments\n\n* `out` - Pointer to output the CID to.\n * `length` - Length of the CID buffer. (should be 0x10)"]
    pub fn FSUSER_GetNandCid(out: *mut u8_, length: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC speed info.\n # Arguments\n\n* `speedInfo` - Pointer to output the speed info to."]
    pub fn FSUSER_GetSdmcSpeedInfo(speedInfo: *mut FS_SdMmcSpeedInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the NAND speed info.\n # Arguments\n\n* `speedInfo` - Pointer to output the speed info to."]
    pub fn FSUSER_GetNandSpeedInfo(speedInfo: *mut FS_SdMmcSpeedInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC log.\n # Arguments\n\n* `out` - Pointer to output the log to.\n * `length` - Length of the log buffer."]
    pub fn FSUSER_GetSdmcLog(out: *mut u8_, length: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the NAND log.\n # Arguments\n\n* `out` - Pointer to output the log to.\n * `length` - Length of the log buffer."]
    pub fn FSUSER_GetNandLog(out: *mut u8_, length: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Clears the SDMC log."]
    pub fn FSUSER_ClearSdmcLog() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Clears the NAND log."]
    pub fn FSUSER_ClearNandLog() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether a card is inserted.\n # Arguments\n\n* `inserted` - Pointer to output the insertion status to."]
    pub fn FSUSER_CardSlotIsInserted(inserted: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Powers on the card slot.\n # Arguments\n\n* `status` - Pointer to output the power status to."]
    pub fn FSUSER_CardSlotPowerOn(status: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Powers off the card slot.\n # Arguments\n\n* `status` - Pointer to output the power status to."]
    pub fn FSUSER_CardSlotPowerOff(status: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the card's power status.\n # Arguments\n\n* `status` - Pointer to output the power status to."]
    pub fn FSUSER_CardSlotGetCardIFPowerStatus(status: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct command.\n # Arguments\n\n* `commandId` - ID of the command."]
    pub fn FSUSER_CardNorDirectCommand(commandId: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct command with an address.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide."]
    pub fn FSUSER_CardNorDirectCommandWithAddress(commandId: u8_, address: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct read.\n # Arguments\n\n* `commandId` - ID of the command.\n * `size` - Size of the output buffer.\n * `output` - Output buffer."]
    pub fn FSUSER_CardNorDirectRead(
        commandId: u8_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct read with an address.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide.\n * `size` - Size of the output buffer.\n * `output` - Output buffer."]
    pub fn FSUSER_CardNorDirectReadWithAddress(
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct write.\n # Arguments\n\n* `commandId` - ID of the command.\n * `size` - Size of the input buffer.\n * `output` - Input buffer."]
    pub fn FSUSER_CardNorDirectWrite(
        commandId: u8_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct write with an address.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide.\n * `size` - Size of the input buffer.\n * `input` - Input buffer."]
    pub fn FSUSER_CardNorDirectWriteWithAddress(
        commandId: u8_,
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR 4xIO direct read.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide.\n * `size` - Size of the output buffer.\n * `output` - Output buffer."]
    pub fn FSUSER_CardNorDirectRead_4xIO(
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct CPU write without verify.\n # Arguments\n\n* `address` - Address to provide.\n * `size` - Size of the input buffer.\n * `output` - Input buffer."]
    pub fn FSUSER_CardNorDirectCpuWriteWithoutVerify(
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct sector erase without verify.\n # Arguments\n\n* `address` - Address to provide."]
    pub fn FSUSER_CardNorDirectSectorEraseWithoutVerify(address: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a process's product info.\n # Arguments\n\n* `info` - Pointer to output the product info to.\n * `processId` - ID of the process."]
    pub fn FSUSER_GetProductInfo(info: *mut FS_ProductInfo, processId: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a process's program launch info.\n # Arguments\n\n* `info` - Pointer to output the program launch info to.\n * `processId` - ID of the process."]
    pub fn FSUSER_GetProgramLaunchInfo(info: *mut FS_ProgramInfo, processId: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the CARDSPI baud rate.\n # Arguments\n\n* `baudRate` - Baud rate to set."]
    pub fn FSUSER_SetCardSpiBaudRate(baudRate: FS_CardSpiBaudRate) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the CARDSPI bus mode.\n # Arguments\n\n* `busMode` - Bus mode to set."]
    pub fn FSUSER_SetCardSpiBusMode(busMode: FS_CardSpiBusMode) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sends initialization info to ARM9."]
    pub fn FSUSER_SendInitializeInfoTo9() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a special content's index.\n # Arguments\n\n* `index` - Pointer to output the index to.\n * `mediaType` - Media type of the special content.\n * `programId` - Program ID owning the special content.\n * `type` - Type of special content."]
    pub fn FSUSER_GetSpecialContentIndex(
        index: *mut u16_,
        mediaType: FS_MediaType,
        programId: u64_,
        type_: FS_SpecialContentType,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the legacy ROM header of a program.\n # Arguments\n\n* `mediaType` - Media type of the program.\n * `programId` - ID of the program.\n * `header` - Pointer to output the legacy ROM header to. (size = 0x3B4)"]
    pub fn FSUSER_GetLegacyRomHeader(
        mediaType: FS_MediaType,
        programId: u64_,
        header: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the legacy banner data of a program.\n # Arguments\n\n* `mediaType` - Media type of the program.\n * `programId` - ID of the program.\n * `banner` - Pointer to output the legacy banner data to. (size = 0x23C0)"]
    pub fn FSUSER_GetLegacyBannerData(
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks a process's authority to access a save data archive.\n # Arguments\n\n* `access` - Pointer to output the access status to.\n * `mediaType` - Media type of the save data.\n * `saveId` - ID of the save data.\n * `processId` - ID of the process to check."]
    pub fn FSUSER_CheckAuthorityToAccessExtSaveData(
        access: *mut bool,
        mediaType: FS_MediaType,
        saveId: u64_,
        processId: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Queries the total quota size of a save data archive.\n # Arguments\n\n* `quotaSize` - Pointer to output the quota size to.\n * `directories` - Number of directories.\n * `files` - Number of files.\n * `fileSizeCount` - Number of file sizes to provide.\n * `fileSizes` - File sizes to provide."]
    pub fn FSUSER_QueryTotalQuotaSize(
        quotaSize: *mut u64_,
        directories: u32_,
        files: u32_,
        fileSizeCount: u32_,
        fileSizes: *mut u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Abnegates an access right.\n # Arguments\n\n* `accessRight` - Access right to abnegate."]
    pub fn FSUSER_AbnegateAccessRight(accessRight: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes the 3DS SDMC root."]
    pub fn FSUSER_DeleteSdmcRoot() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes all ext save data on the NAND."]
    pub fn FSUSER_DeleteAllExtSaveDataOnNand() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the CTR file system."]
    pub fn FSUSER_InitializeCtrFileSystem() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates the FS seed."]
    pub fn FSUSER_CreateSeed() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrieves archive format info.\n # Arguments\n\n* `totalSize` - Pointer to output the total size to.\n * `directories` - Pointer to output the number of directories to.\n * `files` - Pointer to output the number of files to.\n * `duplicateData` - Pointer to output whether to duplicate data to.\n * `archiveId` - ID of the archive.\n * `path` - Path of the archive."]
    pub fn FSUSER_GetFormatInfo(
        totalSize: *mut u32_,
        directories: *mut u32_,
        files: *mut u32_,
        duplicateData: *mut bool,
        archiveId: FS_ArchiveID,
        path: FS_Path,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the legacy ROM header of a program.\n # Arguments\n\n* `headerSize` - Size of the ROM header.\n * `mediaType` - Media type of the program.\n * `programId` - ID of the program.\n * `header` - Pointer to output the legacy ROM header to."]
    pub fn FSUSER_GetLegacyRomHeader2(
        headerSize: u32_,
        mediaType: FS_MediaType,
        programId: u64_,
        header: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the CTR SDMC root path.\n # Arguments\n\n* `out` - Pointer to output the root path to.\n * `length` - Length of the output buffer."]
    pub fn FSUSER_GetSdmcCtrRootPath(out: *mut u8_, length: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets an archive's resource information.\n # Arguments\n\n* `archiveResource` - Pointer to output the archive resource information to.\n * `mediaType` - System media type to check."]
    pub fn FSUSER_GetArchiveResource(
        archiveResource: *mut FS_ArchiveResource,
        mediaType: FS_SystemMediaType,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Exports the integrity verification seed.\n # Arguments\n\n* `seed` - Pointer to output the seed to."]
    pub fn FSUSER_ExportIntegrityVerificationSeed(
        seed: *mut FS_IntegrityVerificationSeed,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Imports an integrity verification seed.\n # Arguments\n\n* `seed` - Seed to import."]
    pub fn FSUSER_ImportIntegrityVerificationSeed(
        seed: *mut FS_IntegrityVerificationSeed,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Formats save data.\n # Arguments\n\n* `archiveId` - ID of the save data archive.\n * `path` - Path of the save data.\n * `blocks` - Size of the save data in blocks. (512 bytes)\n * `directories` - Number of directories.\n * `files` - Number of files.\n * `directoryBuckets` - Directory hash tree bucket count.\n * `fileBuckets` - File hash tree bucket count.\n * `duplicateData` - Whether to store an internal duplicate of the data."]
    pub fn FSUSER_FormatSaveData(
        archiveId: FS_ArchiveID,
        path: FS_Path,
        blocks: u32_,
        directories: u32_,
        files: u32_,
        directoryBuckets: u32_,
        fileBuckets: u32_,
        duplicateData: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the legacy sub banner data of a program.\n # Arguments\n\n* `bannerSize` - Size of the banner.\n * `mediaType` - Media type of the program.\n * `programId` - ID of the program.\n * `header` - Pointer to output the legacy sub banner data to."]
    pub fn FSUSER_GetLegacySubBannerData(
        bannerSize: u32_,
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Hashes the given data and outputs a SHA256 hash.\n # Arguments\n\n* `data` - Pointer to the data to be hashed.\n * `inputSize` - The size of the data.\n * `hash` - Hash output pointer."]
    pub fn FSUSER_UpdateSha256Context(
        data: *const ::libc::c_void,
        inputSize: u32_,
        hash: *mut u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads from a special file.\n # Arguments\n\n* `bytesRead` - Pointer to output the number of bytes read to.\n * `fileOffset` - Offset of the file.\n * `size` - Size of the buffer.\n * `data` - Buffer to read to."]
    pub fn FSUSER_ReadSpecialFile(
        bytesRead: *mut u32_,
        fileOffset: u64_,
        size: u32_,
        data: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the size of a special file.\n # Arguments\n\n* `fileSize` - Pointer to output the size to."]
    pub fn FSUSER_GetSpecialFileSize(fileSize: *mut u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates ext save data.\n # Arguments\n\n* `info` - Info of the save data.\n * `directories` - Number of directories.\n * `files` - Number of files.\n * `sizeLimit` - Size limit of the save data.\n * `smdhSize` - Size of the save data's SMDH data.\n * `smdh` - SMDH data."]
    pub fn FSUSER_CreateExtSaveData(
        info: FS_ExtSaveDataInfo,
        directories: u32_,
        files: u32_,
        sizeLimit: u64_,
        smdhSize: u32_,
        smdh: *mut u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes ext save data.\n # Arguments\n\n* `info` - Info of the save data."]
    pub fn FSUSER_DeleteExtSaveData(info: FS_ExtSaveDataInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads the SMDH icon of ext save data.\n # Arguments\n\n* `bytesRead` - Pointer to output the number of bytes read to.\n * `info` - Info of the save data.\n * `smdhSize` - Size of the save data SMDH.\n * `smdh` - Pointer to output SMDH data to."]
    pub fn FSUSER_ReadExtSaveDataIcon(
        bytesRead: *mut u32_,
        info: FS_ExtSaveDataInfo,
        smdhSize: u32_,
        smdh: *mut u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets an ext data archive's block information.\n # Arguments\n\n* `totalBlocks` - Pointer to output the total blocks to.\n * `freeBlocks` - Pointer to output the free blocks to.\n * `blockSize` - Pointer to output the block size to.\n * `info` - Info of the save data."]
    pub fn FSUSER_GetExtDataBlockSize(
        totalBlocks: *mut u64_,
        freeBlocks: *mut u64_,
        blockSize: *mut u32_,
        info: FS_ExtSaveDataInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Enumerates ext save data.\n # Arguments\n\n* `idsWritten` - Pointer to output the number of IDs written to.\n * `idsSize` - Size of the IDs buffer.\n * `mediaType` - Media type to enumerate over.\n * `idSize` - Size of each ID element.\n * `shared` - Whether to enumerate shared ext save data.\n * `ids` - Pointer to output IDs to."]
    pub fn FSUSER_EnumerateExtSaveData(
        idsWritten: *mut u32_,
        idsSize: u32_,
        mediaType: FS_MediaType,
        idSize: u32_,
        shared: bool,
        ids: *mut u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates system save data.\n # Arguments\n\n* `info` - Info of the save data.\n * `totalSize` - Total size of the save data.\n * `blockSize` - Block size of the save data. (usually 0x1000)\n * `directories` - Number of directories.\n * `files` - Number of files.\n * `directoryBuckets` - Directory hash tree bucket count.\n * `fileBuckets` - File hash tree bucket count.\n * `duplicateData` - Whether to store an internal duplicate of the data."]
    pub fn FSUSER_CreateSystemSaveData(
        info: FS_SystemSaveDataInfo,
        totalSize: u32_,
        blockSize: u32_,
        directories: u32_,
        files: u32_,
        directoryBuckets: u32_,
        fileBuckets: u32_,
        duplicateData: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes system save data.\n # Arguments\n\n* `info` - Info of the save data."]
    pub fn FSUSER_DeleteSystemSaveData(info: FS_SystemSaveDataInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initiates a device move as the source device.\n # Arguments\n\n* `context` - Pointer to output the context to."]
    pub fn FSUSER_StartDeviceMoveAsSource(context: *mut FS_DeviceMoveContext) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initiates a device move as the destination device.\n # Arguments\n\n* `context` - Context to use.\n * `clear` - Whether to clear the device's data first."]
    pub fn FSUSER_StartDeviceMoveAsDestination(
        context: FS_DeviceMoveContext,
        clear: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets an archive's priority.\n # Arguments\n\n* `archive` - Archive to use.\n * `priority` - Priority to set."]
    pub fn FSUSER_SetArchivePriority(archive: FS_Archive, priority: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets an archive's priority.\n # Arguments\n\n* `priority` - Pointer to output the priority to.\n * `archive` - Archive to use."]
    pub fn FSUSER_GetArchivePriority(priority: *mut u32_, archive: FS_Archive) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures CTRCARD latency emulation.\n # Arguments\n\n* `latency` - Latency to apply, in milliseconds.\n * `emulateEndurance` - Whether to emulate card endurance."]
    pub fn FSUSER_SetCtrCardLatencyParameter(latency: u64_, emulateEndurance: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Toggles cleaning up invalid save data.\n # Arguments\n\n* `enable` - Whether to enable cleaning up invalid save data."]
    pub fn FSUSER_SwitchCleanupInvalidSaveData(enable: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Enumerates system save data.\n # Arguments\n\n* `idsWritten` - Pointer to output the number of IDs written to.\n * `idsSize` - Size of the IDs buffer.\n * `ids` - Pointer to output IDs to."]
    pub fn FSUSER_EnumerateSystemSaveData(
        idsWritten: *mut u32_,
        idsSize: u32_,
        ids: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes a FSUSER session with an SDK version.\n # Arguments\n\n* `session` - The handle of the FSUSER session to initialize.\n * `version` - SDK version to initialize with."]
    pub fn FSUSER_InitializeWithSdkVersion(session: Handle, version: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the file system priority.\n # Arguments\n\n* `priority` - Priority to set."]
    pub fn FSUSER_SetPriority(priority: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the file system priority.\n # Arguments\n\n* `priority` - Pointer to output the priority to."]
    pub fn FSUSER_GetPriority(priority: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the save data secure value.\n # Arguments\n\n* `value` - Secure value to set.\n * `slot` - Slot of the secure value.\n * `titleUniqueId` - Unique ID of the title. (default = 0)\n * `titleVariation` - Variation of the title. (default = 0)"]
    pub fn FSUSER_SetSaveDataSecureValue(
        value: u64_,
        slot: FS_SecureValueSlot,
        titleUniqueId: u32_,
        titleVariation: u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the save data secure value.\n # Arguments\n\n* `exists` - Pointer to output whether the secure value exists to.\n * `value` - Pointer to output the secure value to.\n * `slot` - Slot of the secure value.\n * `titleUniqueId` - Unique ID of the title. (default = 0)\n * `titleVariation` - Variation of the title. (default = 0)"]
    pub fn FSUSER_GetSaveDataSecureValue(
        exists: *mut bool,
        value: *mut u64_,
        slot: FS_SecureValueSlot,
        titleUniqueId: u32_,
        titleVariation: u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on a secure save.\n # Arguments\n\n* `action` - Action to perform.\n * `input` - Buffer to read input from.\n * `inputSize` - Size of the input.\n * `output` - Buffer to write output to.\n * `outputSize` - Size of the output."]
    pub fn FSUSER_ControlSecureSave(
        action: FS_SecureSaveAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the media type of the current application.\n # Arguments\n\n* `mediaType` - Pointer to output the media type to."]
    pub fn FSUSER_GetMediaType(mediaType: *mut FS_MediaType) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `action` - Action to perform.\n * `input` - Buffer to read input from.\n * `inputSize` - Size of the input.\n * `output` - Buffer to write output to.\n * `outputSize` - Size of the output."]
    pub fn FSFILE_Control(
        handle: Handle,
        action: FS_FileAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens a handle to a sub-section of a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `subFile` - Pointer to output the sub-file to.\n * `offset` - Offset of the sub-section.\n * `size` - Size of the sub-section."]
    pub fn FSFILE_OpenSubFile(
        handle: Handle,
        subFile: *mut Handle,
        offset: u64_,
        size: u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads from a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `bytesRead` - Pointer to output the number of bytes read to.\n * `offset` - Offset to read from.\n * `buffer` - Buffer to read to.\n * `size` - Size of the buffer."]
    pub fn FSFILE_Read(
        handle: Handle,
        bytesRead: *mut u32_,
        offset: u64_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes to a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `bytesWritten` - Pointer to output the number of bytes written to.\n * `offset` - Offset to write to.\n * `buffer` - Buffer to write from.\n * `size` - Size of the buffer.\n * `flags` - Flags to use when writing."]
    pub fn FSFILE_Write(
        handle: Handle,
        bytesWritten: *mut u32_,
        offset: u64_,
        buffer: *const ::libc::c_void,
        size: u32_,
        flags: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the size of a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `size` - Pointer to output the size to."]
    pub fn FSFILE_GetSize(handle: Handle, size: *mut u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the size of a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `size` - Size to set."]
    pub fn FSFILE_SetSize(handle: Handle, size: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the attributes of a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `attributes` - Pointer to output the attributes to."]
    pub fn FSFILE_GetAttributes(handle: Handle, attributes: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the attributes of a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `attributes` - Attributes to set."]
    pub fn FSFILE_SetAttributes(handle: Handle, attributes: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Closes a file.\n # Arguments\n\n* `handle` - Handle of the file."]
    pub fn FSFILE_Close(handle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Flushes a file's contents.\n # Arguments\n\n* `handle` - Handle of the file."]
    pub fn FSFILE_Flush(handle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets a file's priority.\n # Arguments\n\n* `handle` - Handle of the file.\n * `priority` - Priority to set."]
    pub fn FSFILE_SetPriority(handle: Handle, priority: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a file's priority.\n # Arguments\n\n* `handle` - Handle of the file.\n * `priority` - Pointer to output the priority to."]
    pub fn FSFILE_GetPriority(handle: Handle, priority: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens a duplicate handle to a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `linkFile` - Pointer to output the link handle to."]
    pub fn FSFILE_OpenLinkFile(handle: Handle, linkFile: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on a directory.\n # Arguments\n\n* `handle` - Handle of the directory.\n * `action` - Action to perform.\n * `input` - Buffer to read input from.\n * `inputSize` - Size of the input.\n * `output` - Buffer to write output to.\n * `outputSize` - Size of the output."]
    pub fn FSDIR_Control(
        handle: Handle,
        action: FS_DirectoryAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads one or more directory entries.\n # Arguments\n\n* `handle` - Handle of the directory.\n * `entriesRead` - Pointer to output the number of entries read to.\n * `entryCount` - Number of entries to read.\n * `entryOut` - Pointer to output directory entries to."]
    pub fn FSDIR_Read(
        handle: Handle,
        entriesRead: *mut u32_,
        entryCount: u32_,
        entries: *mut FS_DirectoryEntry,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Closes a directory.\n # Arguments\n\n* `handle` - Handle of the directory."]
    pub fn FSDIR_Close(handle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets a directory's priority.\n # Arguments\n\n* `handle` - Handle of the directory.\n * `priority` - Priority to set."]
    pub fn FSDIR_SetPriority(handle: Handle, priority: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a directory's priority.\n # Arguments\n\n* `handle` - Handle of the directory.\n * `priority` - Pointer to output the priority to."]
    pub fn FSDIR_GetPriority(handle: Handle, priority: *mut u32_) -> Result;
}
#[doc = "Contains basic information about a title."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AM_TitleEntry {
    #[doc = "< The title's ID."]
    pub titleID: u64_,
    #[doc = "< The title's installed size."]
    pub size: u64_,
    #[doc = "< The title's version."]
    pub version: u16_,
    #[doc = "< Unknown title data."]
    pub unk: [u8_; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AM_TitleEntry"][::core::mem::size_of::<AM_TitleEntry>() - 24usize];
    ["Alignment of AM_TitleEntry"][::core::mem::align_of::<AM_TitleEntry>() - 8usize];
    ["Offset of field: AM_TitleEntry::titleID"]
        [::core::mem::offset_of!(AM_TitleEntry, titleID) - 0usize];
    ["Offset of field: AM_TitleEntry::size"][::core::mem::offset_of!(AM_TitleEntry, size) - 8usize];
    ["Offset of field: AM_TitleEntry::version"]
        [::core::mem::offset_of!(AM_TitleEntry, version) - 16usize];
    ["Offset of field: AM_TitleEntry::unk"][::core::mem::offset_of!(AM_TitleEntry, unk) - 18usize];
};
#[doc = "< Titles currently installing."]
pub const AM_STATUS_MASK_INSTALLING: _bindgen_ty_14 = 1;
#[doc = "< Titles awaiting finalization."]
pub const AM_STATUS_MASK_AWAITING_FINALIZATION: _bindgen_ty_14 = 2;
#[doc = "Pending title status mask values."]
pub type _bindgen_ty_14 = ::libc::c_uchar;
#[doc = "< Install aborted."]
pub const AM_STATUS_ABORTED: AM_InstallStatus = 2;
#[doc = "< Title saved, but not installed."]
pub const AM_STATUS_SAVED: AM_InstallStatus = 3;
#[doc = "< Install in progress."]
pub const AM_STATUS_INSTALL_IN_PROGRESS: AM_InstallStatus = 2050;
#[doc = "< Awaiting finalization."]
pub const AM_STATUS_AWAITING_FINALIZATION: AM_InstallStatus = 2051;
#[doc = "Pending title status values."]
pub type AM_InstallStatus = ::libc::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AM_PendingTitleEntry {
    #[doc = "< Title ID"]
    pub titleId: u64_,
    #[doc = "< Version"]
    pub version: u16_,
    #[doc = "< AM_InstallStatus"]
    pub status: u16_,
    #[doc = "< Title Type"]
    pub titleType: u32_,
    #[doc = "< Unknown"]
    pub unk: [u8_; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AM_PendingTitleEntry"][::core::mem::size_of::<AM_PendingTitleEntry>() - 24usize];
    ["Alignment of AM_PendingTitleEntry"][::core::mem::align_of::<AM_PendingTitleEntry>() - 8usize];
    ["Offset of field: AM_PendingTitleEntry::titleId"]
        [::core::mem::offset_of!(AM_PendingTitleEntry, titleId) - 0usize];
    ["Offset of field: AM_PendingTitleEntry::version"]
        [::core::mem::offset_of!(AM_PendingTitleEntry, version) - 8usize];
    ["Offset of field: AM_PendingTitleEntry::status"]
        [::core::mem::offset_of!(AM_PendingTitleEntry, status) - 10usize];
    ["Offset of field: AM_PendingTitleEntry::titleType"]
        [::core::mem::offset_of!(AM_PendingTitleEntry, titleType) - 12usize];
    ["Offset of field: AM_PendingTitleEntry::unk"]
        [::core::mem::offset_of!(AM_PendingTitleEntry, unk) - 16usize];
};
#[doc = "< Non-system titles."]
pub const AM_DELETE_PENDING_NON_SYSTEM: _bindgen_ty_15 = 1;
#[doc = "< System titles."]
pub const AM_DELETE_PENDING_SYSTEM: _bindgen_ty_15 = 2;
#[doc = "Pending title deletion flags."]
pub type _bindgen_ty_15 = ::libc::c_uchar;
#[doc = "Information about the TWL NAND partition."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AM_TWLPartitionInfo {
    #[doc = "< Total capacity."]
    pub capacity: u64_,
    #[doc = "< Total free space."]
    pub freeSpace: u64_,
    #[doc = "< Capacity for titles."]
    pub titlesCapacity: u64_,
    #[doc = "< Free space for titles."]
    pub titlesFreeSpace: u64_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AM_TWLPartitionInfo"][::core::mem::size_of::<AM_TWLPartitionInfo>() - 32usize];
    ["Alignment of AM_TWLPartitionInfo"][::core::mem::align_of::<AM_TWLPartitionInfo>() - 8usize];
    ["Offset of field: AM_TWLPartitionInfo::capacity"]
        [::core::mem::offset_of!(AM_TWLPartitionInfo, capacity) - 0usize];
    ["Offset of field: AM_TWLPartitionInfo::freeSpace"]
        [::core::mem::offset_of!(AM_TWLPartitionInfo, freeSpace) - 8usize];
    ["Offset of field: AM_TWLPartitionInfo::titlesCapacity"]
        [::core::mem::offset_of!(AM_TWLPartitionInfo, titlesCapacity) - 16usize];
    ["Offset of field: AM_TWLPartitionInfo::titlesFreeSpace"]
        [::core::mem::offset_of!(AM_TWLPartitionInfo, titlesFreeSpace) - 24usize];
};
#[doc = "Contains information about a title's content."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AM_ContentInfo {
    #[doc = "< Index of the content in the title."]
    pub index: u16_,
    #[doc = "< ?"]
    pub type_: u16_,
    #[doc = "< ID of the content in the title."]
    pub contentId: u32_,
    #[doc = "< Size of the content in the title."]
    pub size: u64_,
    #[doc = "< AM_ContentInfoFlags"]
    pub flags: u8_,
    #[doc = "< Padding"]
    pub padding: [u8_; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AM_ContentInfo"][::core::mem::size_of::<AM_ContentInfo>() - 24usize];
    ["Alignment of AM_ContentInfo"][::core::mem::align_of::<AM_ContentInfo>() - 8usize];
    ["Offset of field: AM_ContentInfo::index"]
        [::core::mem::offset_of!(AM_ContentInfo, index) - 0usize];
    ["Offset of field: AM_ContentInfo::type_"]
        [::core::mem::offset_of!(AM_ContentInfo, type_) - 2usize];
    ["Offset of field: AM_ContentInfo::contentId"]
        [::core::mem::offset_of!(AM_ContentInfo, contentId) - 4usize];
    ["Offset of field: AM_ContentInfo::size"]
        [::core::mem::offset_of!(AM_ContentInfo, size) - 8usize];
    ["Offset of field: AM_ContentInfo::flags"]
        [::core::mem::offset_of!(AM_ContentInfo, flags) - 16usize];
    ["Offset of field: AM_ContentInfo::padding"]
        [::core::mem::offset_of!(AM_ContentInfo, padding) - 17usize];
};
#[doc = "< ?"]
pub const AM_CONTENT_DOWNLOADED: AM_ContentInfoFlags = 1;
#[doc = "< ?"]
pub const AM_CONTENT_OWNED: AM_ContentInfoFlags = 2;
#[doc = "Title ContentInfo flags."]
pub type AM_ContentInfoFlags = ::libc::c_uchar;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes AM. This doesn't initialize with \"am:app\", see amAppInit()."]
    pub fn amInit() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes AM with a service which has access to the amapp-commands. This should only be used when using the amapp commands, not non-amapp AM commands."]
    pub fn amAppInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits AM."]
    pub fn amExit();
}
unsafe extern "C" {
    #[doc = "Gets the current AM session handle."]
    pub fn amGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the number of titles for a given media type.\n # Arguments\n\n* `mediatype` - Media type to get titles from.\n * `count` (direction out) - Pointer to write the title count to."]
    pub fn AM_GetTitleCount(mediatype: FS_MediaType, count: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a list of title IDs present in a mediatype.\n # Arguments\n\n* `titlesRead` (direction out) - Pointer to output the number of read titles to.\n * `mediatype` - Media type to get titles from.\n * `titleCount` - Number of title IDs to get.\n * `titleIds` - Buffer to output the retrieved title IDs to."]
    pub fn AM_GetTitleList(
        titlesRead: *mut u32_,
        mediatype: FS_MediaType,
        titleCount: u32_,
        titleIds: *mut u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a list of details about installed titles.\n # Arguments\n\n* `mediatype` - Media type to get titles from.\n * `titleCount` - Number of titles to list.\n * `titleIds` - List of title IDs to retrieve details for.\n * `titleInfo` - Buffer to write AM_TitleEntry's to."]
    pub fn AM_GetTitleInfo(
        mediatype: FS_MediaType,
        titleCount: u32_,
        titleIds: *mut u64_,
        titleInfo: *mut AM_TitleEntry,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the number of tickets installed on the system.\n # Arguments\n\n* `count` (direction out) - Pointer to output the ticket count to."]
    pub fn AM_GetTicketCount(count: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a list of tickets installed on the system.\n # Arguments\n\n* `ticketsRead` (direction out) - Pointer to output the number of read tickets to.\n * `ticketCount` - Number of tickets to read.\n * `skip` - Number of tickets to skip.\n * `ticketIds` - Buffer to output the retrieved ticket IDs to."]
    pub fn AM_GetTicketList(
        ticketsRead: *mut u32_,
        ticketCount: u32_,
        skip: u32_,
        ticketIds: *mut u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the number of pending titles on this system.\n # Arguments\n\n* `count` (direction out) - Pointer to output the pending title count to.\n * `mediatype` - Media type of pending titles to count.\n * `statusMask` - Bit mask of status values to include."]
    pub fn AM_GetPendingTitleCount(
        count: *mut u32_,
        mediatype: FS_MediaType,
        statusMask: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a list of pending titles on this system.\n # Arguments\n\n* `titlesRead` (direction out) - Pointer to output the number of read pending titles to.\n * `titleCount` - Number of pending titles to read.\n * `mediatype` - Media type of pending titles to list.\n * `statusMask` - Bit mask of status values to include.\n * `titleIds` - Buffer to output the retrieved pending title IDs to."]
    pub fn AM_GetPendingTitleList(
        titlesRead: *mut u32_,
        titleCount: u32_,
        mediatype: FS_MediaType,
        statusMask: u32_,
        titleIds: *mut u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets information about pending titles on this system.\n # Arguments\n\n* `titleCount` - Number of pending titles to read.\n * `mediatype` - Media type of pending titles to get information on.\n * `titleIds` - IDs of the titles to get information about.\n * `titleInfo` - Buffer to output the retrieved pending title info to."]
    pub fn AM_GetPendingTitleInfo(
        titleCount: u32_,
        mediatype: FS_MediaType,
        titleIds: *mut u64_,
        titleInfo: *mut AM_PendingTitleEntry,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a 32-bit device-specific ID.\n # Arguments\n\n* `deviceID` - Pointer to write the device ID to."]
    pub fn AM_GetDeviceId(deviceID: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Exports DSiWare to the specified filepath.\n # Arguments\n\n* `titleID` - TWL titleID.\n * `operation` - DSiWare operation type.\n * `workbuf` - Work buffer.\n * `workbuf_size` - Work buffer size, must be >=0x20000.\n * `filepath` - UTF-8 filepath(converted to UTF-16 internally)."]
    pub fn AM_ExportTwlBackup(
        titleID: u64_,
        operation: u8_,
        workbuf: *mut ::libc::c_void,
        workbuf_size: u32_,
        filepath: *const ::libc::c_char,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Imports DSiWare from the specified file.\n # Arguments\n\n* `filehandle` - FSUSER file handle.\n * `operation` - DSiWare operation type.\n * `buffer` - Work buffer.\n * `size` - Buffer size, must be >=0x20000."]
    pub fn AM_ImportTwlBackup(
        filehandle: Handle,
        operation: u8_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads info from the specified DSiWare export file. This can only be used with DSiWare exported with certain operation value(s).\n # Arguments\n\n* `filehandle` - FSUSER file handle.\n * `outinfo` - Output info buffer.\n * `outinfo_size` - Output info buffer size.\n * `workbuf` - Work buffer.\n * `workbuf_size` - Work buffer size.\n * `banner` - Output banner buffer.\n * `banner_size` - Output banner buffer size."]
    pub fn AM_ReadTwlBackupInfo(
        filehandle: Handle,
        outinfo: *mut ::libc::c_void,
        outinfo_size: u32_,
        workbuf: *mut ::libc::c_void,
        workbuf_size: u32_,
        banner: *mut ::libc::c_void,
        banner_size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrieves information about the NAND TWL partition.\n # Arguments\n\n* `info` (direction out) - Pointer to output the TWL partition info to."]
    pub fn AM_GetTWLPartitionInfo(info: *mut AM_TWLPartitionInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the CIA install process, returning a handle to write CIA data to.\n # Arguments\n\n* `mediatype` - Media type to install the CIA to.\n * `ciaHandle` (direction out) - Pointer to write the CIA handle to."]
    pub fn AM_StartCiaInstall(mediatype: FS_MediaType, ciaHandle: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the CIA install process for Download Play CIAs, returning a handle to write CIA data to.\n # Arguments\n\n* `ciaHandle` (direction out) - Pointer to write the CIA handle to."]
    pub fn AM_StartDlpChildCiaInstall(ciaHandle: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Aborts the CIA install process.\n # Arguments\n\n* `ciaHandle` - CIA handle to cancel."]
    pub fn AM_CancelCIAInstall(ciaHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Finalizes the CIA install process.\n # Arguments\n\n* `ciaHandle` - CIA handle to finalize."]
    pub fn AM_FinishCiaInstall(ciaHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Finalizes the CIA install process without committing the title to title.db or tmp*.db.\n # Arguments\n\n* `ciaHandle` - CIA handle to finalize."]
    pub fn AM_FinishCiaInstallWithoutCommit(ciaHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Commits installed CIAs.\n # Arguments\n\n* `mediaType` - Location of the titles to finalize.\n * `titleCount` - Number of titles to finalize.\n * `temp` - Whether the titles being finalized are in the temporary database.\n * `titleIds` - Title IDs to finalize."]
    pub fn AM_CommitImportPrograms(
        mediaType: FS_MediaType,
        titleCount: u32_,
        temp: bool,
        titleIds: *const u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes a title.\n # Arguments\n\n* `mediatype` - Media type to delete from.\n * `titleID` - ID of the title to delete."]
    pub fn AM_DeleteTitle(mediatype: FS_MediaType, titleID: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes a title, provided that it is not a system title.\n # Arguments\n\n* `mediatype` - Media type to delete from.\n * `titleID` - ID of the title to delete."]
    pub fn AM_DeleteAppTitle(mediatype: FS_MediaType, titleID: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes a ticket.\n # Arguments\n\n* `titleID` - ID of the ticket to delete."]
    pub fn AM_DeleteTicket(ticketId: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes a pending title.\n # Arguments\n\n* `mediatype` - Media type to delete from.\n * `titleId` - ID of the pending title to delete."]
    pub fn AM_DeletePendingTitle(mediatype: FS_MediaType, titleId: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes pending titles.\n # Arguments\n\n* `mediatype` - Media type to delete from.\n * `flags` - Flags used to select pending titles."]
    pub fn AM_DeletePendingTitles(mediatype: FS_MediaType, flags: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes all pending titles.\n # Arguments\n\n* `mediatype` - Media type to delete from."]
    pub fn AM_DeleteAllPendingTitles(mediatype: FS_MediaType) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Installs the current NATIVE_FIRM title to NAND (firm0:/ & firm1:/)"]
    pub fn AM_InstallNativeFirm() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Installs a NATIVE_FIRM title to NAND. Accepts 0004013800000002 or 0004013820000002 (N3DS).\n # Arguments\n\n* `titleID` - Title ID of the NATIVE_FIRM to install."]
    pub fn AM_InstallFirm(titleID: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the product code of a title.\n # Arguments\n\n* `mediatype` - Media type of the title.\n * `titleID` - ID of the title.\n * `productCode` (direction out) - Pointer to output the product code to. (length = 16)"]
    pub fn AM_GetTitleProductCode(
        mediatype: FS_MediaType,
        titleId: u64_,
        productCode: *mut ::libc::c_char,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the ext data ID of a title.\n # Arguments\n\n* `extDataId` (direction out) - Pointer to output the ext data ID to.\n * `mediatype` - Media type of the title.\n * `titleID` - ID of the title."]
    pub fn AM_GetTitleExtDataId(
        extDataId: *mut u64_,
        mediatype: FS_MediaType,
        titleId: u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets an AM_TitleEntry instance for a CIA file.\n # Arguments\n\n* `mediatype` - Media type that this CIA would be installed to.\n * `titleEntry` (direction out) - Pointer to write the AM_TitleEntry instance to.\n * `fileHandle` - Handle of the CIA file."]
    pub fn AM_GetCiaFileInfo(
        mediatype: FS_MediaType,
        titleEntry: *mut AM_TitleEntry,
        fileHandle: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the SMDH icon data of a CIA file.\n # Arguments\n\n* `icon` - Buffer to store the icon data in. Must be of size 0x36C0 bytes.\n * `fileHandle` - Handle of the CIA file."]
    pub fn AM_GetCiaIcon(icon: *mut ::libc::c_void, fileHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the title ID dependency list of a CIA file.\n # Arguments\n\n* `dependencies` - Buffer to store dependency title IDs in. Must be of size 0x300 bytes.\n * `fileHandle` - Handle of the CIA file."]
    pub fn AM_GetCiaDependencies(dependencies: *mut u64_, fileHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the meta section offset of a CIA file.\n # Arguments\n\n* `metaOffset` (direction out) - Pointer to output the meta section offset to.\n * `fileHandle` - Handle of the CIA file."]
    pub fn AM_GetCiaMetaOffset(metaOffset: *mut u64_, fileHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the core version of a CIA file.\n # Arguments\n\n* `coreVersion` (direction out) - Pointer to output the core version to.\n * `fileHandle` - Handle of the CIA file."]
    pub fn AM_GetCiaCoreVersion(coreVersion: *mut u32_, fileHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the free space, in bytes, required to install a CIA file.\n # Arguments\n\n* `requiredSpace` (direction out) - Pointer to output the required free space to.\n * `mediaType` - Media type to check free space needed to install to.\n * `fileHandle` - Handle of the CIA file."]
    pub fn AM_GetCiaRequiredSpace(
        requiredSpace: *mut u64_,
        mediaType: FS_MediaType,
        fileHandle: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the full meta section of a CIA file.\n # Arguments\n\n* `meta` - Buffer to store the meta section in.\n * `size` - Size of the buffer. Must be greater than or equal to the actual section data's size.\n * `fileHandle` - Handle of the CIA file."]
    pub fn AM_GetCiaMetaSection(
        meta: *mut ::libc::c_void,
        size: u32_,
        fileHandle: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the external (SD) title database.\n # Arguments\n\n* `overwrite` - Overwrites the database if it already exists."]
    pub fn AM_InitializeExternalTitleDatabase(overwrite: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Queries whether the external title database is available.\n # Arguments\n\n* `available` (direction out) - Pointer to output the availability status to."]
    pub fn AM_QueryAvailableExternalTitleDatabase(available: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Begins installing a ticket.\n # Arguments\n\n* `ticketHandle` (direction out) - Pointer to output a handle to write ticket data to."]
    pub fn AM_InstallTicketBegin(ticketHandle: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Aborts installing a ticket.\n # Arguments\n\n* `ticketHandle` - Handle of the installation to abort."]
    pub fn AM_InstallTicketAbort(ticketHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Finishes installing a ticket.\n # Arguments\n\n* `ticketHandle` - Handle of the installation to finalize."]
    pub fn AM_InstallTicketFinish(ticketHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Begins installing a title.\n # Arguments\n\n* `mediaType` - Destination to install to.\n * `titleId` - ID of the title to install.\n * `unk` - Unknown. (usually false)"]
    pub fn AM_InstallTitleBegin(mediaType: FS_MediaType, titleId: u64_, unk: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Stops installing a title, generally to be resumed later."]
    pub fn AM_InstallTitleStop() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Resumes installing a title.\n # Arguments\n\n* `mediaType` - Destination to install to.\n * `titleId` - ID of the title to install."]
    pub fn AM_InstallTitleResume(mediaType: FS_MediaType, titleId: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Aborts installing a title."]
    pub fn AM_InstallTitleAbort() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Finishes installing a title."]
    pub fn AM_InstallTitleFinish() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Commits installed titles.\n # Arguments\n\n* `mediaType` - Location of the titles to finalize.\n * `titleCount` - Number of titles to finalize.\n * `temp` - Whether the titles being finalized are in the temporary database.\n * `titleIds` - Title IDs to finalize."]
    pub fn AM_CommitImportTitles(
        mediaType: FS_MediaType,
        titleCount: u32_,
        temp: bool,
        titleIds: *const u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Begins installing a TMD.\n # Arguments\n\n* `tmdHandle` (direction out) - Pointer to output a handle to write TMD data to."]
    pub fn AM_InstallTmdBegin(tmdHandle: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Aborts installing a TMD.\n # Arguments\n\n* `tmdHandle` - Handle of the installation to abort."]
    pub fn AM_InstallTmdAbort(tmdHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Finishes installing a TMD.\n # Arguments\n\n* `tmdHandle` - Handle of the installation to finalize.\n * `unk` - Unknown. (usually true)"]
    pub fn AM_InstallTmdFinish(tmdHandle: Handle, unk: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Prepares to import title contents.\n # Arguments\n\n* `contentCount` - Number of contents to be imported.\n * `contentIndices` - Indices of the contents to be imported."]
    pub fn AM_CreateImportContentContexts(contentCount: u32_, contentIndices: *mut u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Begins installing title content.\n # Arguments\n\n* `contentHandle` (direction out) - Pointer to output a handle to write content data to.\n * `index` - Index of the content to install."]
    pub fn AM_InstallContentBegin(contentHandle: *mut Handle, index: u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Stops installing title content, generally to be resumed later.\n # Arguments\n\n* `contentHandle` - Handle of the installation to abort."]
    pub fn AM_InstallContentStop(contentHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Resumes installing title content.\n # Arguments\n\n* `contentHandle` (direction out) - Pointer to output a handle to write content data to.\n * `resumeOffset` (direction out) - Pointer to write the offset to resume content installation at to.\n * `index` - Index of the content to install."]
    pub fn AM_InstallContentResume(
        contentHandle: *mut Handle,
        resumeOffset: *mut u64_,
        index: u16_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Cancels installing title content.\n # Arguments\n\n* `contentHandle` - Handle of the installation to finalize."]
    pub fn AM_InstallContentCancel(contentHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Finishes installing title content.\n # Arguments\n\n* `contentHandle` - Handle of the installation to finalize."]
    pub fn AM_InstallContentFinish(contentHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Imports up to four certificates into the ticket certificate chain.\n # Arguments\n\n* `cert1Size` - Size of the first certificate.\n * `cert1` - Data of the first certificate.\n * `cert2Size` - Size of the second certificate.\n * `cert2` - Data of the second certificate.\n * `cert3Size` - Size of the third certificate.\n * `cert3` - Data of the third certificate.\n * `cert4Size` - Size of the fourth certificate.\n * `cert4` - Data of the fourth certificate."]
    pub fn AM_ImportCertificates(
        cert1Size: u32_,
        cert1: *mut ::libc::c_void,
        cert2Size: u32_,
        cert2: *mut ::libc::c_void,
        cert3Size: u32_,
        cert3: *mut ::libc::c_void,
        cert4Size: u32_,
        cert4: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Imports a certificate into the ticket certificate chain.\n # Arguments\n\n* `certSize` - Size of the certificate.\n * `cert` - Data of the certificate."]
    pub fn AM_ImportCertificate(certSize: u32_, cert: *mut ::libc::c_void) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Commits installed titles, and updates FIRM if necessary.\n # Arguments\n\n* `mediaType` - Location of the titles to finalize.\n * `titleCount` - Number of titles to finalize.\n * `temp` - Whether the titles being finalized are in the temporary database.\n * `titleIds` - Title IDs to finalize."]
    pub fn AM_CommitImportTitlesAndUpdateFirmwareAuto(
        mediaType: FS_MediaType,
        titleCount: u32_,
        temp: bool,
        titleIds: *mut u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Resets play count of all installed demos by deleting their launch info."]
    pub fn AM_DeleteAllDemoLaunchInfos() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes temporary titles."]
    pub fn AM_DeleteAllTemporaryTitles() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes all expired titles.\n # Arguments\n\n* `mediatype` - Media type to delete from."]
    pub fn AM_DeleteAllExpiredTitles(mediatype: FS_MediaType) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes all TWL titles."]
    pub fn AM_DeleteAllTwlTitles() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the number of content index installed under the specified DLC title.\n # Arguments\n\n* `count` (direction out) - Pointer to output the number of content indices to.\n * `mediatype` - Media type of the title.\n * `titleID` - Title ID to retrieve the count for (high-id is 0x0004008C)."]
    pub fn AMAPP_GetDLCContentInfoCount(
        count: *mut u32_,
        mediatype: FS_MediaType,
        titleID: u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets content infos installed under the specified DLC title.\n # Arguments\n\n* `contentInfoRead` (direction out) - Pointer to output the number of content infos read to.\n * `mediatype` - Media type of the title.\n * `titleID` - Title ID to retrieve the content infos for (high-id is 0x0004008C).\n * `contentInfoCount` - Number of content infos to retrieve.\n * `offset` - Offset from the first content index the count starts at.\n * `contentInfos` (direction out) - Pointer to output the content infos read to."]
    pub fn AMAPP_ListDLCContentInfos(
        contentInfoRead: *mut u32_,
        mediatype: FS_MediaType,
        titleID: u64_,
        contentInfoCount: u32_,
        offset: u32_,
        contentInfos: *mut AM_ContentInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes AMPXI.\n # Arguments\n\n* `servhandle` - Optional service session handle to use for AMPXI, if zero srvGetServiceHandle() will be used."]
    pub fn ampxiInit(servhandle: Handle) -> Result;
}
unsafe extern "C" {
    #[doc = "Exits AMPXI."]
    pub fn ampxiExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes a TWL save-file to NAND. https://www.3dbrew.org/wiki/AMPXI:WriteTWLSavedata\n # Arguments\n\n* `titleid` - ID of the TWL title.\n * `buffer` - Savedata buffer ptr.\n * `size` - Size of the savedata buffer.\n * `image_filepos` - Filepos to use for writing the data to the NAND savedata file.\n * `section_type` - https://www.3dbrew.org/wiki/AMPXI:WriteTWLSavedata\n * `operation` - https://3dbrew.org/wiki/AM:ImportDSiWare"]
    pub fn AMPXI_WriteTWLSavedata(
        titleid: u64_,
        buffer: *mut u8_,
        size: u32_,
        image_filepos: u32_,
        section_type: u8_,
        operation: u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Finalizes title installation. https://3dbrew.org/wiki/AMPXI:InstallTitlesFinish\n # Arguments\n\n* `mediaType` - Mediatype of the titles to finalize.\n * `db` - Which title database to use.\n * `size` - Size of the savedata buffer.\n * `titlecount` - Total titles.\n * `tidlist` - List of titleIDs."]
    pub fn AMPXI_InstallTitlesFinish(
        mediaType: FS_MediaType,
        db: u8_,
        titlecount: u32_,
        tidlist: *mut u64_,
    ) -> Result;
}
pub const APPID_NONE: NS_APPID = 0;
#[doc = "< Home Menu"]
pub const APPID_HOMEMENU: NS_APPID = 257;
#[doc = "< Camera applet"]
pub const APPID_CAMERA: NS_APPID = 272;
#[doc = "< Friends List applet"]
pub const APPID_FRIENDS_LIST: NS_APPID = 274;
#[doc = "< Game Notes applet"]
pub const APPID_GAME_NOTES: NS_APPID = 275;
#[doc = "< Internet Browser"]
pub const APPID_WEB: NS_APPID = 276;
#[doc = "< Instruction Manual applet"]
pub const APPID_INSTRUCTION_MANUAL: NS_APPID = 277;
#[doc = "< Notifications applet"]
pub const APPID_NOTIFICATIONS: NS_APPID = 278;
#[doc = "< Miiverse applet (olv)"]
pub const APPID_MIIVERSE: NS_APPID = 279;
#[doc = "< Miiverse posting applet (solv3)"]
pub const APPID_MIIVERSE_POSTING: NS_APPID = 280;
#[doc = "< Amiibo settings applet (cabinet)"]
pub const APPID_AMIIBO_SETTINGS: NS_APPID = 281;
#[doc = "< Application"]
pub const APPID_APPLICATION: NS_APPID = 768;
#[doc = "< eShop (tiger)"]
pub const APPID_ESHOP: NS_APPID = 769;
#[doc = "< Software Keyboard"]
pub const APPID_SOFTWARE_KEYBOARD: NS_APPID = 1025;
#[doc = "< appletEd"]
pub const APPID_APPLETED: NS_APPID = 1026;
#[doc = "< PNOTE_AP"]
pub const APPID_PNOTE_AP: NS_APPID = 1028;
#[doc = "< SNOTE_AP"]
pub const APPID_SNOTE_AP: NS_APPID = 1029;
#[doc = "< error"]
pub const APPID_ERROR: NS_APPID = 1030;
#[doc = "< mint"]
pub const APPID_MINT: NS_APPID = 1031;
#[doc = "< extrapad"]
pub const APPID_EXTRAPAD: NS_APPID = 1032;
#[doc = "< memolib"]
pub const APPID_MEMOLIB: NS_APPID = 1033;
#[doc = "NS Application IDs.\n\n Retrieved from http://3dbrew.org/wiki/NS_and_APT_Services#AppIDs"]
pub type NS_APPID = ::libc::c_ushort;
#[doc = "< No position specified."]
pub const APTPOS_NONE: APT_AppletPos = -1;
#[doc = "< Application."]
pub const APTPOS_APP: APT_AppletPos = 0;
#[doc = "< Application library (?)."]
pub const APTPOS_APPLIB: APT_AppletPos = 1;
#[doc = "< System applet."]
pub const APTPOS_SYS: APT_AppletPos = 2;
#[doc = "< System library (?)."]
pub const APTPOS_SYSLIB: APT_AppletPos = 3;
#[doc = "< Resident applet."]
pub const APTPOS_RESIDENT: APT_AppletPos = 4;
#[doc = "APT applet position."]
pub type APT_AppletPos = ::libc::c_schar;
pub type APT_AppletAttr = u8_;
unsafe extern "C" {
    #[doc = "Create an APT_AppletAttr bitfield from its components."]
    #[link_name = "aptMakeAppletAttr__extern"]
    pub fn aptMakeAppletAttr(
        pos: APT_AppletPos,
        manualGpuRights: bool,
        manualDspRights: bool,
    ) -> APT_AppletAttr;
}
pub const APTREPLY_REJECT: APT_QueryReply = 0;
pub const APTREPLY_ACCEPT: APT_QueryReply = 1;
pub const APTREPLY_LATER: APT_QueryReply = 2;
#[doc = "APT query reply."]
pub type APT_QueryReply = ::libc::c_uchar;
#[doc = "< No signal received."]
pub const APTSIGNAL_NONE: APT_Signal = 0;
#[doc = "< HOME button pressed."]
pub const APTSIGNAL_HOMEBUTTON: APT_Signal = 1;
#[doc = "< HOME button pressed (again?)."]
pub const APTSIGNAL_HOMEBUTTON2: APT_Signal = 2;
#[doc = "< Prepare to enter sleep mode."]
pub const APTSIGNAL_SLEEP_QUERY: APT_Signal = 3;
#[doc = "< Triggered when ptm:s GetShellStatus() returns 5."]
pub const APTSIGNAL_SLEEP_CANCEL: APT_Signal = 4;
#[doc = "< Enter sleep mode."]
pub const APTSIGNAL_SLEEP_ENTER: APT_Signal = 5;
#[doc = "< Wake from sleep mode."]
pub const APTSIGNAL_SLEEP_WAKEUP: APT_Signal = 6;
#[doc = "< Shutdown."]
pub const APTSIGNAL_SHUTDOWN: APT_Signal = 7;
#[doc = "< POWER button pressed."]
pub const APTSIGNAL_POWERBUTTON: APT_Signal = 8;
#[doc = "< POWER button cleared (?)."]
pub const APTSIGNAL_POWERBUTTON2: APT_Signal = 9;
#[doc = "< System sleeping (?)."]
pub const APTSIGNAL_TRY_SLEEP: APT_Signal = 10;
#[doc = "< Order to close (such as when an error happens?)."]
pub const APTSIGNAL_ORDERTOCLOSE: APT_Signal = 11;
#[doc = "APT signals."]
pub type APT_Signal = ::libc::c_uchar;
#[doc = "< No command received."]
pub const APTCMD_NONE: APT_Command = 0;
#[doc = "< Applet should wake up."]
pub const APTCMD_WAKEUP: APT_Command = 1;
#[doc = "< Source applet sent us a parameter."]
pub const APTCMD_REQUEST: APT_Command = 2;
#[doc = "< Target applet replied to our parameter."]
pub const APTCMD_RESPONSE: APT_Command = 3;
#[doc = "< Exit (??)"]
pub const APTCMD_EXIT: APT_Command = 4;
#[doc = "< Message (??)"]
pub const APTCMD_MESSAGE: APT_Command = 5;
#[doc = "< HOME button pressed once."]
pub const APTCMD_HOMEBUTTON_ONCE: APT_Command = 6;
#[doc = "< HOME button pressed twice (double-pressed)."]
pub const APTCMD_HOMEBUTTON_TWICE: APT_Command = 7;
#[doc = "< DSP should sleep (manual DSP rights related?)."]
pub const APTCMD_DSP_SLEEP: APT_Command = 8;
#[doc = "< DSP should wake up (manual DSP rights related?)."]
pub const APTCMD_DSP_WAKEUP: APT_Command = 9;
#[doc = "< Applet wakes up due to a different applet exiting."]
pub const APTCMD_WAKEUP_EXIT: APT_Command = 10;
#[doc = "< Applet wakes up after being paused through HOME menu."]
pub const APTCMD_WAKEUP_PAUSE: APT_Command = 11;
#[doc = "< Applet wakes up due to being cancelled."]
pub const APTCMD_WAKEUP_CANCEL: APT_Command = 12;
#[doc = "< Applet wakes up due to all applets being cancelled."]
pub const APTCMD_WAKEUP_CANCELALL: APT_Command = 13;
#[doc = "< Applet wakes up due to POWER button being pressed (?)."]
pub const APTCMD_WAKEUP_POWERBUTTON: APT_Command = 14;
#[doc = "< Applet wakes up and is instructed to jump to HOME menu (?)."]
pub const APTCMD_WAKEUP_JUMPTOHOME: APT_Command = 15;
#[doc = "< Request for sysapplet (?)."]
pub const APTCMD_SYSAPPLET_REQUEST: APT_Command = 16;
#[doc = "< Applet wakes up and is instructed to launch another applet (?)."]
pub const APTCMD_WAKEUP_LAUNCHAPP: APT_Command = 17;
#[doc = "APT commands."]
pub type APT_Command = ::libc::c_uchar;
#[doc = "APT capture buffer information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aptCaptureBufInfo {
    pub size: u32_,
    pub is3D: u32_,
    pub top: aptCaptureBufInfo__bindgen_ty_1,
    pub bottom: aptCaptureBufInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aptCaptureBufInfo__bindgen_ty_1 {
    pub leftOffset: u32_,
    pub rightOffset: u32_,
    pub format: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aptCaptureBufInfo__bindgen_ty_1"]
        [::core::mem::size_of::<aptCaptureBufInfo__bindgen_ty_1>() - 12usize];
    ["Alignment of aptCaptureBufInfo__bindgen_ty_1"]
        [::core::mem::align_of::<aptCaptureBufInfo__bindgen_ty_1>() - 4usize];
    ["Offset of field: aptCaptureBufInfo__bindgen_ty_1::leftOffset"]
        [::core::mem::offset_of!(aptCaptureBufInfo__bindgen_ty_1, leftOffset) - 0usize];
    ["Offset of field: aptCaptureBufInfo__bindgen_ty_1::rightOffset"]
        [::core::mem::offset_of!(aptCaptureBufInfo__bindgen_ty_1, rightOffset) - 4usize];
    ["Offset of field: aptCaptureBufInfo__bindgen_ty_1::format"]
        [::core::mem::offset_of!(aptCaptureBufInfo__bindgen_ty_1, format) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aptCaptureBufInfo"][::core::mem::size_of::<aptCaptureBufInfo>() - 32usize];
    ["Alignment of aptCaptureBufInfo"][::core::mem::align_of::<aptCaptureBufInfo>() - 4usize];
    ["Offset of field: aptCaptureBufInfo::size"]
        [::core::mem::offset_of!(aptCaptureBufInfo, size) - 0usize];
    ["Offset of field: aptCaptureBufInfo::is3D"]
        [::core::mem::offset_of!(aptCaptureBufInfo, is3D) - 4usize];
    ["Offset of field: aptCaptureBufInfo::top"]
        [::core::mem::offset_of!(aptCaptureBufInfo, top) - 8usize];
    ["Offset of field: aptCaptureBufInfo::bottom"]
        [::core::mem::offset_of!(aptCaptureBufInfo, bottom) - 20usize];
};
#[doc = "< App suspended."]
pub const APTHOOK_ONSUSPEND: APT_HookType = 0;
#[doc = "< App restored."]
pub const APTHOOK_ONRESTORE: APT_HookType = 1;
#[doc = "< App sleeping."]
pub const APTHOOK_ONSLEEP: APT_HookType = 2;
#[doc = "< App waking up."]
pub const APTHOOK_ONWAKEUP: APT_HookType = 3;
#[doc = "< App exiting."]
pub const APTHOOK_ONEXIT: APT_HookType = 4;
#[doc = "< Number of APT hook types."]
pub const APTHOOK_COUNT: APT_HookType = 5;
#[doc = "APT hook types."]
pub type APT_HookType = ::libc::c_uchar;
#[doc = "APT hook function."]
pub type aptHookFn =
    ::core::option::Option<unsafe extern "C" fn(hook: APT_HookType, param: *mut ::libc::c_void)>;
#[doc = "APT hook cookie."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_aptHookCookie {
    #[doc = "< Next cookie."]
    pub next: *mut tag_aptHookCookie,
    #[doc = "< Hook callback."]
    pub callback: aptHookFn,
    #[doc = "< Callback parameter."]
    pub param: *mut ::libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tag_aptHookCookie"][::core::mem::size_of::<tag_aptHookCookie>() - 12usize];
    ["Alignment of tag_aptHookCookie"][::core::mem::align_of::<tag_aptHookCookie>() - 4usize];
    ["Offset of field: tag_aptHookCookie::next"]
        [::core::mem::offset_of!(tag_aptHookCookie, next) - 0usize];
    ["Offset of field: tag_aptHookCookie::callback"]
        [::core::mem::offset_of!(tag_aptHookCookie, callback) - 4usize];
    ["Offset of field: tag_aptHookCookie::param"]
        [::core::mem::offset_of!(tag_aptHookCookie, param) - 8usize];
};
impl Default for tag_aptHookCookie {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "APT hook cookie."]
pub type aptHookCookie = tag_aptHookCookie;
#[doc = "APT message callback."]
pub type aptMessageCb = ::core::option::Option<
    unsafe extern "C" fn(
        user: *mut ::libc::c_void,
        sender: NS_APPID,
        msg: *mut ::libc::c_void,
        msgsize: usize,
    ),
>;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes APT."]
    pub fn aptInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits APT."]
    pub fn aptExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sends an APT command through IPC, taking care of locking, opening and closing an APT session.\n # Arguments\n\n* `aptcmdbuf` - Pointer to command buffer (should have capacity for at least 16 words)."]
    pub fn aptSendCommand(aptcmdbuf: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[doc = "Returns true if the application is currently in the foreground."]
    pub fn aptIsActive() -> bool;
}
unsafe extern "C" {
    #[doc = "Returns true if the system has told the application to close."]
    pub fn aptShouldClose() -> bool;
}
unsafe extern "C" {
    #[doc = "Returns true if the system can enter sleep mode while the application is active."]
    pub fn aptIsSleepAllowed() -> bool;
}
unsafe extern "C" {
    #[doc = "Configures whether the system can enter sleep mode while the application is active."]
    pub fn aptSetSleepAllowed(allowed: bool);
}
unsafe extern "C" {
    #[doc = "Handles incoming sleep mode requests."]
    pub fn aptHandleSleep();
}
unsafe extern "C" {
    #[doc = "Returns true if the user can press the HOME button to jump back to the HOME menu while the application is active."]
    pub fn aptIsHomeAllowed() -> bool;
}
unsafe extern "C" {
    #[doc = "Configures whether the user can press the HOME button to jump back to the HOME menu while the application is active."]
    pub fn aptSetHomeAllowed(allowed: bool);
}
unsafe extern "C" {
    #[doc = "Returns true if the system requires the application to jump back to the HOME menu."]
    pub fn aptShouldJumpToHome() -> bool;
}
unsafe extern "C" {
    #[doc = "Returns true if there is an incoming HOME button press rejected by the policy set by aptSetHomeAllowed (use this to show a \"no HOME allowed\" icon)."]
    pub fn aptCheckHomePressRejected() -> bool;
}
unsafe extern "C" {
    #[doc = "> **Deprecated** Alias for aptCheckHomePressRejected."]
    #[link_name = "aptIsHomePressed__extern"]
    pub fn aptIsHomePressed() -> bool;
}
unsafe extern "C" {
    #[doc = "Jumps back to the HOME menu."]
    pub fn aptJumpToHomeMenu();
}
unsafe extern "C" {
    #[doc = "Handles incoming jump-to-HOME requests."]
    #[link_name = "aptHandleJumpToHome__extern"]
    pub fn aptHandleJumpToHome();
}
unsafe extern "C" {
    #[doc = "Main function which handles sleep mode and HOME/power buttons - call this at the beginning of every frame.\n # Returns\n\ntrue if the application should keep running, false otherwise (see aptShouldClose)."]
    pub fn aptMainLoop() -> bool;
}
unsafe extern "C" {
    #[doc = "Sets up an APT status hook.\n # Arguments\n\n* `cookie` - Hook cookie to use.\n * `callback` - Function to call when APT's status changes.\n * `param` - User-defined parameter to pass to the callback."]
    pub fn aptHook(cookie: *mut aptHookCookie, callback: aptHookFn, param: *mut ::libc::c_void);
}
unsafe extern "C" {
    #[doc = "Removes an APT status hook.\n # Arguments\n\n* `cookie` - Hook cookie to remove."]
    pub fn aptUnhook(cookie: *mut aptHookCookie);
}
unsafe extern "C" {
    #[doc = "Sets the function to be called when an APT message from another applet is received.\n # Arguments\n\n* `callback` - Callback function.\n * `user` - User-defined data to be passed to the callback."]
    pub fn aptSetMessageCallback(callback: aptMessageCb, user: *mut ::libc::c_void);
}
unsafe extern "C" {
    #[doc = "Launches a library applet.\n # Arguments\n\n* `appId` - ID of the applet to launch.\n * `buf` - Input/output buffer that contains launch parameters on entry and result data on exit.\n * `bufsize` - Size of the buffer.\n * `handle` - Handle to pass to the library applet."]
    pub fn aptLaunchLibraryApplet(
        appId: NS_APPID,
        buf: *mut ::libc::c_void,
        bufsize: usize,
        handle: Handle,
    );
}
unsafe extern "C" {
    #[doc = "Launches a system applet.\n # Arguments\n\n* `appId` - ID of the applet to launch.\n * `buf` - Input/output buffer that contains launch parameters on entry and result data on exit.\n * `bufsize` - Size of the buffer.\n * `handle` - Handle to pass to the system applet."]
    pub fn aptLaunchSystemApplet(
        appId: NS_APPID,
        buf: *mut ::libc::c_void,
        bufsize: usize,
        handle: Handle,
    );
}
unsafe extern "C" {
    #[doc = "Clears the chainloader state."]
    pub fn aptClearChainloader();
}
unsafe extern "C" {
    #[doc = "Configures the chainloader to launch a specific application.\n # Arguments\n\n* `programID` - ID of the program to chainload to.\n * `mediatype` - Media type of the program to chainload to."]
    pub fn aptSetChainloader(programID: u64_, mediatype: u8_);
}
unsafe extern "C" {
    #[doc = "Configures the chainloader to launch the previous application."]
    pub fn aptSetChainloaderToCaller();
}
unsafe extern "C" {
    #[doc = "Configures the chainloader to relaunch the current application (i.e. soft-reset)"]
    pub fn aptSetChainloaderToSelf();
}
unsafe extern "C" {
    #[doc = "Sets the \"deliver arg\" and HMAC for the chainloader, which will\n be passed to the target 3DS/DS(i) application. The meaning of each\n parameter varies on a per-application basis.\n # Arguments\n\n* `deliverArg` - Deliver arg to pass to the target application.\n * `deliverArgSize` - Size of the deliver arg, maximum 0x300 bytes.\n * `hmac` - HMAC buffer, 32 bytes. Use NULL to pass an all-zero dummy HMAC."]
    pub fn aptSetChainloaderArgs(
        deliverArg: *const ::libc::c_void,
        deliverArgSize: usize,
        hmac: *const ::libc::c_void,
    );
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets an APT lock handle.\n # Arguments\n\n* `flags` - Flags to use.\n * `lockHandle` - Pointer to output the lock handle to."]
    pub fn APT_GetLockHandle(flags: u16_, lockHandle: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes an application's registration with APT.\n # Arguments\n\n* `appId` - ID of the application.\n * `attr` - Attributes of the application.\n * `signalEvent` - Pointer to output the signal event handle to.\n * `resumeEvent` - Pointer to output the resume event handle to."]
    pub fn APT_Initialize(
        appId: NS_APPID,
        attr: APT_AppletAttr,
        signalEvent: *mut Handle,
        resumeEvent: *mut Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Terminates an application's registration with APT.\n # Arguments\n\n* `appID` - ID of the application."]
    pub fn APT_Finalize(appId: NS_APPID) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Asynchronously resets the hardware."]
    pub fn APT_HardwareResetAsync() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Enables APT.\n # Arguments\n\n* `attr` - Attributes of the application."]
    pub fn APT_Enable(attr: APT_AppletAttr) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets applet management info.\n # Arguments\n\n* `inpos` - Requested applet position.\n * `outpos` - Pointer to output the position of the current applet to.\n * `req_appid` - Pointer to output the AppID of the applet at the requested position to.\n * `menu_appid` - Pointer to output the HOME menu AppID to.\n * `active_appid` - Pointer to output the AppID of the currently active applet to."]
    pub fn APT_GetAppletManInfo(
        inpos: APT_AppletPos,
        outpos: *mut APT_AppletPos,
        req_appid: *mut NS_APPID,
        menu_appid: *mut NS_APPID,
        active_appid: *mut NS_APPID,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Gets the menu's app ID.\n # Returns\n\nThe menu's app ID."]
    #[link_name = "aptGetMenuAppID__extern"]
    pub fn aptGetMenuAppID() -> NS_APPID;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets an applet's information.\n # Arguments\n\n* `appID` - AppID of the applet.\n * `pProgramID` - Pointer to output the program ID to.\n * `pMediaType` - Pointer to output the media type to.\n * `pRegistered` - Pointer to output the registration status to.\n * `pLoadState` - Pointer to output the load state to.\n * `pAttributes` - Pointer to output the applet atrributes to."]
    pub fn APT_GetAppletInfo(
        appID: NS_APPID,
        pProgramID: *mut u64_,
        pMediaType: *mut u8_,
        pRegistered: *mut bool,
        pLoadState: *mut bool,
        pAttributes: *mut APT_AppletAttr,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets an applet's program information.\n # Arguments\n\n* `id` - ID of the applet.\n * `flags` - Flags to use when retreiving the information.\n * `titleversion` - Pointer to output the applet's title version to.\n\n Flags:\n - 0x01: Use AM_ListTitles with NAND media type.\n - 0x02: Use AM_ListTitles with SDMC media type.\n - 0x04: Use AM_ListTitles with GAMECARD media type.\n - 0x10: Input ID is an app ID. Must be set if 0x20 is not.\n - 0x20: Input ID is a program ID. Must be set if 0x10 is not.\n - 0x100: Sets program ID high to 0x00040000, else it is 0x00040010. Only used when 0x20 is set."]
    pub fn APT_GetAppletProgramInfo(id: u32_, flags: u32_, titleversion: *mut u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current application's program ID.\n # Arguments\n\n* `pProgramID` - Pointer to output the program ID to."]
    pub fn APT_GetProgramID(pProgramID: *mut u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Prepares to jump to the home menu."]
    pub fn APT_PrepareToJumpToHomeMenu() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Jumps to the home menu.\n # Arguments\n\n* `param` - Parameters to jump with.\n * `Size` - of the parameter buffer.\n * `handle` - Handle to pass."]
    pub fn APT_JumpToHomeMenu(
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Prepares to jump to an application.\n # Arguments\n\n* `exiting` - Specifies whether the applet is exiting."]
    pub fn APT_PrepareToJumpToApplication(exiting: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Jumps to an application.\n # Arguments\n\n* `param` - Parameters to jump with.\n * `Size` - of the parameter buffer.\n * `handle` - Handle to pass."]
    pub fn APT_JumpToApplication(
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether an application is registered.\n # Arguments\n\n* `appID` - ID of the application.\n * `out` - Pointer to output the registration state to."]
    pub fn APT_IsRegistered(appID: NS_APPID, out: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Inquires as to whether a signal has been received.\n # Arguments\n\n* `appID` - ID of the application.\n * `signalType` - Pointer to output the signal type to."]
    pub fn APT_InquireNotification(appID: u32_, signalType: *mut APT_Signal) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Requests to enter sleep mode, and later sets wake events if allowed to.\n # Arguments\n\n* `wakeEvents` - The wake events. Limited to \"shell\" (bit 1) for the PDN wake events part\n and \"shell opened\", \"shell closed\" and \"HOME button pressed\" for the MCU interrupts part."]
    pub fn APT_SleepSystem(wakeEvents: *const PtmWakeEvents) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Notifies an application to wait.\n # Arguments\n\n* `appID` - ID of the application."]
    pub fn APT_NotifyToWait(appID: NS_APPID) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Calls an applet utility function.\n # Arguments\n\n* `id` - Utility function to call.\n * `out` - Pointer to write output data to.\n * `outSize` - Size of the output buffer.\n * `in` - Pointer to the input data.\n * `inSize` - Size of the input buffer."]
    pub fn APT_AppletUtility(
        id: ::libc::c_int,
        out: *mut ::libc::c_void,
        outSize: usize,
        in_: *const ::libc::c_void,
        inSize: usize,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sleeps if shell is closed (?)."]
    pub fn APT_SleepIfShellClosed() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Locks a transition (?).\n # Arguments\n\n* `transition` - Transition ID.\n * `flag` - Flag (?)"]
    pub fn APT_LockTransition(transition: u32_, flag: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Tries to lock a transition (?).\n # Arguments\n\n* `transition` - Transition ID.\n * `succeeded` - Pointer to output whether the lock was successfully applied."]
    pub fn APT_TryLockTransition(transition: u32_, succeeded: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unlocks a transition (?).\n # Arguments\n\n* `transition` - Transition ID."]
    pub fn APT_UnlockTransition(transition: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Glances at a receieved parameter without removing it from the queue.\n # Arguments\n\n* `appID` - AppID of the application.\n * `buffer` - Buffer to receive to.\n * `bufferSize` - Size of the buffer.\n * `sender` - Pointer to output the sender's AppID to.\n * `command` - Pointer to output the command ID to.\n * `actualSize` - Pointer to output the actual received data size to.\n * `parameter` - Pointer to output the parameter handle to."]
    pub fn APT_GlanceParameter(
        appID: NS_APPID,
        buffer: *mut ::libc::c_void,
        bufferSize: usize,
        sender: *mut NS_APPID,
        command: *mut APT_Command,
        actualSize: *mut usize,
        parameter: *mut Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Receives a parameter.\n # Arguments\n\n* `appID` - AppID of the application.\n * `buffer` - Buffer to receive to.\n * `bufferSize` - Size of the buffer.\n * `sender` - Pointer to output the sender's AppID to.\n * `command` - Pointer to output the command ID to.\n * `actualSize` - Pointer to output the actual received data size to.\n * `parameter` - Pointer to output the parameter handle to."]
    pub fn APT_ReceiveParameter(
        appID: NS_APPID,
        buffer: *mut ::libc::c_void,
        bufferSize: usize,
        sender: *mut NS_APPID,
        command: *mut APT_Command,
        actualSize: *mut usize,
        parameter: *mut Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sends a parameter.\n # Arguments\n\n* `source` - AppID of the source application.\n * `dest` - AppID of the destination application.\n * `command` - Command to send.\n * `buffer` - Buffer to send.\n * `bufferSize` - Size of the buffer.\n * `parameter` - Parameter handle to pass."]
    pub fn APT_SendParameter(
        source: NS_APPID,
        dest: NS_APPID,
        command: APT_Command,
        buffer: *const ::libc::c_void,
        bufferSize: u32_,
        parameter: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Cancels a parameter which matches the specified source and dest AppIDs.\n # Arguments\n\n* `source` - AppID of the source application (use APPID_NONE to disable the check).\n * `dest` - AppID of the destination application (use APPID_NONE to disable the check).\n * `success` - Pointer to output true if a parameter was cancelled, or false otherwise."]
    pub fn APT_CancelParameter(source: NS_APPID, dest: NS_APPID, success: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sends capture buffer information.\n # Arguments\n\n* `captureBuf` - Capture buffer information to send."]
    pub fn APT_SendCaptureBufferInfo(captureBuf: *const aptCaptureBufInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Replies to a sleep query.\n # Arguments\n\n* `appID` - ID of the application.\n * `reply` - Query reply value."]
    pub fn APT_ReplySleepQuery(appID: NS_APPID, reply: APT_QueryReply) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Replies that a sleep notification has been completed.\n # Arguments\n\n* `appID` - ID of the application."]
    pub fn APT_ReplySleepNotificationComplete(appID: NS_APPID) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Prepares to close the application.\n # Arguments\n\n* `cancelPreload` - Whether applet preloads should be cancelled."]
    pub fn APT_PrepareToCloseApplication(cancelPreload: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Closes the application.\n # Arguments\n\n* `param` - Parameters to close with.\n * `paramSize` - Size of param.\n * `handle` - Handle to pass."]
    pub fn APT_CloseApplication(
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the application's CPU time limit.\n # Arguments\n\n* `percent` - CPU time limit percentage to set."]
    pub fn APT_SetAppCpuTimeLimit(percent: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the application's CPU time limit.\n # Arguments\n\n* `percent` - Pointer to output the CPU time limit percentage to."]
    pub fn APT_GetAppCpuTimeLimit(percent: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks whether the system is a New 3DS.\n # Arguments\n\n* `out` - Pointer to write the New 3DS flag to."]
    pub fn APT_CheckNew3DS(out: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Prepares for an applicaton jump.\n # Arguments\n\n* `flags` - Flags to use.\n * `programID` - ID of the program to jump to.\n * `mediatype` - Media type of the program to jump to."]
    pub fn APT_PrepareToDoApplicationJump(flags: u8_, programID: u64_, mediatype: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Performs an application jump.\n # Arguments\n\n* `param` - Parameter buffer.\n * `paramSize` - Size of parameter buffer.\n * `hmac` - HMAC buffer (should be 0x20 bytes long)."]
    pub fn APT_DoApplicationJump(
        param: *const ::libc::c_void,
        paramSize: usize,
        hmac: *const ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Prepares to start a library applet.\n # Arguments\n\n* `appID` - AppID of the applet to start."]
    pub fn APT_PrepareToStartLibraryApplet(appID: NS_APPID) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Starts a library applet.\n # Arguments\n\n* `appID` - AppID of the applet to launch.\n * `param` - Buffer containing applet parameters.\n * `paramsize` - Size of the buffer.\n * `handle` - Handle to pass to the applet."]
    pub fn APT_StartLibraryApplet(
        appID: NS_APPID,
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Prepares to start a system applet.\n # Arguments\n\n* `appID` - AppID of the applet to start."]
    pub fn APT_PrepareToStartSystemApplet(appID: NS_APPID) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Starts a system applet.\n # Arguments\n\n* `appID` - AppID of the applet to launch.\n * `param` - Buffer containing applet parameters.\n * `paramSize` - Size of the parameter buffer.\n * `handle` - Handle to pass to the applet."]
    pub fn APT_StartSystemApplet(
        appID: NS_APPID,
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrieves the shared system font.\n fontHandle Pointer to write the handle of the system font memory block to.\n mapAddr Pointer to write the mapping address of the system font memory block to."]
    pub fn APT_GetSharedFont(fontHandle: *mut Handle, mapAddr: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Receives the deliver (launch) argument\n # Arguments\n\n* `param` - Parameter buffer.\n * `paramSize` - Size of parameter buffer.\n * `hmac` - HMAC buffer (should be 0x20 bytes long).\n * `sender` - Pointer to output the sender's AppID to.\n * `received` - Pointer to output whether an argument was received to."]
    pub fn APT_ReceiveDeliverArg(
        param: *mut ::libc::c_void,
        paramSize: usize,
        hmac: *mut ::libc::c_void,
        sender: *mut u64_,
        received: *mut bool,
    ) -> Result;
}
#[doc = "BOSS context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bossContext {
    pub property: [u32_; 7usize],
    pub url: [::libc::c_char; 512usize],
    pub property_x8: u32_,
    pub property_x9: u8_,
    pub property_xa: [u8_; 256usize],
    pub property_xb: [u8_; 512usize],
    pub property_xd: [::libc::c_char; 864usize],
    pub property_xe: u32_,
    pub property_xf: [u32_; 3usize],
    pub property_x10: u8_,
    pub property_x11: u8_,
    pub property_x12: u8_,
    pub property_x13: u32_,
    pub property_x14: u32_,
    pub property_x15: [u8_; 64usize],
    pub property_x16: u32_,
    pub property_x3b: u32_,
    pub property_x3e: [u8_; 512usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bossContext"][::core::mem::size_of::<bossContext>() - 2792usize];
    ["Alignment of bossContext"][::core::mem::align_of::<bossContext>() - 4usize];
    ["Offset of field: bossContext::property"]
        [::core::mem::offset_of!(bossContext, property) - 0usize];
    ["Offset of field: bossContext::url"][::core::mem::offset_of!(bossContext, url) - 28usize];
    ["Offset of field: bossContext::property_x8"]
        [::core::mem::offset_of!(bossContext, property_x8) - 540usize];
    ["Offset of field: bossContext::property_x9"]
        [::core::mem::offset_of!(bossContext, property_x9) - 544usize];
    ["Offset of field: bossContext::property_xa"]
        [::core::mem::offset_of!(bossContext, property_xa) - 545usize];
    ["Offset of field: bossContext::property_xb"]
        [::core::mem::offset_of!(bossContext, property_xb) - 801usize];
    ["Offset of field: bossContext::property_xd"]
        [::core::mem::offset_of!(bossContext, property_xd) - 1313usize];
    ["Offset of field: bossContext::property_xe"]
        [::core::mem::offset_of!(bossContext, property_xe) - 2180usize];
    ["Offset of field: bossContext::property_xf"]
        [::core::mem::offset_of!(bossContext, property_xf) - 2184usize];
    ["Offset of field: bossContext::property_x10"]
        [::core::mem::offset_of!(bossContext, property_x10) - 2196usize];
    ["Offset of field: bossContext::property_x11"]
        [::core::mem::offset_of!(bossContext, property_x11) - 2197usize];
    ["Offset of field: bossContext::property_x12"]
        [::core::mem::offset_of!(bossContext, property_x12) - 2198usize];
    ["Offset of field: bossContext::property_x13"]
        [::core::mem::offset_of!(bossContext, property_x13) - 2200usize];
    ["Offset of field: bossContext::property_x14"]
        [::core::mem::offset_of!(bossContext, property_x14) - 2204usize];
    ["Offset of field: bossContext::property_x15"]
        [::core::mem::offset_of!(bossContext, property_x15) - 2208usize];
    ["Offset of field: bossContext::property_x16"]
        [::core::mem::offset_of!(bossContext, property_x16) - 2272usize];
    ["Offset of field: bossContext::property_x3b"]
        [::core::mem::offset_of!(bossContext, property_x3b) - 2276usize];
    ["Offset of field: bossContext::property_x3e"]
        [::core::mem::offset_of!(bossContext, property_x3e) - 2280usize];
};
impl Default for bossContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BOSSTASKSTATUS_STARTED: bossTaskStatus = 2;
pub const BOSSTASKSTATUS_ERROR: bossTaskStatus = 7;
#[doc = "BOSS task status."]
pub type bossTaskStatus = ::libc::c_uchar;
pub const bossNsDataHeaderInfoType_ContentSize: bossNsDataHeaderInfoTypes = 3;
#[doc = "Type values for bossGetNsDataHeaderInfo()."]
pub type bossNsDataHeaderInfoTypes = ::libc::c_uchar;
pub const bossNsDataHeaderInfoTypeSize_ContentSize: bossNsDataHeaderInfoTypeSizes = 4;
#[doc = "Size of the output data for bossGetNsDataHeaderInfo()."]
pub type bossNsDataHeaderInfoTypeSizes = ::libc::c_uchar;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes BOSS.\n # Arguments\n\n* `programID` - programID to use, 0 for the current process. Only used when BOSSP is available without *hax payload.\n * `force_user` - When true, just use bossU instead of trying to initialize with bossP first."]
    pub fn bossInit(programID: u64_, force_user: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Run the InitializeSession service cmd. This is mainly for changing the programID associated with the current BOSS session.\n # Arguments\n\n* `programID` - programID to use, 0 for the current process."]
    pub fn bossReinit(programID: u64_) -> Result;
}
unsafe extern "C" {
    #[doc = "Exits BOSS."]
    pub fn bossExit();
}
unsafe extern "C" {
    #[doc = "Returns the BOSS session handle."]
    pub fn bossGetSessionHandle() -> Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Set the content data storage location.\n # Arguments\n\n* `extdataID` - u64 extdataID, must have the high word set to the shared-extdata value when it's for NAND.\n * `boss_size` - Probably the max size in the extdata which BOSS can use.\n * `mediaType` - Roughly the same as FS mediatype."]
    pub fn bossSetStorageInfo(extdataID: u64_, boss_size: u32_, mediaType: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unregister the content data storage location, which includes unregistering the BOSS-session programID with BOSS."]
    pub fn bossUnregisterStorage() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Register a task.\n # Arguments\n\n* `taskID` - BOSS taskID.\n * `unk0` - Unknown, usually zero.\n * `unk1` - Unknown, usually zero."]
    pub fn bossRegisterTask(taskID: *const ::libc::c_char, unk0: u8_, unk1: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Send a property.\n # Arguments\n\n* `PropertyID` - PropertyID\n * `buf` - Input buffer data.\n * `size` - Buffer size."]
    pub fn bossSendProperty(PropertyID: u16_, buf: *const ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes the content file for the specified NsDataId.\n # Arguments\n\n* `NsDataId` - NsDataId"]
    pub fn bossDeleteNsData(NsDataId: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets header info for the specified NsDataId.\n # Arguments\n\n* `NsDataId` - NsDataId\n * `type` - Type of data to load.\n * `buffer` - Output buffer.\n * `size` - Output buffer size."]
    pub fn bossGetNsDataHeaderInfo(
        NsDataId: u32_,
        type_: u8_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads data from the content for the specified NsDataId.\n # Arguments\n\n* `NsDataId` - NsDataId\n * `offset` - Offset in the content.\n * `buffer` - Output buffer.\n * `size` - Output buffer size.\n * `transfer_total` - Optional output actual read size, can be NULL.\n * `unk_out` - Optional unknown output, can be NULL."]
    pub fn bossReadNsData(
        NsDataId: u32_,
        offset: u64_,
        buffer: *mut ::libc::c_void,
        size: u32_,
        transfer_total: *mut u32_,
        unk_out: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Starts a task soon after running this command.\n # Arguments\n\n* `taskID` - BOSS taskID."]
    pub fn bossStartTaskImmediate(taskID: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Similar to bossStartTaskImmediate?\n # Arguments\n\n* `taskID` - BOSS taskID."]
    pub fn bossStartBgImmediate(taskID: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes a task by using CancelTask and UnregisterTask internally.\n # Arguments\n\n* `taskID` - BOSS taskID.\n * `unk` - Unknown, usually zero?"]
    pub fn bossDeleteTask(taskID: *const ::libc::c_char, unk: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns task state.\n # Arguments\n\n* `taskID` - BOSS taskID.\n * `inval` - Unknown, normally 0?\n * `status` - Output status, see bossTaskStatus.\n * `out1` - Output field.\n * `out2` - Output field."]
    pub fn bossGetTaskState(
        taskID: *const ::libc::c_char,
        inval: s8,
        status: *mut u8_,
        out1: *mut u32_,
        out2: *mut u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This loads the current state of PropertyID 0x0 for the specified task.\n # Arguments\n\n* `taskID` - BOSS taskID."]
    pub fn bossGetTaskProperty0(taskID: *const ::libc::c_char, out: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[doc = "Setup a BOSS context with the default config.\n # Arguments\n\n* `bossContext` - BOSS context.\n * `seconds_interval` - Interval in seconds for running the task automatically.\n * `url` - Task URL."]
    pub fn bossSetupContextDefault(
        ctx: *mut bossContext,
        seconds_interval: u32_,
        url: *const ::libc::c_char,
    );
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sends the config stored in the context. Used before registering a task.\n # Arguments\n\n* `bossContext` - BOSS context."]
    pub fn bossSendContextConfig(ctx: *mut bossContext) -> Result;
}
#[doc = "< 8-bit per component, planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples).Usually named YUV422P."]
pub const INPUT_YUV422_INDIV_8: Y2RU_InputFormat = 0;
#[doc = "< 8-bit per component, planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples).Usually named YUV420P."]
pub const INPUT_YUV420_INDIV_8: Y2RU_InputFormat = 1;
#[doc = "< 16-bit per component, planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples).Usually named YUV422P16."]
pub const INPUT_YUV422_INDIV_16: Y2RU_InputFormat = 2;
#[doc = "< 16-bit per component, planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples).Usually named YUV420P16."]
pub const INPUT_YUV420_INDIV_16: Y2RU_InputFormat = 3;
#[doc = "< 8-bit per component, packed YUV 4:2:2, 16bpp, (Y0 Cb Y1 Cr).Usually named YUYV422."]
pub const INPUT_YUV422_BATCH: Y2RU_InputFormat = 4;
#[doc = "Input color formats\n\n For the 16-bit per component formats, bits 15-8 are padding and 7-0 contains the value."]
pub type Y2RU_InputFormat = ::libc::c_uchar;
#[doc = "< 32-bit RGBA8888. The alpha component is the 8-bit value set by Y2RU_SetAlpha"]
pub const OUTPUT_RGB_32: Y2RU_OutputFormat = 0;
#[doc = "< 24-bit RGB888."]
pub const OUTPUT_RGB_24: Y2RU_OutputFormat = 1;
#[doc = "< 16-bit RGBA5551. The alpha bit is the 7th bit of the alpha value set by Y2RU_SetAlpha"]
pub const OUTPUT_RGB_16_555: Y2RU_OutputFormat = 2;
#[doc = "< 16-bit RGB565."]
pub const OUTPUT_RGB_16_565: Y2RU_OutputFormat = 3;
#[doc = "Output color formats\n\n Those are the same as the framebuffer and GPU texture formats."]
pub type Y2RU_OutputFormat = ::libc::c_uchar;
#[doc = "< No rotation."]
pub const ROTATION_NONE: Y2RU_Rotation = 0;
#[doc = "< Clockwise 90 degrees."]
pub const ROTATION_CLOCKWISE_90: Y2RU_Rotation = 1;
#[doc = "< Clockwise 180 degrees."]
pub const ROTATION_CLOCKWISE_180: Y2RU_Rotation = 2;
#[doc = "< Clockwise 270 degrees."]
pub const ROTATION_CLOCKWISE_270: Y2RU_Rotation = 3;
#[doc = "Rotation to be applied to the output."]
pub type Y2RU_Rotation = ::libc::c_uchar;
#[doc = "< The result buffer will be laid out in linear format, the usual way."]
pub const BLOCK_LINE: Y2RU_BlockAlignment = 0;
#[doc = "< The result will be stored as 8x8 blocks in Z-order.Useful for textures since it is the format used by the PICA200."]
pub const BLOCK_8_BY_8: Y2RU_BlockAlignment = 1;
#[doc = "Block alignment of output\n\n Defines the way the output will be laid out in memory."]
pub type Y2RU_BlockAlignment = ::libc::c_uchar;
#[doc = "Coefficients of the YUV->RGB conversion formula.\n\n A set of coefficients configuring the RGB to YUV conversion. Coefficients 0-4 are unsigned 2.8\n fixed pointer numbers representing entries on the conversion matrix, while coefficient 5-7 are\n signed 11.5 fixed point numbers added as offsets to the RGB result.\n\n The overall conversion process formula is:\n R = trunc((rgb_Y * Y + r_V * V) + 0.75 + r_offset)\n G = trunc((rgb_Y * Y - g_U * U - g_V * V) + 0.75 + g_offset)\n B = trunc((rgb_Y * Y + b_U * U ) + 0.75 + b_offset)\n "]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Y2RU_ColorCoefficients {
    #[doc = "< RGB per unit Y."]
    pub rgb_Y: u16_,
    #[doc = "< Red per unit V."]
    pub r_V: u16_,
    #[doc = "< Green per unit V."]
    pub g_V: u16_,
    #[doc = "< Green per unit U."]
    pub g_U: u16_,
    #[doc = "< Blue per unit U."]
    pub b_U: u16_,
    #[doc = "< Red offset."]
    pub r_offset: u16_,
    #[doc = "< Green offset."]
    pub g_offset: u16_,
    #[doc = "< Blue offset."]
    pub b_offset: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Y2RU_ColorCoefficients"][::core::mem::size_of::<Y2RU_ColorCoefficients>() - 16usize];
    ["Alignment of Y2RU_ColorCoefficients"]
        [::core::mem::align_of::<Y2RU_ColorCoefficients>() - 2usize];
    ["Offset of field: Y2RU_ColorCoefficients::rgb_Y"]
        [::core::mem::offset_of!(Y2RU_ColorCoefficients, rgb_Y) - 0usize];
    ["Offset of field: Y2RU_ColorCoefficients::r_V"]
        [::core::mem::offset_of!(Y2RU_ColorCoefficients, r_V) - 2usize];
    ["Offset of field: Y2RU_ColorCoefficients::g_V"]
        [::core::mem::offset_of!(Y2RU_ColorCoefficients, g_V) - 4usize];
    ["Offset of field: Y2RU_ColorCoefficients::g_U"]
        [::core::mem::offset_of!(Y2RU_ColorCoefficients, g_U) - 6usize];
    ["Offset of field: Y2RU_ColorCoefficients::b_U"]
        [::core::mem::offset_of!(Y2RU_ColorCoefficients, b_U) - 8usize];
    ["Offset of field: Y2RU_ColorCoefficients::r_offset"]
        [::core::mem::offset_of!(Y2RU_ColorCoefficients, r_offset) - 10usize];
    ["Offset of field: Y2RU_ColorCoefficients::g_offset"]
        [::core::mem::offset_of!(Y2RU_ColorCoefficients, g_offset) - 12usize];
    ["Offset of field: Y2RU_ColorCoefficients::b_offset"]
        [::core::mem::offset_of!(Y2RU_ColorCoefficients, b_offset) - 14usize];
};
#[doc = "< Coefficients from the ITU-R BT.601 standard with PC ranges."]
pub const COEFFICIENT_ITU_R_BT_601: Y2RU_StandardCoefficient = 0;
#[doc = "< Coefficients from the ITU-R BT.709 standard with PC ranges."]
pub const COEFFICIENT_ITU_R_BT_709: Y2RU_StandardCoefficient = 1;
#[doc = "< Coefficients from the ITU-R BT.601 standard with TV ranges."]
pub const COEFFICIENT_ITU_R_BT_601_SCALING: Y2RU_StandardCoefficient = 2;
#[doc = "< Coefficients from the ITU-R BT.709 standard with TV ranges."]
pub const COEFFICIENT_ITU_R_BT_709_SCALING: Y2RU_StandardCoefficient = 3;
#[doc = "Preset conversion coefficients based on ITU standards for the YUV->RGB formula.\n\n For more details refer to Y2RU_ColorCoefficients"]
pub type Y2RU_StandardCoefficient = ::libc::c_uchar;
#[doc = "Structure used to configure all parameters at once.\n\n You can send a batch of configuration parameters using this structure and Y2RU_SetConversionParams."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Y2RU_ConversionParams {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Value passed to Y2RU_SetInputLineWidth"]
    pub input_line_width: s16,
    #[doc = "< Value passed to Y2RU_SetInputLines"]
    pub input_lines: s16,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Unused."]
    pub unused: u8_,
    #[doc = "< Value passed to Y2RU_SetAlpha"]
    pub alpha: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Y2RU_ConversionParams"][::core::mem::size_of::<Y2RU_ConversionParams>() - 12usize];
    ["Alignment of Y2RU_ConversionParams"]
        [::core::mem::align_of::<Y2RU_ConversionParams>() - 2usize];
    ["Offset of field: Y2RU_ConversionParams::input_line_width"]
        [::core::mem::offset_of!(Y2RU_ConversionParams, input_line_width) - 4usize];
    ["Offset of field: Y2RU_ConversionParams::input_lines"]
        [::core::mem::offset_of!(Y2RU_ConversionParams, input_lines) - 6usize];
    ["Offset of field: Y2RU_ConversionParams::unused"]
        [::core::mem::offset_of!(Y2RU_ConversionParams, unused) - 9usize];
    ["Offset of field: Y2RU_ConversionParams::alpha"]
        [::core::mem::offset_of!(Y2RU_ConversionParams, alpha) - 10usize];
};
impl Default for Y2RU_ConversionParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Y2RU_ConversionParams {
    #[inline]
    pub fn input_format(&self) -> Y2RU_InputFormat {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_input_format(&mut self, val: Y2RU_InputFormat) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn input_format_raw(this: *const Self) -> Y2RU_InputFormat {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_input_format_raw(this: *mut Self, val: Y2RU_InputFormat) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn output_format(&self) -> Y2RU_OutputFormat {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_output_format(&mut self, val: Y2RU_OutputFormat) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn output_format_raw(this: *const Self) -> Y2RU_OutputFormat {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_output_format_raw(this: *mut Self, val: Y2RU_OutputFormat) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rotation(&self) -> Y2RU_Rotation {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_rotation(&mut self, val: Y2RU_Rotation) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rotation_raw(this: *const Self) -> Y2RU_Rotation {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rotation_raw(this: *mut Self, val: Y2RU_Rotation) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn block_alignment(&self) -> Y2RU_BlockAlignment {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_block_alignment(&mut self, val: Y2RU_BlockAlignment) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn block_alignment_raw(this: *const Self) -> Y2RU_BlockAlignment {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_block_alignment_raw(this: *mut Self, val: Y2RU_BlockAlignment) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        input_format: Y2RU_InputFormat,
        output_format: Y2RU_OutputFormat,
        rotation: Y2RU_Rotation,
        block_alignment: Y2RU_BlockAlignment,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let input_format: u8 = unsafe { ::core::mem::transmute(input_format) };
            input_format as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let output_format: u8 = unsafe { ::core::mem::transmute(output_format) };
            output_format as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let rotation: u8 = unsafe { ::core::mem::transmute(rotation) };
            rotation as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let block_alignment: u8 = unsafe { ::core::mem::transmute(block_alignment) };
            block_alignment as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn standard_coefficient(&self) -> Y2RU_StandardCoefficient {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_standard_coefficient(&mut self, val: Y2RU_StandardCoefficient) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn standard_coefficient_raw(this: *const Self) -> Y2RU_StandardCoefficient {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                8u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_standard_coefficient_raw(this: *mut Self, val: Y2RU_StandardCoefficient) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        standard_coefficient: Y2RU_StandardCoefficient,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let standard_coefficient: u8 = unsafe { ::core::mem::transmute(standard_coefficient) };
            standard_coefficient as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Dithering weights."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Y2RU_DitheringWeightParams {
    #[doc = "< Weight 0 for even X, even Y."]
    pub w0_xEven_yEven: u16_,
    #[doc = "< Weight 0 for odd X, even Y."]
    pub w0_xOdd_yEven: u16_,
    #[doc = "< Weight 0 for even X, odd Y."]
    pub w0_xEven_yOdd: u16_,
    #[doc = "< Weight 0 for odd X, odd Y."]
    pub w0_xOdd_yOdd: u16_,
    #[doc = "< Weight 1 for even X, even Y."]
    pub w1_xEven_yEven: u16_,
    #[doc = "< Weight 1 for odd X, even Y."]
    pub w1_xOdd_yEven: u16_,
    #[doc = "< Weight 1 for even X, odd Y."]
    pub w1_xEven_yOdd: u16_,
    #[doc = "< Weight 1 for odd X, odd Y."]
    pub w1_xOdd_yOdd: u16_,
    #[doc = "< Weight 2 for even X, even Y."]
    pub w2_xEven_yEven: u16_,
    #[doc = "< Weight 2 for odd X, even Y."]
    pub w2_xOdd_yEven: u16_,
    #[doc = "< Weight 2 for even X, odd Y."]
    pub w2_xEven_yOdd: u16_,
    #[doc = "< Weight 2 for odd X, odd Y."]
    pub w2_xOdd_yOdd: u16_,
    #[doc = "< Weight 3 for even X, even Y."]
    pub w3_xEven_yEven: u16_,
    #[doc = "< Weight 3 for odd X, even Y."]
    pub w3_xOdd_yEven: u16_,
    #[doc = "< Weight 3 for even X, odd Y."]
    pub w3_xEven_yOdd: u16_,
    #[doc = "< Weight 3 for odd X, odd Y."]
    pub w3_xOdd_yOdd: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Y2RU_DitheringWeightParams"]
        [::core::mem::size_of::<Y2RU_DitheringWeightParams>() - 32usize];
    ["Alignment of Y2RU_DitheringWeightParams"]
        [::core::mem::align_of::<Y2RU_DitheringWeightParams>() - 2usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w0_xEven_yEven"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w0_xEven_yEven) - 0usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w0_xOdd_yEven"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w0_xOdd_yEven) - 2usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w0_xEven_yOdd"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w0_xEven_yOdd) - 4usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w0_xOdd_yOdd"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w0_xOdd_yOdd) - 6usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w1_xEven_yEven"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w1_xEven_yEven) - 8usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w1_xOdd_yEven"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w1_xOdd_yEven) - 10usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w1_xEven_yOdd"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w1_xEven_yOdd) - 12usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w1_xOdd_yOdd"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w1_xOdd_yOdd) - 14usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w2_xEven_yEven"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w2_xEven_yEven) - 16usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w2_xOdd_yEven"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w2_xOdd_yEven) - 18usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w2_xEven_yOdd"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w2_xEven_yOdd) - 20usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w2_xOdd_yOdd"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w2_xOdd_yOdd) - 22usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w3_xEven_yEven"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w3_xEven_yEven) - 24usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w3_xOdd_yEven"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w3_xOdd_yEven) - 26usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w3_xEven_yOdd"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w3_xEven_yOdd) - 28usize];
    ["Offset of field: Y2RU_DitheringWeightParams::w3_xOdd_yOdd"]
        [::core::mem::offset_of!(Y2RU_DitheringWeightParams, w3_xOdd_yOdd) - 30usize];
};
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the y2r service.\n\n This will internally get the handle of the service, and on success call Y2RU_DriverInitialize."]
    pub fn y2rInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Closes the y2r service.\n\n This will internally call Y2RU_DriverFinalize and close the handle of the service."]
    pub fn y2rExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Used to configure the input format.\n # Arguments\n\n* `format` - Input format to use.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetInputFormat(format: Y2RU_InputFormat) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the configured input format.\n # Arguments\n\n* `format` - Pointer to output the input format to."]
    pub fn Y2RU_GetInputFormat(format: *mut Y2RU_InputFormat) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Used to configure the output format.\n # Arguments\n\n* `format` - Output format to use.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetOutputFormat(format: Y2RU_OutputFormat) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the configured output format.\n # Arguments\n\n* `format` - Pointer to output the output format to."]
    pub fn Y2RU_GetOutputFormat(format: *mut Y2RU_OutputFormat) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Used to configure the rotation of the output.\n # Arguments\n\n* `rotation` - Rotation to use.\n\n It seems to apply the rotation per batch of 8 lines, so the output will be (height/8) images of size 8 x width.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetRotation(rotation: Y2RU_Rotation) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the configured rotation.\n # Arguments\n\n* `rotation` - Pointer to output the rotation to."]
    pub fn Y2RU_GetRotation(rotation: *mut Y2RU_Rotation) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Used to configure the alignment of the output buffer.\n # Arguments\n\n* `alignment` - Alignment to use.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetBlockAlignment(alignment: Y2RU_BlockAlignment) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the configured alignment.\n # Arguments\n\n* `alignment` - Pointer to output the alignment to."]
    pub fn Y2RU_GetBlockAlignment(alignment: *mut Y2RU_BlockAlignment) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets whether to use spacial dithering.\n # Arguments\n\n* `enable` - Whether to use spacial dithering."]
    pub fn Y2RU_SetSpacialDithering(enable: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether to use spacial dithering.\n # Arguments\n\n* `enable` - Pointer to output the spacial dithering state to."]
    pub fn Y2RU_GetSpacialDithering(enabled: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets whether to use temporal dithering.\n # Arguments\n\n* `enable` - Whether to use temporal dithering."]
    pub fn Y2RU_SetTemporalDithering(enable: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether to use temporal dithering.\n # Arguments\n\n* `enable` - Pointer to output the temporal dithering state to."]
    pub fn Y2RU_GetTemporalDithering(enabled: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Used to configure the width of the image.\n # Arguments\n\n* `line_width` - Width of the image in pixels. Must be a multiple of 8, up to 1024.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetInputLineWidth(line_width: u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the configured input line width.\n # Arguments\n\n* `line_width` - Pointer to output the line width to."]
    pub fn Y2RU_GetInputLineWidth(line_width: *mut u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Used to configure the height of the image.\n # Arguments\n\n* `num_lines` - Number of lines to be converted.\n\n A multiple of 8 seems to be preferred.\n If using the BLOCK_8_BY_8 mode, it must be a multiple of 8.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetInputLines(num_lines: u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the configured number of input lines.\n # Arguments\n\n* `num_lines` - Pointer to output the input lines to."]
    pub fn Y2RU_GetInputLines(num_lines: *mut u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Used to configure the color conversion formula.\n # Arguments\n\n* `coefficients` - Coefficients to use.\n\n See Y2RU_ColorCoefficients for more information about the coefficients.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetCoefficients(coefficients: *const Y2RU_ColorCoefficients) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the configured color coefficients.\n # Arguments\n\n* `num_lines` - Pointer to output the coefficients to."]
    pub fn Y2RU_GetCoefficients(coefficients: *mut Y2RU_ColorCoefficients) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Used to configure the color conversion formula with ITU stantards coefficients.\n # Arguments\n\n* `coefficient` - Standard coefficient to use.\n\n See Y2RU_ColorCoefficients for more information about the coefficients.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetStandardCoefficient(coefficient: Y2RU_StandardCoefficient) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the color coefficient parameters of a standard coefficient.\n # Arguments\n\n* `coefficients` - Pointer to output the coefficients to.\n * `standardCoeff` - Standard coefficient to check."]
    pub fn Y2RU_GetStandardCoefficient(
        coefficients: *mut Y2RU_ColorCoefficients,
        standardCoeff: Y2RU_StandardCoefficient,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Used to configure the alpha value of the output.\n # Arguments\n\n* `alpha` - 8-bit value to be used for the output when the format requires it.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetAlpha(alpha: u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the configured output alpha value.\n # Arguments\n\n* `alpha` - Pointer to output the alpha value to."]
    pub fn Y2RU_GetAlpha(alpha: *mut u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Used to enable the end of conversion interrupt.\n # Arguments\n\n* `should_interrupt` - Enables the interrupt if true, disable it if false.\n\n It is possible to fire an interrupt when the conversion is finished, and that the DMA is done copying the data.\n This interrupt will then be used to fire an event. See Y2RU_GetTransferEndEvent.\n By default the interrupt is enabled.\n\n > **Note:** It seems that the event can be fired too soon in some cases, depending the transfer_unit size.Please see the note at Y2RU_SetReceiving"]
    pub fn Y2RU_SetTransferEndInterrupt(should_interrupt: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether the transfer end interrupt is enabled.\n # Arguments\n\n* `should_interrupt` - Pointer to output the interrupt state to."]
    pub fn Y2RU_GetTransferEndInterrupt(should_interrupt: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets an handle to the end of conversion event.\n # Arguments\n\n* `end_event` - Pointer to the event handle to be set to the end of conversion event. It isn't necessary to create or close this handle.\n\n To enable this event you have to use C} Y2RU_SetTransferEndInterrupt(true);The event will be triggered when the corresponding interrupt is fired.\n\n > **Note:** It is recommended to use a timeout when waiting on this event, as it sometimes (but rarely) isn't triggered."]
    pub fn Y2RU_GetTransferEndEvent(end_event: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures the Y plane buffer.\n # Arguments\n\n* `src_buf` - A pointer to the beginning of your Y data buffer.\n * `image_size` - The total size of the data buffer.\n * `transfer_unit` - Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n * `transfer_gap` - Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n This specifies the Y data buffer for the planar input formats (INPUT_YUV42*_INDIV_*).\n The actual transfer will only happen after calling Y2RU_StartConversion."]
    pub fn Y2RU_SetSendingY(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures the U plane buffer.\n # Arguments\n\n* `src_buf` - A pointer to the beginning of your Y data buffer.\n * `image_size` - The total size of the data buffer.\n * `transfer_unit` - Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n * `transfer_gap` - Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n This specifies the U data buffer for the planar input formats (INPUT_YUV42*_INDIV_*).\n The actual transfer will only happen after calling Y2RU_StartConversion."]
    pub fn Y2RU_SetSendingU(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures the V plane buffer.\n # Arguments\n\n* `src_buf` - A pointer to the beginning of your Y data buffer.\n * `image_size` - The total size of the data buffer.\n * `transfer_unit` - Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n * `transfer_gap` - Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n This specifies the V data buffer for the planar input formats (INPUT_YUV42*_INDIV_*).\n The actual transfer will only happen after calling Y2RU_StartConversion."]
    pub fn Y2RU_SetSendingV(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures the YUYV source buffer.\n # Arguments\n\n* `src_buf` - A pointer to the beginning of your Y data buffer.\n * `image_size` - The total size of the data buffer.\n * `transfer_unit` - Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n * `transfer_gap` - Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n This specifies the YUYV data buffer for the packed input format INPUT_YUV422_BATCH.\n The actual transfer will only happen after calling Y2RU_StartConversion."]
    pub fn Y2RU_SetSendingYUYV(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures the destination buffer.\n # Arguments\n\n* `src_buf` - A pointer to the beginning of your destination buffer in FCRAM\n * `image_size` - The total size of the data buffer.\n * `transfer_unit` - Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n * `transfer_gap` - Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n This specifies the destination buffer of the conversion.\n The actual transfer will only happen after calling Y2RU_StartConversion.\n The buffer does NOT need to be allocated in the linear heap.\n\n transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n > **Note:** It seems that depending on the size of the image and of the transfer unit,it is possible for the end of conversion interrupt to be triggered right after the conversion began.One line as transfer_unit seems to trigger this issue for 400x240, setting to 2/4/8 lines fixes it.\n\n > **Note:** Setting a transfer_unit of 4 or 8 lines seems to bring the best results in terms of speed for a 400x240 image."]
    pub fn Y2RU_SetReceiving(
        dst_buf: *mut ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the Y buffer.\n # Arguments\n\n* `is_done` - Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring the Y plane, false otherwise. To be used with Y2RU_SetSendingY."]
    pub fn Y2RU_IsDoneSendingY(is_done: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the U buffer.\n # Arguments\n\n* `is_done` - Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring the U plane, false otherwise. To be used with Y2RU_SetSendingU."]
    pub fn Y2RU_IsDoneSendingU(is_done: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the V buffer.\n # Arguments\n\n* `is_done` - Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring the V plane, false otherwise. To be used with Y2RU_SetSendingV."]
    pub fn Y2RU_IsDoneSendingV(is_done: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the YUYV buffer.\n # Arguments\n\n* `is_done` - Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring the YUYV buffer, false otherwise. To be used with Y2RU_SetSendingYUYV."]
    pub fn Y2RU_IsDoneSendingYUYV(is_done: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the converted result.\n # Arguments\n\n* `is_done` - Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring data to your destination buffer, false otherwise."]
    pub fn Y2RU_IsDoneReceiving(is_done: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures the dithering weight parameters.\n # Arguments\n\n* `params` - Dithering weight parameters to use."]
    pub fn Y2RU_SetDitheringWeightParams(params: *const Y2RU_DitheringWeightParams) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the configured dithering weight parameters.\n # Arguments\n\n* `params` - Pointer to output the dithering weight parameters to."]
    pub fn Y2RU_GetDitheringWeightParams(params: *mut Y2RU_DitheringWeightParams) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets all of the parameters of Y2RU_ConversionParams at once.\n # Arguments\n\n* `params` - Conversion parameters to set.\n\n Faster than calling the individual value through Y2R_Set* because only one system call is made."]
    pub fn Y2RU_SetConversionParams(params: *const Y2RU_ConversionParams) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Starts the conversion process"]
    pub fn Y2RU_StartConversion() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Cancels the conversion"]
    pub fn Y2RU_StopConversion() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if the conversion and DMA transfer are finished.\n # Arguments\n\n* `is_busy` - Pointer to output the busy state to.\n\n This can have the same problems as the event and interrupt. See Y2RU_SetTransferEndInterrupt."]
    pub fn Y2RU_IsBusyConversion(is_busy: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks whether Y2R is ready to be used.\n # Arguments\n\n* `ping` - Pointer to output the ready status to."]
    pub fn Y2RU_PingProcess(ping: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the Y2R driver."]
    pub fn Y2RU_DriverInitialize() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Terminates the Y2R driver."]
    pub fn Y2RU_DriverFinalize() -> Result;
}
#[doc = "< No port."]
pub const PORT_NONE: _bindgen_ty_16 = 0;
#[doc = "< CAM1 port."]
pub const PORT_CAM1: _bindgen_ty_16 = 1;
#[doc = "< CAM2 port."]
pub const PORT_CAM2: _bindgen_ty_16 = 2;
#[doc = "< Both ports."]
pub const PORT_BOTH: _bindgen_ty_16 = 3;
#[doc = "Camera connection target ports."]
pub type _bindgen_ty_16 = ::libc::c_uchar;
#[doc = "< No camera."]
pub const SELECT_NONE: _bindgen_ty_17 = 0;
#[doc = "< Outer camera 1."]
pub const SELECT_OUT1: _bindgen_ty_17 = 1;
#[doc = "< Inner camera 1."]
pub const SELECT_IN1: _bindgen_ty_17 = 2;
#[doc = "< Outer camera 2."]
pub const SELECT_OUT2: _bindgen_ty_17 = 4;
#[doc = "< Outer camera 1 and inner camera 1."]
pub const SELECT_IN1_OUT1: _bindgen_ty_17 = 3;
#[doc = "< Both outer cameras."]
pub const SELECT_OUT1_OUT2: _bindgen_ty_17 = 5;
#[doc = "< Inner camera 1 and outer camera 2."]
pub const SELECT_IN1_OUT2: _bindgen_ty_17 = 6;
#[doc = "< All cameras."]
pub const SELECT_ALL: _bindgen_ty_17 = 7;
#[doc = "Camera combinations."]
pub type _bindgen_ty_17 = ::libc::c_uchar;
#[doc = "< No context."]
pub const CONTEXT_NONE: CAMU_Context = 0;
#[doc = "< Context A."]
pub const CONTEXT_A: CAMU_Context = 1;
#[doc = "< Context B."]
pub const CONTEXT_B: CAMU_Context = 2;
#[doc = "< Both contexts."]
pub const CONTEXT_BOTH: CAMU_Context = 3;
#[doc = "Camera contexts."]
pub type CAMU_Context = ::libc::c_uchar;
#[doc = "< No flip."]
pub const FLIP_NONE: CAMU_Flip = 0;
#[doc = "< Horizontal flip."]
pub const FLIP_HORIZONTAL: CAMU_Flip = 1;
#[doc = "< Vertical flip."]
pub const FLIP_VERTICAL: CAMU_Flip = 2;
#[doc = "< Reverse flip."]
pub const FLIP_REVERSE: CAMU_Flip = 3;
#[doc = "Ways to flip the camera image."]
pub type CAMU_Flip = ::libc::c_uchar;
#[doc = "< VGA size. (640x480)"]
pub const SIZE_VGA: CAMU_Size = 0;
#[doc = "< QVGA size. (320x240)"]
pub const SIZE_QVGA: CAMU_Size = 1;
#[doc = "< QQVGA size. (160x120)"]
pub const SIZE_QQVGA: CAMU_Size = 2;
#[doc = "< CIF size. (352x288)"]
pub const SIZE_CIF: CAMU_Size = 3;
#[doc = "< QCIF size. (176x144)"]
pub const SIZE_QCIF: CAMU_Size = 4;
#[doc = "< DS LCD size. (256x192)"]
pub const SIZE_DS_LCD: CAMU_Size = 5;
#[doc = "< DS LCD x4 size. (512x384)"]
pub const SIZE_DS_LCDx4: CAMU_Size = 6;
#[doc = "< CTR Top LCD size. (400x240)"]
pub const SIZE_CTR_TOP_LCD: CAMU_Size = 7;
#[doc = "< CTR Bottom LCD size. (320x240)"]
pub const SIZE_CTR_BOTTOM_LCD: CAMU_Size = 1;
#[doc = "Camera image resolutions."]
pub type CAMU_Size = ::libc::c_uchar;
#[doc = "< 15 FPS."]
pub const FRAME_RATE_15: CAMU_FrameRate = 0;
#[doc = "< 15-5 FPS."]
pub const FRAME_RATE_15_TO_5: CAMU_FrameRate = 1;
#[doc = "< 15-2 FPS."]
pub const FRAME_RATE_15_TO_2: CAMU_FrameRate = 2;
#[doc = "< 10 FPS."]
pub const FRAME_RATE_10: CAMU_FrameRate = 3;
#[doc = "< 8.5 FPS."]
pub const FRAME_RATE_8_5: CAMU_FrameRate = 4;
#[doc = "< 5 FPS."]
pub const FRAME_RATE_5: CAMU_FrameRate = 5;
#[doc = "< 20 FPS."]
pub const FRAME_RATE_20: CAMU_FrameRate = 6;
#[doc = "< 20-5 FPS."]
pub const FRAME_RATE_20_TO_5: CAMU_FrameRate = 7;
#[doc = "< 30 FPS."]
pub const FRAME_RATE_30: CAMU_FrameRate = 8;
#[doc = "< 30-5 FPS."]
pub const FRAME_RATE_30_TO_5: CAMU_FrameRate = 9;
#[doc = "< 15-10 FPS."]
pub const FRAME_RATE_15_TO_10: CAMU_FrameRate = 10;
#[doc = "< 20-10 FPS."]
pub const FRAME_RATE_20_TO_10: CAMU_FrameRate = 11;
#[doc = "< 30-10 FPS."]
pub const FRAME_RATE_30_TO_10: CAMU_FrameRate = 12;
#[doc = "Camera capture frame rates."]
pub type CAMU_FrameRate = ::libc::c_uchar;
#[doc = "< Auto white balance."]
pub const WHITE_BALANCE_AUTO: CAMU_WhiteBalance = 0;
#[doc = "< 3200K white balance."]
pub const WHITE_BALANCE_3200K: CAMU_WhiteBalance = 1;
#[doc = "< 4150K white balance."]
pub const WHITE_BALANCE_4150K: CAMU_WhiteBalance = 2;
#[doc = "< 5200K white balance."]
pub const WHITE_BALANCE_5200K: CAMU_WhiteBalance = 3;
#[doc = "< 6000K white balance."]
pub const WHITE_BALANCE_6000K: CAMU_WhiteBalance = 4;
#[doc = "< 7000K white balance."]
pub const WHITE_BALANCE_7000K: CAMU_WhiteBalance = 5;
pub const WHITE_BALANCE_NORMAL: CAMU_WhiteBalance = 0;
pub const WHITE_BALANCE_TUNGSTEN: CAMU_WhiteBalance = 1;
pub const WHITE_BALANCE_WHITE_FLUORESCENT_LIGHT: CAMU_WhiteBalance = 2;
pub const WHITE_BALANCE_DAYLIGHT: CAMU_WhiteBalance = 3;
pub const WHITE_BALANCE_CLOUDY: CAMU_WhiteBalance = 4;
pub const WHITE_BALANCE_HORIZON: CAMU_WhiteBalance = 4;
pub const WHITE_BALANCE_SHADE: CAMU_WhiteBalance = 5;
#[doc = "Camera white balance modes."]
pub type CAMU_WhiteBalance = ::libc::c_uchar;
#[doc = "< Normal mode."]
pub const PHOTO_MODE_NORMAL: CAMU_PhotoMode = 0;
#[doc = "< Portrait mode."]
pub const PHOTO_MODE_PORTRAIT: CAMU_PhotoMode = 1;
#[doc = "< Landscape mode."]
pub const PHOTO_MODE_LANDSCAPE: CAMU_PhotoMode = 2;
#[doc = "< Night mode."]
pub const PHOTO_MODE_NIGHTVIEW: CAMU_PhotoMode = 3;
#[doc = "< Letter mode."]
pub const PHOTO_MODE_LETTER: CAMU_PhotoMode = 4;
#[doc = "Camera photo modes."]
pub type CAMU_PhotoMode = ::libc::c_uchar;
#[doc = "< No effects."]
pub const EFFECT_NONE: CAMU_Effect = 0;
#[doc = "< Mono effect."]
pub const EFFECT_MONO: CAMU_Effect = 1;
#[doc = "< Sepia effect."]
pub const EFFECT_SEPIA: CAMU_Effect = 2;
#[doc = "< Negative effect."]
pub const EFFECT_NEGATIVE: CAMU_Effect = 3;
#[doc = "< Negative film effect."]
pub const EFFECT_NEGAFILM: CAMU_Effect = 4;
#[doc = "< Sepia effect."]
pub const EFFECT_SEPIA01: CAMU_Effect = 5;
#[doc = "Camera special effects."]
pub type CAMU_Effect = ::libc::c_uchar;
#[doc = "< Pattern 1."]
pub const CONTRAST_PATTERN_01: CAMU_Contrast = 0;
#[doc = "< Pattern 2."]
pub const CONTRAST_PATTERN_02: CAMU_Contrast = 1;
#[doc = "< Pattern 3."]
pub const CONTRAST_PATTERN_03: CAMU_Contrast = 2;
#[doc = "< Pattern 4."]
pub const CONTRAST_PATTERN_04: CAMU_Contrast = 3;
#[doc = "< Pattern 5."]
pub const CONTRAST_PATTERN_05: CAMU_Contrast = 4;
#[doc = "< Pattern 6."]
pub const CONTRAST_PATTERN_06: CAMU_Contrast = 5;
#[doc = "< Pattern 7."]
pub const CONTRAST_PATTERN_07: CAMU_Contrast = 6;
#[doc = "< Pattern 8."]
pub const CONTRAST_PATTERN_08: CAMU_Contrast = 7;
#[doc = "< Pattern 9."]
pub const CONTRAST_PATTERN_09: CAMU_Contrast = 8;
#[doc = "< Pattern 10."]
pub const CONTRAST_PATTERN_10: CAMU_Contrast = 9;
#[doc = "< Pattern 11."]
pub const CONTRAST_PATTERN_11: CAMU_Contrast = 10;
#[doc = "< Low contrast. (5)"]
pub const CONTRAST_LOW: CAMU_Contrast = 4;
#[doc = "< Normal contrast. (6)"]
pub const CONTRAST_NORMAL: CAMU_Contrast = 5;
#[doc = "< High contrast. (7)"]
pub const CONTRAST_HIGH: CAMU_Contrast = 6;
#[doc = "Camera contrast patterns."]
pub type CAMU_Contrast = ::libc::c_uchar;
#[doc = "< No lens correction."]
pub const LENS_CORRECTION_OFF: CAMU_LensCorrection = 0;
#[doc = "< Edge-to-center brightness ratio of 70."]
pub const LENS_CORRECTION_ON_70: CAMU_LensCorrection = 1;
#[doc = "< Edge-to-center brightness ratio of 90."]
pub const LENS_CORRECTION_ON_90: CAMU_LensCorrection = 2;
#[doc = "< Dark lens correction. (OFF)"]
pub const LENS_CORRECTION_DARK: CAMU_LensCorrection = 0;
#[doc = "< Normal lens correction. (70)"]
pub const LENS_CORRECTION_NORMAL: CAMU_LensCorrection = 1;
#[doc = "< Bright lens correction. (90)"]
pub const LENS_CORRECTION_BRIGHT: CAMU_LensCorrection = 2;
#[doc = "Camera lens correction modes."]
pub type CAMU_LensCorrection = ::libc::c_uchar;
#[doc = "< YUV422"]
pub const OUTPUT_YUV_422: CAMU_OutputFormat = 0;
#[doc = "< RGB565"]
pub const OUTPUT_RGB_565: CAMU_OutputFormat = 1;
#[doc = "Camera image output formats."]
pub type CAMU_OutputFormat = ::libc::c_uchar;
#[doc = "< Normal shutter sound."]
pub const SHUTTER_SOUND_TYPE_NORMAL: CAMU_ShutterSoundType = 0;
#[doc = "< Shutter sound to begin a movie."]
pub const SHUTTER_SOUND_TYPE_MOVIE: CAMU_ShutterSoundType = 1;
#[doc = "< Shutter sound to end a movie."]
pub const SHUTTER_SOUND_TYPE_MOVIE_END: CAMU_ShutterSoundType = 2;
#[doc = "Camera shutter sounds."]
pub type CAMU_ShutterSoundType = ::libc::c_uchar;
#[doc = "Image quality calibration data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_ImageQualityCalibrationData {
    #[doc = "< Auto exposure base target brightness."]
    pub aeBaseTarget: s16,
    #[doc = "< Left color correction matrix red normalization coefficient."]
    pub kRL: s16,
    #[doc = "< Left color correction matrix green normalization coefficient."]
    pub kGL: s16,
    #[doc = "< Left color correction matrix blue normalization coefficient."]
    pub kBL: s16,
    #[doc = "< Color correction matrix position."]
    pub ccmPosition: s16,
    #[doc = "< Right camera, left color correction matrix red/green gain."]
    pub awbCcmL9Right: u16_,
    #[doc = "< Left camera, left color correction matrix red/green gain."]
    pub awbCcmL9Left: u16_,
    #[doc = "< Right camera, left color correction matrix blue/green gain."]
    pub awbCcmL10Right: u16_,
    #[doc = "< Left camera, left color correction matrix blue/green gain."]
    pub awbCcmL10Left: u16_,
    #[doc = "< Right camera, color correction matrix position threshold."]
    pub awbX0Right: u16_,
    #[doc = "< Left camera, color correction matrix position threshold."]
    pub awbX0Left: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CAMU_ImageQualityCalibrationData"]
        [::core::mem::size_of::<CAMU_ImageQualityCalibrationData>() - 22usize];
    ["Alignment of CAMU_ImageQualityCalibrationData"]
        [::core::mem::align_of::<CAMU_ImageQualityCalibrationData>() - 2usize];
    ["Offset of field: CAMU_ImageQualityCalibrationData::aeBaseTarget"]
        [::core::mem::offset_of!(CAMU_ImageQualityCalibrationData, aeBaseTarget) - 0usize];
    ["Offset of field: CAMU_ImageQualityCalibrationData::kRL"]
        [::core::mem::offset_of!(CAMU_ImageQualityCalibrationData, kRL) - 2usize];
    ["Offset of field: CAMU_ImageQualityCalibrationData::kGL"]
        [::core::mem::offset_of!(CAMU_ImageQualityCalibrationData, kGL) - 4usize];
    ["Offset of field: CAMU_ImageQualityCalibrationData::kBL"]
        [::core::mem::offset_of!(CAMU_ImageQualityCalibrationData, kBL) - 6usize];
    ["Offset of field: CAMU_ImageQualityCalibrationData::ccmPosition"]
        [::core::mem::offset_of!(CAMU_ImageQualityCalibrationData, ccmPosition) - 8usize];
    ["Offset of field: CAMU_ImageQualityCalibrationData::awbCcmL9Right"]
        [::core::mem::offset_of!(CAMU_ImageQualityCalibrationData, awbCcmL9Right) - 10usize];
    ["Offset of field: CAMU_ImageQualityCalibrationData::awbCcmL9Left"]
        [::core::mem::offset_of!(CAMU_ImageQualityCalibrationData, awbCcmL9Left) - 12usize];
    ["Offset of field: CAMU_ImageQualityCalibrationData::awbCcmL10Right"]
        [::core::mem::offset_of!(CAMU_ImageQualityCalibrationData, awbCcmL10Right) - 14usize];
    ["Offset of field: CAMU_ImageQualityCalibrationData::awbCcmL10Left"]
        [::core::mem::offset_of!(CAMU_ImageQualityCalibrationData, awbCcmL10Left) - 16usize];
    ["Offset of field: CAMU_ImageQualityCalibrationData::awbX0Right"]
        [::core::mem::offset_of!(CAMU_ImageQualityCalibrationData, awbX0Right) - 18usize];
    ["Offset of field: CAMU_ImageQualityCalibrationData::awbX0Left"]
        [::core::mem::offset_of!(CAMU_ImageQualityCalibrationData, awbX0Left) - 20usize];
};
#[doc = "Stereo camera calibration data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_StereoCameraCalibrationData {
    #[doc = "< #bool Whether the X and Y rotation data is valid."]
    pub isValidRotationXY: u8_,
    #[doc = "< Padding. (Aligns isValidRotationXY to 4 bytes)"]
    pub padding: [u8_; 3usize],
    #[doc = "< Scale to match the left camera image with the right."]
    pub scale: f32,
    #[doc = "< Z axis rotation to match the left camera image with the right."]
    pub rotationZ: f32,
    #[doc = "< X axis translation to match the left camera image with the right."]
    pub translationX: f32,
    #[doc = "< Y axis translation to match the left camera image with the right."]
    pub translationY: f32,
    #[doc = "< X axis rotation to match the left camera image with the right."]
    pub rotationX: f32,
    #[doc = "< Y axis rotation to match the left camera image with the right."]
    pub rotationY: f32,
    #[doc = "< Right camera angle of view."]
    pub angleOfViewRight: f32,
    #[doc = "< Left camera angle of view."]
    pub angleOfViewLeft: f32,
    #[doc = "< Distance between cameras and measurement chart."]
    pub distanceToChart: f32,
    #[doc = "< Distance between left and right cameras."]
    pub distanceCameras: f32,
    #[doc = "< Image width."]
    pub imageWidth: s16,
    #[doc = "< Image height."]
    pub imageHeight: s16,
    #[doc = "< Reserved for future use. (unused)"]
    pub reserved: [u8_; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CAMU_StereoCameraCalibrationData"]
        [::core::mem::size_of::<CAMU_StereoCameraCalibrationData>() - 64usize];
    ["Alignment of CAMU_StereoCameraCalibrationData"]
        [::core::mem::align_of::<CAMU_StereoCameraCalibrationData>() - 4usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::isValidRotationXY"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, isValidRotationXY) - 0usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::padding"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, padding) - 1usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::scale"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, scale) - 4usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::rotationZ"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, rotationZ) - 8usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::translationX"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, translationX) - 12usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::translationY"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, translationY) - 16usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::rotationX"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, rotationX) - 20usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::rotationY"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, rotationY) - 24usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::angleOfViewRight"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, angleOfViewRight) - 28usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::angleOfViewLeft"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, angleOfViewLeft) - 32usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::distanceToChart"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, distanceToChart) - 36usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::distanceCameras"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, distanceCameras) - 40usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::imageWidth"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, imageWidth) - 44usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::imageHeight"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, imageHeight) - 46usize];
    ["Offset of field: CAMU_StereoCameraCalibrationData::reserved"]
        [::core::mem::offset_of!(CAMU_StereoCameraCalibrationData, reserved) - 48usize];
};
#[doc = "Batch camera configuration for use without a context."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_PackageParameterCameraSelect {
    #[doc = "< Selected camera."]
    pub camera: u8_,
    #[doc = "< Camera exposure."]
    pub exposure: s8,
    #[doc = "< #CAMU_WhiteBalance Camera white balance."]
    pub whiteBalance: u8_,
    #[doc = "< Camera sharpness."]
    pub sharpness: s8,
    #[doc = "< #bool Whether to automatically determine the proper exposure."]
    pub autoExposureOn: u8_,
    #[doc = "< #bool Whether to automatically determine the white balance mode."]
    pub autoWhiteBalanceOn: u8_,
    #[doc = "< #CAMU_FrameRate Camera frame rate."]
    pub frameRate: u8_,
    #[doc = "< #CAMU_PhotoMode Camera photo mode."]
    pub photoMode: u8_,
    #[doc = "< #CAMU_Contrast Camera contrast."]
    pub contrast: u8_,
    #[doc = "< #CAMU_LensCorrection Camera lens correction."]
    pub lensCorrection: u8_,
    #[doc = "< #bool Whether to enable the camera's noise filter."]
    pub noiseFilterOn: u8_,
    #[doc = "< Padding. (Aligns last 3 fields to 4 bytes)"]
    pub padding: u8_,
    #[doc = "< X of the region to use for auto exposure."]
    pub autoExposureWindowX: s16,
    #[doc = "< Y of the region to use for auto exposure."]
    pub autoExposureWindowY: s16,
    #[doc = "< Width of the region to use for auto exposure."]
    pub autoExposureWindowWidth: s16,
    #[doc = "< Height of the region to use for auto exposure."]
    pub autoExposureWindowHeight: s16,
    #[doc = "< X of the region to use for auto white balance."]
    pub autoWhiteBalanceWindowX: s16,
    #[doc = "< Y of the region to use for auto white balance."]
    pub autoWhiteBalanceWindowY: s16,
    #[doc = "< Width of the region to use for auto white balance."]
    pub autoWhiteBalanceWindowWidth: s16,
    #[doc = "< Height of the region to use for auto white balance."]
    pub autoWhiteBalanceWindowHeight: s16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CAMU_PackageParameterCameraSelect"]
        [::core::mem::size_of::<CAMU_PackageParameterCameraSelect>() - 28usize];
    ["Alignment of CAMU_PackageParameterCameraSelect"]
        [::core::mem::align_of::<CAMU_PackageParameterCameraSelect>() - 2usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::camera"]
        [::core::mem::offset_of!(CAMU_PackageParameterCameraSelect, camera) - 0usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::exposure"]
        [::core::mem::offset_of!(CAMU_PackageParameterCameraSelect, exposure) - 1usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::whiteBalance"]
        [::core::mem::offset_of!(CAMU_PackageParameterCameraSelect, whiteBalance) - 2usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::sharpness"]
        [::core::mem::offset_of!(CAMU_PackageParameterCameraSelect, sharpness) - 3usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::autoExposureOn"]
        [::core::mem::offset_of!(CAMU_PackageParameterCameraSelect, autoExposureOn) - 4usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::autoWhiteBalanceOn"]
        [::core::mem::offset_of!(CAMU_PackageParameterCameraSelect, autoWhiteBalanceOn) - 5usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::frameRate"]
        [::core::mem::offset_of!(CAMU_PackageParameterCameraSelect, frameRate) - 6usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::photoMode"]
        [::core::mem::offset_of!(CAMU_PackageParameterCameraSelect, photoMode) - 7usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::contrast"]
        [::core::mem::offset_of!(CAMU_PackageParameterCameraSelect, contrast) - 8usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::lensCorrection"]
        [::core::mem::offset_of!(CAMU_PackageParameterCameraSelect, lensCorrection) - 9usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::noiseFilterOn"]
        [::core::mem::offset_of!(CAMU_PackageParameterCameraSelect, noiseFilterOn) - 10usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::padding"]
        [::core::mem::offset_of!(CAMU_PackageParameterCameraSelect, padding) - 11usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::autoExposureWindowX"]
        [::core::mem::offset_of!(CAMU_PackageParameterCameraSelect, autoExposureWindowX) - 12usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::autoExposureWindowY"]
        [::core::mem::offset_of!(CAMU_PackageParameterCameraSelect, autoExposureWindowY) - 14usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::autoExposureWindowWidth"][::core::mem::offset_of!(
        CAMU_PackageParameterCameraSelect,
        autoExposureWindowWidth
    ) - 16usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::autoExposureWindowHeight"][::core::mem::offset_of!(
        CAMU_PackageParameterCameraSelect,
        autoExposureWindowHeight
    ) - 18usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::autoWhiteBalanceWindowX"][::core::mem::offset_of!(
        CAMU_PackageParameterCameraSelect,
        autoWhiteBalanceWindowX
    ) - 20usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::autoWhiteBalanceWindowY"][::core::mem::offset_of!(
        CAMU_PackageParameterCameraSelect,
        autoWhiteBalanceWindowY
    ) - 22usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::autoWhiteBalanceWindowWidth"][::core::mem::offset_of!(
        CAMU_PackageParameterCameraSelect,
        autoWhiteBalanceWindowWidth
    )
        - 24usize];
    ["Offset of field: CAMU_PackageParameterCameraSelect::autoWhiteBalanceWindowHeight"][::core::mem::offset_of!(
        CAMU_PackageParameterCameraSelect,
        autoWhiteBalanceWindowHeight
    )
        - 26usize];
};
#[doc = "Batch camera configuration for use with a context."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_PackageParameterContext {
    #[doc = "< Selected camera."]
    pub camera: u8_,
    #[doc = "< #CAMU_Context Selected context."]
    pub context: u8_,
    #[doc = "< #CAMU_Flip Camera image flip mode."]
    pub flip: u8_,
    #[doc = "< #CAMU_Effect Camera image special effects."]
    pub effect: u8_,
    #[doc = "< #CAMU_Size Camera image resolution."]
    pub size: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CAMU_PackageParameterContext"]
        [::core::mem::size_of::<CAMU_PackageParameterContext>() - 5usize];
    ["Alignment of CAMU_PackageParameterContext"]
        [::core::mem::align_of::<CAMU_PackageParameterContext>() - 1usize];
    ["Offset of field: CAMU_PackageParameterContext::camera"]
        [::core::mem::offset_of!(CAMU_PackageParameterContext, camera) - 0usize];
    ["Offset of field: CAMU_PackageParameterContext::context"]
        [::core::mem::offset_of!(CAMU_PackageParameterContext, context) - 1usize];
    ["Offset of field: CAMU_PackageParameterContext::flip"]
        [::core::mem::offset_of!(CAMU_PackageParameterContext, flip) - 2usize];
    ["Offset of field: CAMU_PackageParameterContext::effect"]
        [::core::mem::offset_of!(CAMU_PackageParameterContext, effect) - 3usize];
    ["Offset of field: CAMU_PackageParameterContext::size"]
        [::core::mem::offset_of!(CAMU_PackageParameterContext, size) - 4usize];
};
#[doc = "Batch camera configuration for use with a context and with detailed size information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_PackageParameterContextDetail {
    #[doc = "< Selected camera."]
    pub camera: u8_,
    #[doc = "< #CAMU_Context Selected context."]
    pub context: u8_,
    #[doc = "< #CAMU_Flip Camera image flip mode."]
    pub flip: u8_,
    #[doc = "< #CAMU_Effect Camera image special effects."]
    pub effect: u8_,
    #[doc = "< Image width."]
    pub width: s16,
    #[doc = "< Image height."]
    pub height: s16,
    #[doc = "< First crop point X."]
    pub cropX0: s16,
    #[doc = "< First crop point Y."]
    pub cropY0: s16,
    #[doc = "< Second crop point X."]
    pub cropX1: s16,
    #[doc = "< Second crop point Y."]
    pub cropY1: s16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CAMU_PackageParameterContextDetail"]
        [::core::mem::size_of::<CAMU_PackageParameterContextDetail>() - 16usize];
    ["Alignment of CAMU_PackageParameterContextDetail"]
        [::core::mem::align_of::<CAMU_PackageParameterContextDetail>() - 2usize];
    ["Offset of field: CAMU_PackageParameterContextDetail::camera"]
        [::core::mem::offset_of!(CAMU_PackageParameterContextDetail, camera) - 0usize];
    ["Offset of field: CAMU_PackageParameterContextDetail::context"]
        [::core::mem::offset_of!(CAMU_PackageParameterContextDetail, context) - 1usize];
    ["Offset of field: CAMU_PackageParameterContextDetail::flip"]
        [::core::mem::offset_of!(CAMU_PackageParameterContextDetail, flip) - 2usize];
    ["Offset of field: CAMU_PackageParameterContextDetail::effect"]
        [::core::mem::offset_of!(CAMU_PackageParameterContextDetail, effect) - 3usize];
    ["Offset of field: CAMU_PackageParameterContextDetail::width"]
        [::core::mem::offset_of!(CAMU_PackageParameterContextDetail, width) - 4usize];
    ["Offset of field: CAMU_PackageParameterContextDetail::height"]
        [::core::mem::offset_of!(CAMU_PackageParameterContextDetail, height) - 6usize];
    ["Offset of field: CAMU_PackageParameterContextDetail::cropX0"]
        [::core::mem::offset_of!(CAMU_PackageParameterContextDetail, cropX0) - 8usize];
    ["Offset of field: CAMU_PackageParameterContextDetail::cropY0"]
        [::core::mem::offset_of!(CAMU_PackageParameterContextDetail, cropY0) - 10usize];
    ["Offset of field: CAMU_PackageParameterContextDetail::cropX1"]
        [::core::mem::offset_of!(CAMU_PackageParameterContextDetail, cropX1) - 12usize];
    ["Offset of field: CAMU_PackageParameterContextDetail::cropY1"]
        [::core::mem::offset_of!(CAMU_PackageParameterContextDetail, cropY1) - 14usize];
};
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the cam service.\n\n This will internally get the handle of the service, and on success call CAMU_DriverInitialize."]
    pub fn camInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Closes the cam service.\n\n This will internally call CAMU_DriverFinalize and close the handle of the service."]
    pub fn camExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Begins capture on the specified camera port.\n # Arguments\n\n* `port` - Port to begin capture on."]
    pub fn CAMU_StartCapture(port: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Terminates capture on the specified camera port.\n # Arguments\n\n* `port` - Port to terminate capture on."]
    pub fn CAMU_StopCapture(port: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether the specified camera port is busy.\n # Arguments\n\n* `busy` - Pointer to output the busy state to.\n * `port` - Port to check."]
    pub fn CAMU_IsBusy(busy: *mut bool, port: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Clears the buffer and error flags of the specified camera port.\n # Arguments\n\n* `port` - Port to clear."]
    pub fn CAMU_ClearBuffer(port: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a handle to the event signaled on vsync interrupts.\n # Arguments\n\n* `event` - Pointer to output the event handle to.\n * `port` - Port to use."]
    pub fn CAMU_GetVsyncInterruptEvent(event: *mut Handle, port: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a handle to the event signaled on camera buffer errors.\n # Arguments\n\n* `event` - Pointer to output the event handle to.\n * `port` - Port to use."]
    pub fn CAMU_GetBufferErrorInterruptEvent(event: *mut Handle, port: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initiates the process of receiving a camera frame.\n # Arguments\n\n* `event` - Pointer to output the completion event handle to.\n * `dst` - Buffer to write data to.\n * `port` - Port to receive from.\n * `imageSize` - Size of the image to receive.\n * `transferUnit` - Transfer unit to use when receiving."]
    pub fn CAMU_SetReceiving(
        event: *mut Handle,
        dst: *mut ::libc::c_void,
        port: u32_,
        imageSize: u32_,
        transferUnit: s16,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether the specified camera port has finished receiving image data.\n # Arguments\n\n* `finishedReceiving` - Pointer to output the receiving status to.\n * `port` - Port to check."]
    pub fn CAMU_IsFinishedReceiving(finishedReceiving: *mut bool, port: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the number of lines to transfer into an image buffer.\n # Arguments\n\n* `port` - Port to use.\n * `lines` - Lines to transfer.\n * `width` - Width of the image.\n * `height` - Height of the image."]
    pub fn CAMU_SetTransferLines(port: u32_, lines: s16, width: s16, height: s16) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the maximum number of lines that can be saved to an image buffer.\n # Arguments\n\n* `maxLines` - Pointer to write the maximum number of lines to.\n * `width` - Width of the image.\n * `height` - Height of the image."]
    pub fn CAMU_GetMaxLines(maxLines: *mut s16, width: s16, height: s16) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the number of bytes to transfer into an image buffer.\n # Arguments\n\n* `port` - Port to use.\n * `bytes` - Bytes to transfer.\n * `width` - Width of the image.\n * `height` - Height of the image."]
    pub fn CAMU_SetTransferBytes(port: u32_, bytes: u32_, width: s16, height: s16) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the number of bytes to transfer into an image buffer.\n # Arguments\n\n* `transferBytes` - Pointer to write the number of bytes to.\n * `port` - Port to use."]
    pub fn CAMU_GetTransferBytes(transferBytes: *mut u32_, port: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the maximum number of bytes that can be saved to an image buffer.\n # Arguments\n\n* `maxBytes` - Pointer to write the maximum number of bytes to.\n * `width` - Width of the image.\n * `height` - Height of the image."]
    pub fn CAMU_GetMaxBytes(maxBytes: *mut u32_, width: s16, height: s16) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets whether image trimming is enabled.\n # Arguments\n\n* `port` - Port to use.\n * `trimming` - Whether image trimming is enabled."]
    pub fn CAMU_SetTrimming(port: u32_, trimming: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether image trimming is enabled.\n # Arguments\n\n* `trimming` - Pointer to output the trim state to.\n * `port` - Port to use."]
    pub fn CAMU_IsTrimming(trimming: *mut bool, port: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the parameters used for trimming images.\n # Arguments\n\n* `port` - Port to use.\n * `xStart` - Start X coordinate.\n * `yStart` - Start Y coordinate.\n * `xEnd` - End X coordinate.\n * `yEnd` - End Y coordinate."]
    pub fn CAMU_SetTrimmingParams(
        port: u32_,
        xStart: s16,
        yStart: s16,
        xEnd: s16,
        yEnd: s16,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the parameters used for trimming images.\n # Arguments\n\n* `xStart` - Pointer to write the start X coordinate to.\n * `yStart` - Pointer to write the start Y coordinate to.\n * `xEnd` - Pointer to write the end X coordinate to.\n * `yEnd` - Pointer to write the end Y coordinate to.\n * `port` - Port to use."]
    pub fn CAMU_GetTrimmingParams(
        xStart: *mut s16,
        yStart: *mut s16,
        xEnd: *mut s16,
        yEnd: *mut s16,
        port: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the parameters used for trimming images, relative to the center of the image.\n # Arguments\n\n* `port` - Port to use.\n * `trimWidth` - Trim width.\n * `trimHeight` - Trim height.\n * `camWidth` - Camera width.\n * `camHeight` - Camera height."]
    pub fn CAMU_SetTrimmingParamsCenter(
        port: u32_,
        trimWidth: s16,
        trimHeight: s16,
        camWidth: s16,
        camHeight: s16,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Activates the specified camera.\n # Arguments\n\n* `select` - Camera to use."]
    pub fn CAMU_Activate(select: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Switches the specified camera's active context.\n # Arguments\n\n* `select` - Camera to use.\n * `context` - Context to use."]
    pub fn CAMU_SwitchContext(select: u32_, context: CAMU_Context) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the exposure value of the specified camera.\n # Arguments\n\n* `select` - Camera to use.\n * `exposure` - Exposure value to use."]
    pub fn CAMU_SetExposure(select: u32_, exposure: s8) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the white balance mode of the specified camera.\n # Arguments\n\n* `select` - Camera to use.\n * `whiteBalance` - White balance mode to use."]
    pub fn CAMU_SetWhiteBalance(select: u32_, whiteBalance: CAMU_WhiteBalance) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the white balance mode of the specified camera.\n TODO: Explain \"without base up\"?\n # Arguments\n\n* `select` - Camera to use.\n * `whiteBalance` - White balance mode to use."]
    pub fn CAMU_SetWhiteBalanceWithoutBaseUp(
        select: u32_,
        whiteBalance: CAMU_WhiteBalance,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the sharpness of the specified camera.\n # Arguments\n\n* `select` - Camera to use.\n * `sharpness` - Sharpness to use."]
    pub fn CAMU_SetSharpness(select: u32_, sharpness: s8) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets whether auto exposure is enabled on the specified camera.\n # Arguments\n\n* `select` - Camera to use.\n * `autoWhiteBalance` - Whether auto exposure is enabled."]
    pub fn CAMU_SetAutoExposure(select: u32_, autoExposure: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether auto exposure is enabled on the specified camera.\n # Arguments\n\n* `autoExposure` - Pointer to output the auto exposure state to.\n * `select` - Camera to use."]
    pub fn CAMU_IsAutoExposure(autoExposure: *mut bool, select: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets whether auto white balance is enabled on the specified camera.\n # Arguments\n\n* `select` - Camera to use.\n * `autoWhiteBalance` - Whether auto white balance is enabled."]
    pub fn CAMU_SetAutoWhiteBalance(select: u32_, autoWhiteBalance: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether auto white balance is enabled on the specified camera.\n # Arguments\n\n* `autoWhiteBalance` - Pointer to output the auto white balance state to.\n * `select` - Camera to use."]
    pub fn CAMU_IsAutoWhiteBalance(autoWhiteBalance: *mut bool, select: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Flips the image of the specified camera in the specified context.\n # Arguments\n\n* `select` - Camera to use.\n * `flip` - Flip mode to use.\n * `context` - Context to use."]
    pub fn CAMU_FlipImage(select: u32_, flip: CAMU_Flip, context: CAMU_Context) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the image resolution of the given camera in the given context, in detail.\n # Arguments\n\n* `select` - Camera to use.\n * `width` - Width to use.\n * `height` - Height to use.\n * `cropX0` - First crop point X.\n * `cropY0` - First crop point Y.\n * `cropX1` - Second crop point X.\n * `cropY1` - Second crop point Y.\n * `context` - Context to use."]
    pub fn CAMU_SetDetailSize(
        select: u32_,
        width: s16,
        height: s16,
        cropX0: s16,
        cropY0: s16,
        cropX1: s16,
        cropY1: s16,
        context: CAMU_Context,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the image resolution of the given camera in the given context.\n # Arguments\n\n* `select` - Camera to use.\n * `size` - Size to use.\n * `context` - Context to use."]
    pub fn CAMU_SetSize(select: u32_, size: CAMU_Size, context: CAMU_Context) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the frame rate of the given camera.\n # Arguments\n\n* `select` - Camera to use.\n * `frameRate` - Frame rate to use."]
    pub fn CAMU_SetFrameRate(select: u32_, frameRate: CAMU_FrameRate) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the photo mode of the given camera.\n # Arguments\n\n* `select` - Camera to use.\n * `photoMode` - Photo mode to use."]
    pub fn CAMU_SetPhotoMode(select: u32_, photoMode: CAMU_PhotoMode) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the special effects of the given camera in the given context.\n # Arguments\n\n* `select` - Camera to use.\n * `effect` - Effect to use.\n * `context` - Context to use."]
    pub fn CAMU_SetEffect(select: u32_, effect: CAMU_Effect, context: CAMU_Context) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the contrast mode of the given camera.\n # Arguments\n\n* `select` - Camera to use.\n * `contrast` - Contrast mode to use."]
    pub fn CAMU_SetContrast(select: u32_, contrast: CAMU_Contrast) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the lens correction mode of the given camera.\n # Arguments\n\n* `select` - Camera to use.\n * `lensCorrection` - Lens correction mode to use."]
    pub fn CAMU_SetLensCorrection(select: u32_, lensCorrection: CAMU_LensCorrection) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the output format of the given camera in the given context.\n # Arguments\n\n* `select` - Camera to use.\n * `format` - Format to output.\n * `context` - Context to use."]
    pub fn CAMU_SetOutputFormat(
        select: u32_,
        format: CAMU_OutputFormat,
        context: CAMU_Context,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the region to base auto exposure off of for the specified camera.\n # Arguments\n\n* `select` - Camera to use.\n * `x` - X of the region.\n * `y` - Y of the region.\n * `width` - Width of the region.\n * `height` - Height of the region."]
    pub fn CAMU_SetAutoExposureWindow(
        select: u32_,
        x: s16,
        y: s16,
        width: s16,
        height: s16,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the region to base auto white balance off of for the specified camera.\n # Arguments\n\n* `select` - Camera to use.\n * `x` - X of the region.\n * `y` - Y of the region.\n * `width` - Width of the region.\n * `height` - Height of the region."]
    pub fn CAMU_SetAutoWhiteBalanceWindow(
        select: u32_,
        x: s16,
        y: s16,
        width: s16,
        height: s16,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets whether the specified camera's noise filter is enabled.\n # Arguments\n\n* `select` - Camera to use.\n * `noiseFilter` - Whether the noise filter is enabled."]
    pub fn CAMU_SetNoiseFilter(select: u32_, noiseFilter: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Synchronizes the specified cameras' vsync timing.\n # Arguments\n\n* `select1` - First camera.\n * `select2` - Second camera."]
    pub fn CAMU_SynchronizeVsyncTiming(select1: u32_, select2: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the vsync timing record of the specified camera for the specified number of signals.\n # Arguments\n\n* `timing` - Pointer to write timing data to. (size \"past * sizeof(s64)\")\n * `port` - Port to use.\n * `past` - Number of past timings to retrieve."]
    pub fn CAMU_GetLatestVsyncTiming(timing: *mut s64, port: u32_, past: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the specified camera's stereo camera calibration data.\n # Arguments\n\n* `data` - Pointer to output the stereo camera data to."]
    pub fn CAMU_GetStereoCameraCalibrationData(
        data: *mut CAMU_StereoCameraCalibrationData,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the specified camera's stereo camera calibration data.\n # Arguments\n\n* `data` - Data to set."]
    pub fn CAMU_SetStereoCameraCalibrationData(data: CAMU_StereoCameraCalibrationData) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes to the specified I2C register of the specified camera.\n # Arguments\n\n* `select` - Camera to write to.\n * `addr` - Address to write to.\n * `data` - Data to write."]
    pub fn CAMU_WriteRegisterI2c(select: u32_, addr: u16_, data: u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes to the specified MCU variable of the specified camera.\n # Arguments\n\n* `select` - Camera to write to.\n * `addr` - Address to write to.\n * `data` - Data to write."]
    pub fn CAMU_WriteMcuVariableI2c(select: u32_, addr: u16_, data: u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads the specified I2C register of the specified camera.\n # Arguments\n\n* `data` - Pointer to read data to.\n * `select` - Camera to read from.\n * `addr` - Address to read."]
    pub fn CAMU_ReadRegisterI2cExclusive(data: *mut u16_, select: u32_, addr: u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads the specified MCU variable of the specified camera.\n # Arguments\n\n* `data` - Pointer to read data to.\n * `select` - Camera to read from.\n * `addr` - Address to read."]
    pub fn CAMU_ReadMcuVariableI2cExclusive(data: *mut u16_, select: u32_, addr: u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the specified camera's image quality calibration data.\n # Arguments\n\n* `data` - Data to set."]
    pub fn CAMU_SetImageQualityCalibrationData(data: CAMU_ImageQualityCalibrationData) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the specified camera's image quality calibration data.\n # Arguments\n\n* `data` - Pointer to write the quality data to."]
    pub fn CAMU_GetImageQualityCalibrationData(
        data: *mut CAMU_ImageQualityCalibrationData,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures a camera with pre-packaged configuration data without a context.\n # Arguments\n\n* `Parameter` - to use."]
    pub fn CAMU_SetPackageParameterWithoutContext(
        param: CAMU_PackageParameterCameraSelect,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures a camera with pre-packaged configuration data with a context.\n # Arguments\n\n* `Parameter` - to use."]
    pub fn CAMU_SetPackageParameterWithContext(param: CAMU_PackageParameterContext) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures a camera with pre-packaged configuration data without a context and extra resolution details.\n # Arguments\n\n* `Parameter` - to use."]
    pub fn CAMU_SetPackageParameterWithContextDetail(
        param: CAMU_PackageParameterContextDetail,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the Y2R coefficient applied to image data by the camera.\n # Arguments\n\n* `coefficient` - Pointer to output the Y2R coefficient to."]
    pub fn CAMU_GetSuitableY2rStandardCoefficient(
        coefficient: *mut Y2RU_StandardCoefficient,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Plays the specified shutter sound.\n # Arguments\n\n* `sound` - Shutter sound to play."]
    pub fn CAMU_PlayShutterSound(sound: CAMU_ShutterSoundType) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the camera driver."]
    pub fn CAMU_DriverInitialize() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Finalizes the camera driver."]
    pub fn CAMU_DriverFinalize() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current activated camera.\n # Arguments\n\n* `select` - Pointer to output the current activated camera to."]
    pub fn CAMU_GetActivatedCamera(select: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current sleep camera.\n # Arguments\n\n* `select` - Pointer to output the current sleep camera to."]
    pub fn CAMU_GetSleepCamera(select: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the current sleep camera.\n # Arguments\n\n* `select` - Camera to set."]
    pub fn CAMU_SetSleepCamera(select: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets whether to enable synchronization of left and right camera brightnesses.\n # Arguments\n\n* `brightnessSynchronization` - Whether to enable brightness synchronization."]
    pub fn CAMU_SetBrightnessSynchronization(brightnessSynchronization: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes CFGNOR.\n # Arguments\n\n* `value` - Unknown, usually 1."]
    pub fn cfgnorInit(value: u8_) -> Result;
}
unsafe extern "C" {
    #[doc = "Exits CFGNOR"]
    pub fn cfgnorExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Dumps the NOR flash.\n # Arguments\n\n* `buf` - Buffer to dump to.\n * `size` - Size of the buffer."]
    pub fn cfgnorDumpFlash(buf: *mut u32_, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes the NOR flash.\n # Arguments\n\n* `buf` - Buffer to write from.\n * `size` - Size of the buffer."]
    pub fn cfgnorWriteFlash(buf: *mut u32_, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the CFGNOR session.\n # Arguments\n\n* `value` - Unknown, usually 1."]
    pub fn CFGNOR_Initialize(value: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Shuts down the CFGNOR session."]
    pub fn CFGNOR_Shutdown() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads data from NOR.\n # Arguments\n\n* `offset` - Offset to read from.\n * `buf` - Buffer to read data to.\n * `size` - Size of the buffer."]
    pub fn CFGNOR_ReadData(offset: u32_, buf: *mut u32_, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes data to NOR.\n # Arguments\n\n* `offset` - Offset to write to.\n * `buf` - Buffer to write data from.\n * `size` - Size of the buffer."]
    pub fn CFGNOR_WriteData(offset: u32_, buf: *mut u32_, size: u32_) -> Result;
}
#[doc = "< Japan"]
pub const CFG_REGION_JPN: CFG_Region = 0;
#[doc = "< USA"]
pub const CFG_REGION_USA: CFG_Region = 1;
#[doc = "< Europe"]
pub const CFG_REGION_EUR: CFG_Region = 2;
#[doc = "< Australia"]
pub const CFG_REGION_AUS: CFG_Region = 3;
#[doc = "< China"]
pub const CFG_REGION_CHN: CFG_Region = 4;
#[doc = "< Korea"]
pub const CFG_REGION_KOR: CFG_Region = 5;
#[doc = "< Taiwan"]
pub const CFG_REGION_TWN: CFG_Region = 6;
#[doc = "Configuration region values."]
pub type CFG_Region = ::libc::c_uchar;
#[doc = "< Use system language in errorInit"]
pub const CFG_LANGUAGE_DEFAULT: CFG_Language = -1;
#[doc = "< Japanese"]
pub const CFG_LANGUAGE_JP: CFG_Language = 0;
#[doc = "< English"]
pub const CFG_LANGUAGE_EN: CFG_Language = 1;
#[doc = "< French"]
pub const CFG_LANGUAGE_FR: CFG_Language = 2;
#[doc = "< German"]
pub const CFG_LANGUAGE_DE: CFG_Language = 3;
#[doc = "< Italian"]
pub const CFG_LANGUAGE_IT: CFG_Language = 4;
#[doc = "< Spanish"]
pub const CFG_LANGUAGE_ES: CFG_Language = 5;
#[doc = "< Simplified Chinese"]
pub const CFG_LANGUAGE_ZH: CFG_Language = 6;
#[doc = "< Korean"]
pub const CFG_LANGUAGE_KO: CFG_Language = 7;
#[doc = "< Dutch"]
pub const CFG_LANGUAGE_NL: CFG_Language = 8;
#[doc = "< Portugese"]
pub const CFG_LANGUAGE_PT: CFG_Language = 9;
#[doc = "< Russian"]
pub const CFG_LANGUAGE_RU: CFG_Language = 10;
#[doc = "< Traditional Chinese"]
pub const CFG_LANGUAGE_TW: CFG_Language = 11;
#[doc = "Configuration language values."]
pub type CFG_Language = ::libc::c_schar;
#[doc = "< Old 3DS (CTR)"]
pub const CFG_MODEL_3DS: CFG_SystemModel = 0;
#[doc = "< Old 3DS XL (SPR)"]
pub const CFG_MODEL_3DSXL: CFG_SystemModel = 1;
#[doc = "< New 3DS (KTR)"]
pub const CFG_MODEL_N3DS: CFG_SystemModel = 2;
#[doc = "< Old 2DS (FTR)"]
pub const CFG_MODEL_2DS: CFG_SystemModel = 3;
#[doc = "< New 3DS XL (RED)"]
pub const CFG_MODEL_N3DSXL: CFG_SystemModel = 4;
#[doc = "< New 2DS XL (JAN)"]
pub const CFG_MODEL_N2DSXL: CFG_SystemModel = 5;
pub type CFG_SystemModel = ::libc::c_uchar;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes CFGU."]
    pub fn cfguInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits CFGU."]
    pub fn cfguExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the system's region from secure info.\n # Arguments\n\n* `region` - Pointer to output the region to. (see CFG_Region)"]
    pub fn CFGU_SecureInfoGetRegion(region: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Generates a console-unique hash.\n # Arguments\n\n* `appIDSalt` - Salt to use.\n * `hash` - Pointer to output the hash to."]
    pub fn CFGU_GenHashConsoleUnique(appIDSalt: u32_, hash: *mut u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether the system's region is Canada or USA.\n # Arguments\n\n* `value` - Pointer to output the result to. (0 = no, 1 = yes)"]
    pub fn CFGU_GetRegionCanadaUSA(value: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the system's model.\n # Arguments\n\n* `model` - Pointer to output the model to. (see CFG_SystemModel)"]
    pub fn CFGU_GetSystemModel(model: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether the system is a 2DS.\n # Arguments\n\n* `value` - Pointer to output the result to. (0 = yes, 1 = no)"]
    pub fn CFGU_GetModelNintendo2DS(value: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a string representing a country code.\n # Arguments\n\n* `code` - Country code to use.\n * `string` - Pointer to output the string to."]
    pub fn CFGU_GetCountryCodeString(code: u16_, string: *mut u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a country code ID from its string.\n # Arguments\n\n* `string` - String to use.\n * `code` - Pointer to output the country code to."]
    pub fn CFGU_GetCountryCodeID(string: u16_, code: *mut u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if NFC (code name: fangate) is supported.\n # Arguments\n\n* `isSupported` - pointer to the output the result to."]
    pub fn CFGU_IsNFCSupported(isSupported: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a config info block with flags = 2.\n # Arguments\n\n* `size` - Size of the data to retrieve.\n * `blkID` - ID of the block to retrieve.\n * `outData` - Pointer to write the block data to."]
    pub fn CFGU_GetConfigInfoBlk2(size: u32_, blkID: u32_, outData: *mut ::libc::c_void) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a config info block with flags = 4.\n # Arguments\n\n* `size` - Size of the data to retrieve.\n * `blkID` - ID of the block to retrieve.\n * `outData` - Pointer to write the block data to."]
    pub fn CFG_GetConfigInfoBlk4(size: u32_, blkID: u32_, outData: *mut ::libc::c_void) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a config info block with flags = 8.\n # Arguments\n\n* `size` - Size of the data to retrieve.\n * `blkID` - ID of the block to retrieve.\n * `outData` - Pointer to write the block data to."]
    pub fn CFG_GetConfigInfoBlk8(size: u32_, blkID: u32_, outData: *mut ::libc::c_void) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets a config info block with flags = 4.\n # Arguments\n\n* `size` - Size of the data to retrieve.\n * `blkID` - ID of the block to retrieve.\n * `inData` - Pointer to block data to write."]
    pub fn CFG_SetConfigInfoBlk4(size: u32_, blkID: u32_, inData: *const ::libc::c_void) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets a config info block with flags = 8.\n # Arguments\n\n* `size` - Size of the data to retrieve.\n * `blkID` - ID of the block to retrieve.\n * `inData` - Pointer to block data to write."]
    pub fn CFG_SetConfigInfoBlk8(size: u32_, blkID: u32_, inData: *const ::libc::c_void) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes the CFG buffer in memory to the savegame in NAND."]
    pub fn CFG_UpdateConfigSavegame() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the system's language.\n # Arguments\n\n* `language` - Pointer to write the language to. (see CFG_Language)"]
    pub fn CFGU_GetSystemLanguage(language: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes the NAND LocalFriendCodeSeed file, then recreates it using the LocalFriendCodeSeed data stored in memory."]
    pub fn CFGI_RestoreLocalFriendCodeSeed() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes the NAND SecureInfo file, then recreates it using the SecureInfo data stored in memory."]
    pub fn CFGI_RestoreSecureInfo() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes the \"config\" file stored in the NAND Config_Savegame."]
    pub fn CFGI_DeleteConfigSavefile() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Formats Config_Savegame."]
    pub fn CFGI_FormatConfig() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Clears parental controls"]
    pub fn CFGI_ClearParentalControls() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Verifies the RSA signature for the LocalFriendCodeSeed data already stored in memory."]
    pub fn CFGI_VerifySigLocalFriendCodeSeed() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Verifies the RSA signature for the SecureInfo data already stored in memory."]
    pub fn CFGI_VerifySigSecureInfo() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the system's serial number.\n # Arguments\n\n* `serial` - Pointer to output the serial to. (This is normally 0xF)"]
    pub fn CFGI_SecureInfoGetSerialNumber(serial: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the 0x110-byte buffer containing the data for the LocalFriendCodeSeed.\n # Arguments\n\n* `data` - Pointer to output the buffer. (The size must be at least 0x110-bytes)"]
    pub fn CFGI_GetLocalFriendCodeSeedData(data: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the 64-bit local friend code seed.\n # Arguments\n\n* `seed` - Pointer to write the friend code seed to."]
    pub fn CFGI_GetLocalFriendCodeSeed(seed: *mut u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the 0x11-byte data following the SecureInfo signature.\n # Arguments\n\n* `data` - Pointer to output the buffer. (The size must be at least 0x11-bytes)"]
    pub fn CFGI_GetSecureInfoData(data: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the 0x100-byte RSA-2048 SecureInfo signature.\n # Arguments\n\n* `data` - Pointer to output the buffer. (The size must be at least 0x100-bytes)"]
    pub fn CFGI_GetSecureInfoSignature(data: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[doc = "Converts a vol-pan pair into a left/right volume pair used by the hardware.\n # Arguments\n\n* `vol` - Volume to use.\n * `pan` - Pan to use.\n # Returns\n\nA left/right volume pair for use by hardware."]
    #[link_name = "CSND_VOL__extern"]
    pub fn CSND_VOL(vol: f32, pan: f32) -> u32_;
}
#[doc = "< PCM8"]
pub const CSND_ENCODING_PCM8: _bindgen_ty_18 = 0;
#[doc = "< PCM16"]
pub const CSND_ENCODING_PCM16: _bindgen_ty_18 = 1;
#[doc = "< IMA-ADPCM"]
pub const CSND_ENCODING_ADPCM: _bindgen_ty_18 = 2;
#[doc = "< PSG (Similar to DS?)"]
pub const CSND_ENCODING_PSG: _bindgen_ty_18 = 3;
#[doc = "CSND encodings."]
pub type _bindgen_ty_18 = ::libc::c_uchar;
#[doc = "< Manual loop."]
pub const CSND_LOOPMODE_MANUAL: _bindgen_ty_19 = 0;
#[doc = "< Normal loop."]
pub const CSND_LOOPMODE_NORMAL: _bindgen_ty_19 = 1;
#[doc = "< Do not loop."]
pub const CSND_LOOPMODE_ONESHOT: _bindgen_ty_19 = 2;
#[doc = "< Don't reload."]
pub const CSND_LOOPMODE_NORELOAD: _bindgen_ty_19 = 3;
#[doc = "CSND loop modes."]
pub type _bindgen_ty_19 = ::libc::c_uchar;
#[doc = "< Linear interpolation."]
pub const SOUND_LINEAR_INTERP: _bindgen_ty_20 = 64;
#[doc = "< Repeat the sound."]
pub const SOUND_REPEAT: _bindgen_ty_20 = 1024;
#[doc = "< Play the sound once."]
pub const SOUND_ONE_SHOT: _bindgen_ty_20 = 2048;
#[doc = "< PCM8"]
pub const SOUND_FORMAT_8BIT: _bindgen_ty_20 = 0;
#[doc = "< PCM16"]
pub const SOUND_FORMAT_16BIT: _bindgen_ty_20 = 4096;
#[doc = "< ADPCM"]
pub const SOUND_FORMAT_ADPCM: _bindgen_ty_20 = 8192;
#[doc = "< PSG"]
pub const SOUND_FORMAT_PSG: _bindgen_ty_20 = 12288;
#[doc = "< Enable sound."]
pub const SOUND_ENABLE: _bindgen_ty_20 = 16384;
#[doc = "Sound flags."]
pub type _bindgen_ty_20 = ::libc::c_ushort;
#[doc = "< Repeat capture."]
pub const CAPTURE_REPEAT: _bindgen_ty_21 = 0;
#[doc = "< Capture once."]
pub const CAPTURE_ONE_SHOT: _bindgen_ty_21 = 1;
#[doc = "< PCM16"]
pub const CAPTURE_FORMAT_16BIT: _bindgen_ty_21 = 0;
#[doc = "< PCM8"]
pub const CAPTURE_FORMAT_8BIT: _bindgen_ty_21 = 2;
#[doc = "< Enable capture."]
pub const CAPTURE_ENABLE: _bindgen_ty_21 = 32768;
#[doc = "Capture modes."]
pub type _bindgen_ty_21 = ::libc::c_ushort;
#[doc = "< 0.0% duty cycle"]
pub const DutyCycle_0: CSND_DutyCycle = 7;
#[doc = "< 12.5% duty cycle"]
pub const DutyCycle_12: CSND_DutyCycle = 0;
#[doc = "< 25.0% duty cycle"]
pub const DutyCycle_25: CSND_DutyCycle = 1;
#[doc = "< 37.5% duty cycle"]
pub const DutyCycle_37: CSND_DutyCycle = 2;
#[doc = "< 50.0% duty cycle"]
pub const DutyCycle_50: CSND_DutyCycle = 3;
#[doc = "< 62.5% duty cycle"]
pub const DutyCycle_62: CSND_DutyCycle = 4;
#[doc = "< 75.0% duty cycle"]
pub const DutyCycle_75: CSND_DutyCycle = 5;
#[doc = "< 87.5% duty cycle"]
pub const DutyCycle_87: CSND_DutyCycle = 6;
#[doc = "Duty cycles for a PSG channel."]
pub type CSND_DutyCycle = ::libc::c_uchar;
#[doc = "Channel info."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CSND_ChnInfo {
    #[doc = "< Raw values."]
    pub value: [u32_; 3usize],
    pub __bindgen_anon_1: CSND_ChnInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CSND_ChnInfo__bindgen_ty_1 {
    #[doc = "< Channel active."]
    pub active: u8_,
    #[doc = "< Padding."]
    pub _pad1: u8_,
    #[doc = "< Padding."]
    pub _pad2: u16_,
    #[doc = "< Current ADPCM sample."]
    pub adpcmSample: s16,
    #[doc = "< Current ADPCM index."]
    pub adpcmIndex: u8_,
    #[doc = "< Padding."]
    pub _pad3: u8_,
    #[doc = "< Unknown."]
    pub unknownZero: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSND_ChnInfo__bindgen_ty_1"]
        [::core::mem::size_of::<CSND_ChnInfo__bindgen_ty_1>() - 12usize];
    ["Alignment of CSND_ChnInfo__bindgen_ty_1"]
        [::core::mem::align_of::<CSND_ChnInfo__bindgen_ty_1>() - 4usize];
    ["Offset of field: CSND_ChnInfo__bindgen_ty_1::active"]
        [::core::mem::offset_of!(CSND_ChnInfo__bindgen_ty_1, active) - 0usize];
    ["Offset of field: CSND_ChnInfo__bindgen_ty_1::_pad1"]
        [::core::mem::offset_of!(CSND_ChnInfo__bindgen_ty_1, _pad1) - 1usize];
    ["Offset of field: CSND_ChnInfo__bindgen_ty_1::_pad2"]
        [::core::mem::offset_of!(CSND_ChnInfo__bindgen_ty_1, _pad2) - 2usize];
    ["Offset of field: CSND_ChnInfo__bindgen_ty_1::adpcmSample"]
        [::core::mem::offset_of!(CSND_ChnInfo__bindgen_ty_1, adpcmSample) - 4usize];
    ["Offset of field: CSND_ChnInfo__bindgen_ty_1::adpcmIndex"]
        [::core::mem::offset_of!(CSND_ChnInfo__bindgen_ty_1, adpcmIndex) - 6usize];
    ["Offset of field: CSND_ChnInfo__bindgen_ty_1::_pad3"]
        [::core::mem::offset_of!(CSND_ChnInfo__bindgen_ty_1, _pad3) - 7usize];
    ["Offset of field: CSND_ChnInfo__bindgen_ty_1::unknownZero"]
        [::core::mem::offset_of!(CSND_ChnInfo__bindgen_ty_1, unknownZero) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSND_ChnInfo"][::core::mem::size_of::<CSND_ChnInfo>() - 12usize];
    ["Alignment of CSND_ChnInfo"][::core::mem::align_of::<CSND_ChnInfo>() - 4usize];
    ["Offset of field: CSND_ChnInfo::value"][::core::mem::offset_of!(CSND_ChnInfo, value) - 0usize];
};
impl Default for CSND_ChnInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Capture info."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CSND_CapInfo {
    #[doc = "< Raw values."]
    pub value: [u32_; 2usize],
    pub __bindgen_anon_1: CSND_CapInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CSND_CapInfo__bindgen_ty_1 {
    #[doc = "< Capture active."]
    pub active: u8_,
    #[doc = "< Padding."]
    pub _pad1: u8_,
    #[doc = "< Padding."]
    pub _pad2: u16_,
    #[doc = "< Unknown."]
    pub unknownZero: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSND_CapInfo__bindgen_ty_1"]
        [::core::mem::size_of::<CSND_CapInfo__bindgen_ty_1>() - 8usize];
    ["Alignment of CSND_CapInfo__bindgen_ty_1"]
        [::core::mem::align_of::<CSND_CapInfo__bindgen_ty_1>() - 4usize];
    ["Offset of field: CSND_CapInfo__bindgen_ty_1::active"]
        [::core::mem::offset_of!(CSND_CapInfo__bindgen_ty_1, active) - 0usize];
    ["Offset of field: CSND_CapInfo__bindgen_ty_1::_pad1"]
        [::core::mem::offset_of!(CSND_CapInfo__bindgen_ty_1, _pad1) - 1usize];
    ["Offset of field: CSND_CapInfo__bindgen_ty_1::_pad2"]
        [::core::mem::offset_of!(CSND_CapInfo__bindgen_ty_1, _pad2) - 2usize];
    ["Offset of field: CSND_CapInfo__bindgen_ty_1::unknownZero"]
        [::core::mem::offset_of!(CSND_CapInfo__bindgen_ty_1, unknownZero) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CSND_CapInfo"][::core::mem::size_of::<CSND_CapInfo>() - 8usize];
    ["Alignment of CSND_CapInfo"][::core::mem::align_of::<CSND_CapInfo>() - 4usize];
    ["Offset of field: CSND_CapInfo::value"][::core::mem::offset_of!(CSND_CapInfo, value) - 0usize];
};
impl Default for CSND_CapInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = "< CSND shared memory."]
    pub static mut csndSharedMem: *mut vu32;
}
unsafe extern "C" {
    #[doc = "< CSND shared memory size."]
    pub static mut csndSharedMemSize: u32_;
}
unsafe extern "C" {
    #[doc = "< Bitmask of channels that are allowed for usage."]
    pub static mut csndChannels: u32_;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acquires a capture unit.\n # Arguments\n\n* `capUnit` - Pointer to output the capture unit to."]
    pub fn CSND_AcquireCapUnit(capUnit: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Releases a capture unit.\n # Arguments\n\n* `capUnit` - Capture unit to release."]
    pub fn CSND_ReleaseCapUnit(capUnit: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Flushes the data cache of a memory region.\n # Arguments\n\n* `adr` - Address of the memory region.\n * `size` - Size of the memory region."]
    pub fn CSND_FlushDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Stores the data cache of a memory region.\n # Arguments\n\n* `adr` - Address of the memory region.\n * `size` - Size of the memory region."]
    pub fn CSND_StoreDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Invalidates the data cache of a memory region.\n # Arguments\n\n* `adr` - Address of the memory region.\n * `size` - Size of the memory region."]
    pub fn CSND_InvalidateDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Resets CSND.\n Note: Currently breaks sound, don't use for now!"]
    pub fn CSND_Reset() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes CSND."]
    pub fn csndInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits CSND."]
    pub fn csndExit();
}
unsafe extern "C" {
    #[doc = "Adds a command to the list, returning a buffer to write arguments to.\n # Arguments\n\n* `cmdid` - ID of the command to add.\n # Returns\n\nA buffer to write command arguments to."]
    pub fn csndAddCmd(cmdid: ::libc::c_int) -> *mut u32_;
}
unsafe extern "C" {
    #[doc = "Adds a command to the list, copying its arguments from a buffer.\n # Arguments\n\n* `cmdid` - ID of the command to add.\n * `cmdparams` - Buffer containing the command's parameters."]
    pub fn csndWriteCmd(cmdid: ::libc::c_int, cmdparams: *mut u8_);
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes pending CSND commands.\n # Arguments\n\n* `waitDone` - Whether to wait until the commands have finished executing."]
    pub fn csndExecCmds(waitDone: bool) -> Result;
}
unsafe extern "C" {
    #[doc = "Sets a channel's play state, resetting registers on stop.\n # Arguments\n\n* `channel` - Channel to use.\n * `value` - Play state to set."]
    pub fn CSND_SetPlayStateR(channel: u32_, value: u32_);
}
unsafe extern "C" {
    #[doc = "Sets a channel's play state.\n # Arguments\n\n* `channel` - Channel to use.\n * `value` - Play state to set."]
    pub fn CSND_SetPlayState(channel: u32_, value: u32_);
}
unsafe extern "C" {
    #[doc = "Sets a channel's encoding.\n # Arguments\n\n* `channel` - Channel to use.\n * `value` - Encoding to set."]
    pub fn CSND_SetEncoding(channel: u32_, value: u32_);
}
unsafe extern "C" {
    #[doc = "Sets the data of a channel's block.\n # Arguments\n\n* `channel` - Channel to use.\n * `block` - Block to set.\n * `physaddr` - Physical address to set the block to.\n * `size` - Size of the block."]
    pub fn CSND_SetBlock(channel: u32_, block: ::libc::c_int, physaddr: u32_, size: u32_);
}
unsafe extern "C" {
    #[doc = "Sets whether to loop a channel.\n # Arguments\n\n* `channel` - Channel to use.\n * `value` - Whether to loop the channel."]
    pub fn CSND_SetLooping(channel: u32_, value: u32_);
}
unsafe extern "C" {
    #[doc = "Sets bit 7 of a channel.\n # Arguments\n\n* `channel` - Channel to use.\n * `set` - Value to set."]
    pub fn CSND_SetBit7(channel: u32_, set: bool);
}
unsafe extern "C" {
    #[doc = "Sets whether a channel should use interpolation.\n # Arguments\n\n* `channel` - Channel to use.\n * `interp` - Whether to use interpolation."]
    pub fn CSND_SetInterp(channel: u32_, interp: bool);
}
unsafe extern "C" {
    #[doc = "Sets a channel's duty.\n # Arguments\n\n* `channel` - Channel to use.\n * `duty` - Duty to set."]
    pub fn CSND_SetDuty(channel: u32_, duty: CSND_DutyCycle);
}
unsafe extern "C" {
    #[doc = "Sets a channel's timer.\n # Arguments\n\n* `channel` - Channel to use.\n * `timer` - Timer to set."]
    pub fn CSND_SetTimer(channel: u32_, timer: u32_);
}
unsafe extern "C" {
    #[doc = "Sets a channel's volume.\n # Arguments\n\n* `channel` - Channel to use.\n * `chnVolumes` - Channel volume data to set.\n * `capVolumes` - Capture volume data to set."]
    pub fn CSND_SetVol(channel: u32_, chnVolumes: u32_, capVolumes: u32_);
}
unsafe extern "C" {
    #[doc = "Sets a channel's ADPCM state.\n # Arguments\n\n* `channel` - Channel to use.\n * `block` - Current block.\n * `sample` - Current sample.\n * `index` - Current index."]
    pub fn CSND_SetAdpcmState(
        channel: u32_,
        block: ::libc::c_int,
        sample: ::libc::c_int,
        index: ::libc::c_int,
    );
}
unsafe extern "C" {
    #[doc = "Sets a whether channel's ADPCM data should be reloaded when the second block is played.\n # Arguments\n\n* `channel` - Channel to use.\n * `reload` - Whether to reload ADPCM data."]
    pub fn CSND_SetAdpcmReload(channel: u32_, reload: bool);
}
unsafe extern "C" {
    #[doc = "Sets CSND's channel registers.\n # Arguments\n\n* `flags` - Flags to set.\n * `physaddr0` - Physical address of the first buffer to play.\n * `physaddr1` - Physical address of the second buffer to play.\n * `totalbytesize` - Total size of the data to play.\n * `chnVolumes` - Channel volume data.\n * `capVolumes` - Capture volume data."]
    pub fn CSND_SetChnRegs(
        flags: u32_,
        physaddr0: u32_,
        physaddr1: u32_,
        totalbytesize: u32_,
        chnVolumes: u32_,
        capVolumes: u32_,
    );
}
unsafe extern "C" {
    #[doc = "Sets CSND's PSG channel registers.\n # Arguments\n\n* `flags` - Flags to set.\n * `chnVolumes` - Channel volume data.\n * `capVolumes` - Capture volume data.\n * `duty` - Duty value to set."]
    pub fn CSND_SetChnRegsPSG(
        flags: u32_,
        chnVolumes: u32_,
        capVolumes: u32_,
        duty: CSND_DutyCycle,
    );
}
unsafe extern "C" {
    #[doc = "Sets CSND's noise channel registers.\n # Arguments\n\n* `flags` - Flags to set.\n * `chnVolumes` - Channel volume data.\n * `capVolumes` - Capture volume data."]
    pub fn CSND_SetChnRegsNoise(flags: u32_, chnVolumes: u32_, capVolumes: u32_);
}
unsafe extern "C" {
    #[doc = "Sets whether a capture unit is enabled.\n # Arguments\n\n* `capUnit` - Capture unit to use.\n * `enable` - Whether to enable the capture unit."]
    pub fn CSND_CapEnable(capUnit: u32_, enable: bool);
}
unsafe extern "C" {
    #[doc = "Sets whether a capture unit should repeat.\n # Arguments\n\n* `capUnit` - Capture unit to use.\n * `repeat` - Whether the capture unit should repeat."]
    pub fn CSND_CapSetRepeat(capUnit: u32_, repeat: bool);
}
unsafe extern "C" {
    #[doc = "Sets a capture unit's format.\n # Arguments\n\n* `capUnit` - Capture unit to use.\n * `eightbit` - Format to use."]
    pub fn CSND_CapSetFormat(capUnit: u32_, eightbit: bool);
}
unsafe extern "C" {
    #[doc = "Sets a capture unit's second bit.\n # Arguments\n\n* `capUnit` - Capture unit to use.\n * `set` - Value to set."]
    pub fn CSND_CapSetBit2(capUnit: u32_, set: bool);
}
unsafe extern "C" {
    #[doc = "Sets a capture unit's timer.\n # Arguments\n\n* `capUnit` - Capture unit to use.\n * `timer` - Timer to set."]
    pub fn CSND_CapSetTimer(capUnit: u32_, timer: u32_);
}
unsafe extern "C" {
    #[doc = "Sets a capture unit's buffer.\n # Arguments\n\n* `capUnit` - Capture unit to use.\n * `addr` - Buffer address to use.\n * `size` - Size of the buffer."]
    pub fn CSND_CapSetBuffer(capUnit: u32_, addr: u32_, size: u32_);
}
unsafe extern "C" {
    #[doc = "Sets a capture unit's capture registers.\n # Arguments\n\n* `capUnit` - Capture unit to use.\n * `flags` - Capture unit flags.\n * `addr` - Capture unit buffer address.\n * `size` - Buffer size."]
    pub fn CSND_SetCapRegs(capUnit: u32_, flags: u32_, addr: u32_, size: u32_);
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets up DSP flags.\n # Arguments\n\n* `waitDone` - Whether to wait for completion."]
    pub fn CSND_SetDspFlags(waitDone: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Updates CSND information.\n # Arguments\n\n* `waitDone` - Whether to wait for completion."]
    pub fn CSND_UpdateInfo(waitDone: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Plays a sound.\n # Arguments\n\n* `chn` - Channel to play the sound on.\n * `flags` - Flags containing information about the sound.\n * `sampleRate` - Sample rate of the sound.\n * `vol` - The volume, ranges from 0.0 to 1.0 included.\n * `pan` - The pan, ranges from -1.0 to 1.0 included.\n * `data0` - First block of sound data.\n * `data1` - Second block of sound data. This is the block that will be looped over.\n * `size` - Size of the sound data.\n\n In this implementation if the loop mode is used, data1 must be in the range [data0 ; data0 + size]. Sound will be played once from data0 to data0 + size and then loop between data1 and data0+size."]
    pub fn csndPlaySound(
        chn: ::libc::c_int,
        flags: u32_,
        sampleRate: u32_,
        vol: f32,
        pan: f32,
        data0: *mut ::libc::c_void,
        data1: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Gets CSND's DSP flags.\n Note: Requires previous CSND_UpdateInfo()\n # Arguments\n\n* `outSemFlags` - Pointer to write semaphore flags to.\n * `outIrqFlags` - Pointer to write interrupt flags to."]
    pub fn csndGetDspFlags(outSemFlags: *mut u32_, outIrqFlags: *mut u32_);
}
unsafe extern "C" {
    #[doc = "Gets a channel's information.\n Note: Requires previous CSND_UpdateInfo()\n # Arguments\n\n* `channel` - Channel to get information for.\n # Returns\n\nThe channel's information."]
    pub fn csndGetChnInfo(channel: u32_) -> *mut CSND_ChnInfo;
}
unsafe extern "C" {
    #[doc = "Gets a capture unit's information.\n Note: Requires previous CSND_UpdateInfo()\n # Arguments\n\n* `capUnit` - Capture unit to get information for.\n # Returns\n\nThe capture unit's information."]
    pub fn csndGetCapInfo(capUnit: u32_) -> *mut CSND_CapInfo;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a channel's state.\n # Arguments\n\n* `channel` - Channel to get the state of.\n * `out` - Pointer to output channel information to."]
    pub fn csndGetState(channel: u32_, out: *mut CSND_ChnInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether a channel is playing.\n # Arguments\n\n* `channel` - Channel to check.\n * `status` - Pointer to output the channel status to."]
    pub fn csndIsPlaying(channel: u32_, status: *mut u8_) -> Result;
}
#[doc = "< Pipe interrupt."]
pub const DSP_INTERRUPT_PIPE: DSP_InterruptType = 2;
#[doc = "DSP interrupt types."]
pub type DSP_InterruptType = ::libc::c_uchar;
#[doc = "< DSP is going to sleep."]
pub const DSPHOOK_ONSLEEP: DSP_HookType = 0;
#[doc = "< DSP is waking up."]
pub const DSPHOOK_ONWAKEUP: DSP_HookType = 1;
#[doc = "< DSP was sleeping and the app was cancelled."]
pub const DSPHOOK_ONCANCEL: DSP_HookType = 2;
#[doc = "DSP hook types."]
pub type DSP_HookType = ::libc::c_uchar;
#[doc = "DSP hook function."]
pub type dspHookFn = ::core::option::Option<unsafe extern "C" fn(hook: DSP_HookType)>;
#[doc = "DSP hook cookie."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_dspHookCookie {
    #[doc = "< Next cookie."]
    pub next: *mut tag_dspHookCookie,
    #[doc = "< Hook callback."]
    pub callback: dspHookFn,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tag_dspHookCookie"][::core::mem::size_of::<tag_dspHookCookie>() - 8usize];
    ["Alignment of tag_dspHookCookie"][::core::mem::align_of::<tag_dspHookCookie>() - 4usize];
    ["Offset of field: tag_dspHookCookie::next"]
        [::core::mem::offset_of!(tag_dspHookCookie, next) - 0usize];
    ["Offset of field: tag_dspHookCookie::callback"]
        [::core::mem::offset_of!(tag_dspHookCookie, callback) - 4usize];
};
impl Default for tag_dspHookCookie {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "DSP hook cookie."]
pub type dspHookCookie = tag_dspHookCookie;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the dsp service.\n\n Call this before calling any DSP_* function.\n > **Note:** This will also unload any previously loaded DSP binary.\n It is done this way since you have to provide your binary when the 3DS leaves sleep mode anyway."]
    pub fn dspInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Closes the dsp service.\n > **Note:** This will also unload the DSP binary."]
    pub fn dspExit();
}
unsafe extern "C" {
    #[doc = "Returns true if a component is loaded, false otherwise."]
    pub fn dspIsComponentLoaded() -> bool;
}
unsafe extern "C" {
    #[doc = "Sets up a DSP status hook.\n # Arguments\n\n* `cookie` - Hook cookie to use.\n * `callback` - Function to call when DSP's status changes."]
    pub fn dspHook(cookie: *mut dspHookCookie, callback: dspHookFn);
}
unsafe extern "C" {
    #[doc = "Removes a DSP status hook.\n # Arguments\n\n* `cookie` - Hook cookie to remove."]
    pub fn dspUnhook(cookie: *mut dspHookCookie);
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if a headphone is inserted.\n # Arguments\n\n* `is_inserted` - Pointer to output the insertion status to."]
    pub fn DSP_GetHeadphoneStatus(is_inserted: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Flushes the cache\n # Arguments\n\n* `address` - Beginning of the memory range to flush, inside the Linear or DSP memory regions\n * `size` - Size of the memory range to flush\n\n Flushes the cache for the specified memory range and invalidates the cache"]
    pub fn DSP_FlushDataCache(address: *const ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Invalidates the cache\n # Arguments\n\n* `address` - Beginning of the memory range to invalidate, inside the Linear or DSP memory regions\n * `size` - Size of the memory range to flush\n\n Invalidates the cache for the specified memory range"]
    pub fn DSP_InvalidateDataCache(address: *const ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrieves the handle of the DSP semaphore.\n # Arguments\n\n* `semaphore` - Pointer to output the semaphore to."]
    pub fn DSP_GetSemaphoreHandle(semaphore: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the DSP hardware semaphore value.\n # Arguments\n\n* `value` - Value to set."]
    pub fn DSP_SetSemaphore(value: u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Masks the DSP hardware semaphore value.\n # Arguments\n\n* `mask` - Mask to apply."]
    pub fn DSP_SetSemaphoreMask(mask: u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Loads a DSP binary and starts the DSP\n # Arguments\n\n* `component` - The program file address in memory\n * `size` - The size of the program\n * `prog_mask` - DSP memory block related ? Default is 0xff.\n * `data_mask` - DSP memory block related ? Default is 0xff.\n * `is_loaded` - Indicates if the DSP was succesfully loaded.\n\n > **Note:** The binary must be signed (http://3dbrew.org/wiki/DSP_Binary)\n > **Note:** Seems to be called when the 3ds leaves the Sleep mode"]
    pub fn DSP_LoadComponent(
        component: *const ::libc::c_void,
        size: u32_,
        prog_mask: u16_,
        data_mask: u16_,
        is_loaded: *mut bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Stops the DSP by unloading the binary."]
    pub fn DSP_UnloadComponent() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Registers an event handle with the DSP through IPC\n # Arguments\n\n* `handle` - Event handle to register.\n * `interrupt` - The type of interrupt that will trigger the event. Usual value is DSP_INTERRUPT_PIPE.\n * `channel` - The pipe channel. Usual value is 2\n\n > **Note:** It is possible that interrupt are inverted"]
    pub fn DSP_RegisterInterruptEvents(handle: Handle, interrupt: u32_, channel: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads a pipe if possible.\n # Arguments\n\n* `channel` - unknown. Usually 2\n * `peer` - unknown. Usually 0\n * `buffer` - The buffer that will store the values read from the pipe\n * `length` - Length of the buffer\n * `length_read` - Number of bytes read by the command"]
    pub fn DSP_ReadPipeIfPossible(
        channel: u32_,
        peer: u32_,
        buffer: *mut ::libc::c_void,
        length: u16_,
        length_read: *mut u16_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes to a pipe.\n # Arguments\n\n* `channel` - unknown. Usually 2\n * `buffer` - The message to send to the DSP process\n * `length` - Length of the message"]
    pub fn DSP_WriteProcessPipe(
        channel: u32_,
        buffer: *const ::libc::c_void,
        length: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Converts a DSP memory address to a virtual address usable by the process.\n # Arguments\n\n* `dsp_address` - Address to convert.\n * `arm_address` - Pointer to output the converted address to."]
    pub fn DSP_ConvertProcessAddressFromDspDram(
        dsp_address: u32_,
        arm_address: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads a DSP register\n # Arguments\n\n* `regNo` - Offset of the hardware register, base address is 0x1EC40000\n * `value` - Pointer to read the register value to."]
    pub fn DSP_RecvData(regNo: u16_, value: *mut u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if you can read a DSP register\n # Arguments\n\n* `regNo` - Offset of the hardware register, base address is 0x1EC40000\n * `is_ready` - Pointer to write the ready status to.\n\n This call might hang if the data is not ready. See DSP_SendDataIsEmpty."]
    pub fn DSP_RecvDataIsReady(regNo: u16_, is_ready: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes to a DSP register\n # Arguments\n\n* `regNo` - Offset of the hardware register, base address is 0x1EC40000\n * `value` - Value to write.\n\n This call might hang if the SendData is not empty. See DSP_SendDataIsEmpty."]
    pub fn DSP_SendData(regNo: u16_, value: u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if you can write to a DSP register ?\n # Arguments\n\n* `regNo` - Offset of the hardware register, base address is 0x1EC40000\n * `is_empty` - Pointer to write the empty status to."]
    pub fn DSP_SendDataIsEmpty(regNo: u16_, is_empty: *mut bool) -> Result;
}
pub type FSPXI_Archive = u64_;
pub type FSPXI_File = u64_;
pub type FSPXI_Directory = u64_;
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens a file.\n # Arguments\n\n* `out` - Pointer to output the file handle to.\n * `archive` - Archive containing the file.\n * `path` - Path of the file.\n * `flags` - Flags to open the file with.\n * `attributes` - Attributes of the file."]
    pub fn FSPXI_OpenFile(
        serviceHandle: Handle,
        out: *mut FSPXI_File,
        archive: FSPXI_Archive,
        path: FS_Path,
        flags: u32_,
        attributes: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes a file.\n # Arguments\n\n* `archive` - Archive containing the file.\n * `path` - Path of the file."]
    pub fn FSPXI_DeleteFile(serviceHandle: Handle, archive: FSPXI_Archive, path: FS_Path)
    -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Renames a file.\n # Arguments\n\n* `srcArchive` - Archive containing the source file.\n * `srcPath` - Path of the source file.\n * `dstArchive` - Archive containing the destination file.\n * `dstPath` - Path of the destination file."]
    pub fn FSPXI_RenameFile(
        serviceHandle: Handle,
        srcArchive: FSPXI_Archive,
        srcPath: FS_Path,
        dstArchive: FSPXI_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes a directory.\n # Arguments\n\n* `archive` - Archive containing the directory.\n * `path` - Path of the directory."]
    pub fn FSPXI_DeleteDirectory(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        path: FS_Path,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a file.\n # Arguments\n\n* `archive` - Archive to create the file in.\n * `path` - Path of the file.\n * `attributes` - Attributes of the file.\n * `size` - Size of the file."]
    pub fn FSPXI_CreateFile(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        path: FS_Path,
        attributes: u32_,
        fileSize: u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a directory.\n # Arguments\n\n* `archive` - Archive to create the directory in.\n * `path` - Path of the directory.\n * `attributes` - Attributes of the directory."]
    pub fn FSPXI_CreateDirectory(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        path: FS_Path,
        attributes: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Renames a directory.\n # Arguments\n\n* `srcArchive` - Archive containing the source directory.\n * `srcPath` - Path of the source directory.\n * `dstArchive` - Archive containing the destination directory.\n * `dstPath` - Path of the destination directory."]
    pub fn FSPXI_RenameDirectory(
        serviceHandle: Handle,
        srcArchive: FSPXI_Archive,
        srcPath: FS_Path,
        dstArchive: FSPXI_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens a directory.\n # Arguments\n\n* `out` - Pointer to output the directory handle to.\n * `archive` - Archive containing the directory.\n * `path` - Path of the directory."]
    pub fn FSPXI_OpenDirectory(
        serviceHandle: Handle,
        out: *mut FSPXI_Directory,
        archive: FSPXI_Archive,
        path: FS_Path,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads from a file.\n # Arguments\n\n* `file` - File to read from.\n * `bytesRead` - Pointer to output the number of read bytes to.\n * `offset` - Offset to read from.\n * `buffer` - Buffer to read to.\n * `size` - Size of the buffer."]
    pub fn FSPXI_ReadFile(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesRead: *mut u32_,
        offset: u64_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Calculate SHA256 of a file.\n # Arguments\n\n* `file` - File to calculate the hash of.\n * `buffer` - Buffer to output the hash to.\n * `size` - Size of the buffer."]
    pub fn FSPXI_CalculateFileHashSHA256(
        serviceHandle: Handle,
        file: FSPXI_File,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes to a file.\n # Arguments\n\n* `file` - File to write to.\n * `bytesWritten` - Pointer to output the number of bytes written to.\n * `offset` - Offset to write to.\n * `buffer` - Buffer to write from.\n * `size` - Size of the buffer.\n * `flags` - Flags to use when writing."]
    pub fn FSPXI_WriteFile(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesWritten: *mut u32_,
        offset: u64_,
        buffer: *const ::libc::c_void,
        size: u32_,
        flags: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Calculates the MAC used in a DISA/DIFF header?\n # Arguments\n\n* `file` - Unsure\n * `inBuffer` - 0x100-byte DISA/DIFF input buffer.\n * `inSize` - Size of inBuffer.\n * `outBuffer` - Buffer to write MAC to.\n * `outSize` - Size of outBuffer."]
    pub fn FSPXI_CalcSavegameMAC(
        serviceHandle: Handle,
        file: FSPXI_File,
        inBuffer: *const ::libc::c_void,
        inSize: u32_,
        outBuffer: *mut ::libc::c_void,
        outSize: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Get size of a file\n # Arguments\n\n* `file` - File to get the size of.\n * `size` - Pointer to output size to."]
    pub fn FSPXI_GetFileSize(serviceHandle: Handle, file: FSPXI_File, size: *mut u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Set size of a file\n # Arguments\n\n* `file` - File to set the size of\n * `size` - Size to set the file to"]
    pub fn FSPXI_SetFileSize(serviceHandle: Handle, file: FSPXI_File, size: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Close a file\n # Arguments\n\n* `file` - File to close"]
    pub fn FSPXI_CloseFile(serviceHandle: Handle, file: FSPXI_File) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads one or more directory entries.\n # Arguments\n\n* `directory` - Directory to read from.\n * `entriesRead` - Pointer to output the number of entries read to.\n * `entryCount` - Number of entries to read.\n * `entryOut` - Pointer to output directory entries to."]
    pub fn FSPXI_ReadDirectory(
        serviceHandle: Handle,
        directory: FSPXI_Directory,
        entriesRead: *mut u32_,
        entryCount: u32_,
        entries: *mut FS_DirectoryEntry,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Close a directory\n # Arguments\n\n* `directory` - Directory to close."]
    pub fn FSPXI_CloseDirectory(serviceHandle: Handle, directory: FSPXI_Directory) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens an archive.\n # Arguments\n\n* `archive` - Pointer to output the opened archive to.\n * `id` - ID of the archive.\n * `path` - Path of the archive."]
    pub fn FSPXI_OpenArchive(
        serviceHandle: Handle,
        archive: *mut FSPXI_Archive,
        archiveID: FS_ArchiveID,
        path: FS_Path,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if the archive contains a file at path.\n # Arguments\n\n* `archive` - Archive to check.\n * `out` - Pointer to output existence to.\n * `path` - Path to check for file"]
    pub fn FSPXI_HasFile(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut bool,
        path: FS_Path,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if the archive contains a directory at path.\n # Arguments\n\n* `archive` - Archive to check.\n * `out` - Pointer to output existence to.\n * `path` - Path to check for directory"]
    pub fn FSPXI_HasDirectory(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut bool,
        path: FS_Path,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Commits an archive's save data.\n # Arguments\n\n* `archive` - Archive to commit.\n * `id` - Archive action sent by FSUSER_ControlArchive. Must not be 0 or 0x789D\n > Unsure why id is sent. This appears to be the default action for FSUSER_ControlArchive, with every action other than 0 and 0x789D being sent to this command."]
    pub fn FSPXI_CommitSaveData(serviceHandle: Handle, archive: FSPXI_Archive, id: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Close an archive\n # Arguments\n\n* `archive` - Archive to close."]
    pub fn FSPXI_CloseArchive(serviceHandle: Handle, archive: FSPXI_Archive) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unknown 0x17. Appears to be an \"is archive handle valid\" command?\n # Arguments\n\n* `archive` - Archive handle to check validity of.\n * `out` - Pointer to output validity to."]
    pub fn FSPXI_Unknown0x17(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the inserted card type.\n # Arguments\n\n* `out` - Pointer to output the card type to."]
    pub fn FSPXI_GetCardType(serviceHandle: Handle, out: *mut FS_CardType) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC archive resource information.\n # Arguments\n\n* `out` - Pointer to output the archive resource information to."]
    pub fn FSPXI_GetSdmcArchiveResource(
        serviceHandle: Handle,
        out: *mut FS_ArchiveResource,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the NAND archive resource information.\n # Arguments\n\n* `out` - Pointer to output the archive resource information to."]
    pub fn FSPXI_GetNandArchiveResource(
        serviceHandle: Handle,
        out: *mut FS_ArchiveResource,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the error code from the SDMC FatFS driver\n # Arguments\n\n* `out` - Pointer to output the error code to"]
    pub fn FSPXI_GetSdmcFatFsError(serviceHandle: Handle, out: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether PXIFS0 detects the SD\n # Arguments\n\n* `out` - Pointer to output the detection status to"]
    pub fn FSPXI_IsSdmcDetected(serviceHandle: Handle, out: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether PXIFS0 can write to the SD\n # Arguments\n\n* `out` - Pointer to output the writable status to"]
    pub fn FSPXI_IsSdmcWritable(serviceHandle: Handle, out: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC CID\n # Arguments\n\n* `out` - Buffer to output the CID to.\n * `size` - Size of buffer."]
    pub fn FSPXI_GetSdmcCid(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the NAND CID\n # Arguments\n\n* `out` - Buffer to output the CID to.\n * `size` - Size of buffer."]
    pub fn FSPXI_GetNandCid(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC speed info\n # Arguments\n\n* `out` - Buffer to output the speed info to."]
    pub fn FSPXI_GetSdmcSpeedInfo(serviceHandle: Handle, out: *mut FS_SdMmcSpeedInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the NAND speed info\n # Arguments\n\n* `out` - Buffer to output the speed info to."]
    pub fn FSPXI_GetNandSpeedInfo(serviceHandle: Handle, out: *mut FS_SdMmcSpeedInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC log\n # Arguments\n\n* `out` - Buffer to output the log to.\n * `size` - Size of buffer."]
    pub fn FSPXI_GetSdmcLog(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the NAND log\n # Arguments\n\n* `out` - Buffer to output the log to.\n * `size` - Size of buffer."]
    pub fn FSPXI_GetNandLog(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Clears the SDMC log"]
    pub fn FSPXI_ClearSdmcLog(serviceHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Clears the NAND log"]
    pub fn FSPXI_ClearNandLog(serviceHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether a card is inserted.\n # Arguments\n\n* `inserted` - Pointer to output the insertion status to."]
    pub fn FSPXI_CardSlotIsInserted(serviceHandle: Handle, inserted: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Powers on the card slot.\n # Arguments\n\n* `status` - Pointer to output the power status to."]
    pub fn FSPXI_CardSlotPowerOn(serviceHandle: Handle, status: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Powers off the card slot.\n # Arguments\n\n* `status` - Pointer to output the power status to."]
    pub fn FSPXI_CardSlotPowerOff(serviceHandle: Handle, status: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the card's power status.\n # Arguments\n\n* `status` - Pointer to output the power status to."]
    pub fn FSPXI_CardSlotGetCardIFPowerStatus(serviceHandle: Handle, status: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct command.\n # Arguments\n\n* `commandId` - ID of the command."]
    pub fn FSPXI_CardNorDirectCommand(serviceHandle: Handle, commandId: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct command with an address.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide."]
    pub fn FSPXI_CardNorDirectCommandWithAddress(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct read.\n # Arguments\n\n* `commandId` - ID of the command.\n * `size` - Size of the output buffer.\n * `output` - Output buffer."]
    pub fn FSPXI_CardNorDirectRead(
        serviceHandle: Handle,
        commandId: u8_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct read with an address.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide.\n * `size` - Size of the output buffer.\n * `output` - Output buffer."]
    pub fn FSPXI_CardNorDirectReadWithAddress(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct write.\n # Arguments\n\n* `commandId` - ID of the command.\n * `size` - Size of the input buffer.\n * `output` - Input buffer.\n > Stubbed in latest firmware, since ?.?.?"]
    pub fn FSPXI_CardNorDirectWrite(
        serviceHandle: Handle,
        commandId: u8_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct write with an address.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide.\n * `size` - Size of the input buffer.\n * `input` - Input buffer."]
    pub fn FSPXI_CardNorDirectWriteWithAddress(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR 4xIO direct read.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide.\n * `size` - Size of the output buffer.\n * `output` - Output buffer."]
    pub fn FSPXI_CardNorDirectRead_4xIO(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct CPU write without verify.\n # Arguments\n\n* `address` - Address to provide.\n * `size` - Size of the input buffer.\n * `output` - Input buffer."]
    pub fn FSPXI_CardNorDirectCpuWriteWithoutVerify(
        serviceHandle: Handle,
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct sector erase without verify.\n # Arguments\n\n* `address` - Address to provide."]
    pub fn FSPXI_CardNorDirectSectorEraseWithoutVerify(
        serviceHandle: Handle,
        address: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets an NCCH's product info\n # Arguments\n\n* `info` - Pointer to output the product info to.\n * `archive` - Open NCCH content archive"]
    pub fn FSPXI_GetProductInfo(
        serviceHandle: Handle,
        info: *mut FS_ProductInfo,
        archive: FSPXI_Archive,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the CARDSPI baud rate.\n # Arguments\n\n* `baudRate` - Baud rate to set."]
    pub fn FSPXI_SetCardSpiBaudrate(serviceHandle: Handle, baudRate: FS_CardSpiBaudRate) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the CARDSPI bus mode.\n # Arguments\n\n* `busMode` - Bus mode to set."]
    pub fn FSPXI_SetCardSpiBusMode(serviceHandle: Handle, busMode: FS_CardSpiBusMode) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sends initialization info to ARM9\n # Arguments\n\n* `unk` - FS sends *(0x1FF81086)"]
    pub fn FSPXI_SendInitializeInfoTo9(serviceHandle: Handle, unk: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates ext save data.\n # Arguments\n\n* `info` - Info of the save data."]
    pub fn FSPXI_CreateExtSaveData(serviceHandle: Handle, info: FS_ExtSaveDataInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes ext save data.\n # Arguments\n\n* `info` - Info of the save data."]
    pub fn FSPXI_DeleteExtSaveData(serviceHandle: Handle, info: FS_ExtSaveDataInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Enumerates ext save data.\n # Arguments\n\n* `idsWritten` - Pointer to output the number of IDs written to.\n * `idsSize` - Size of the IDs buffer.\n * `mediaType` - Media type to enumerate over.\n * `idSize` - Size of each ID element.\n * `shared` - Whether to enumerate shared ext save data.\n * `ids` - Pointer to output IDs to."]
    pub fn FSPXI_EnumerateExtSaveData(
        serviceHandle: Handle,
        idsWritten: *mut u32_,
        idsSize: u32_,
        mediaType: FS_MediaType,
        idSize: u32_,
        shared: bool,
        ids: *mut u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a special content's index.\n # Arguments\n\n* `index` - Pointer to output the index to.\n * `mediaType` - Media type of the special content.\n * `programId` - Program ID owning the special content.\n * `type` - Type of special content."]
    pub fn FSPXI_GetSpecialContentIndex(
        serviceHandle: Handle,
        index: *mut u16_,
        mediaType: FS_MediaType,
        programId: u64_,
        type_: FS_SpecialContentType,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the legacy ROM header of a program.\n # Arguments\n\n* `mediaType` - Media type of the program.\n * `programId` - ID of the program.\n * `header` - Pointer to output the legacy ROM header to. (size = 0x3B4)"]
    pub fn FSPXI_GetLegacyRomHeader(
        serviceHandle: Handle,
        mediaType: FS_MediaType,
        programId: u64_,
        header: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the legacy banner data of a program.\n # Arguments\n\n* `mediaType` - Media type of the program.\n * `programId` - ID of the program.\n * `banner` - Pointer to output the legacy banner data to. (size = 0x23C0)\n * `unk` - Unknown. Always 1?"]
    pub fn FSPXI_GetLegacyBannerData(
        serviceHandle: Handle,
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
        unk: u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Formats the CARDNOR device.\n # Arguments\n\n* `unk` - Unknown. Transaction?"]
    pub fn FSPXI_FormatCardNorDevice(serviceHandle: Handle, unk: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes the 3DS SDMC root."]
    pub fn FSPXI_DeleteSdmcRoot(serviceHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Deletes all ext save data on the NAND."]
    pub fn FSPXI_DeleteAllExtSaveDataOnNand(serviceHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the CTR file system."]
    pub fn FSPXI_InitializeCtrFilesystem(serviceHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates the FS seed."]
    pub fn FSPXI_CreateSeed(serviceHandle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the CTR SDMC root path.\n # Arguments\n\n* `out` - Pointer to output the root path to.\n * `length` - Length of the output buffer in bytes."]
    pub fn FSPXI_GetSdmcCtrRootPath(serviceHandle: Handle, out: *mut u16_, length: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets an archive's resource information.\n # Arguments\n\n* `archiveResource` - Pointer to output the archive resource information to.\n * `mediaType` - System media type to check."]
    pub fn FSPXI_GetArchiveResource(
        serviceHandle: Handle,
        archiveResource: *mut FS_ArchiveResource,
        mediaType: FS_SystemMediaType,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Exports the integrity verification seed.\n # Arguments\n\n* `seed` - Pointer to output the seed to."]
    pub fn FSPXI_ExportIntegrityVerificationSeed(
        serviceHandle: Handle,
        seed: *mut FS_IntegrityVerificationSeed,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Imports an integrity verification seed.\n # Arguments\n\n* `seed` - Seed to import."]
    pub fn FSPXI_ImportIntegrityVerificationSeed(
        serviceHandle: Handle,
        seed: *const FS_IntegrityVerificationSeed,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the legacy sub banner data of a program.\n # Arguments\n\n* `bannerSize` - Size of the banner.\n * `mediaType` - Media type of the program.\n * `programId` - ID of the program.\n * `header` - Pointer to output the legacy sub banner data to."]
    pub fn FSPXI_GetLegacySubBannerData(
        serviceHandle: Handle,
        bannerSize: u32_,
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Generates random bytes. Uses same code as PSPXI_GenerateRandomBytes\n # Arguments\n\n* `buf` - Buffer to output random bytes to.\n * `size` - Size of buffer."]
    pub fn FSPXI_GenerateRandomBytes(
        serviceHandle: Handle,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the last modified time of a file in an archive.\n # Arguments\n\n* `archive` - The archive that contains the file.\n * `out` - The pointer to write the timestamp to.\n * `path` - The UTF-16 path of the file.\n * `size` - The size of the path."]
    pub fn FSPXI_GetFileLastModified(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut u64_,
        path: *const u16_,
        size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads from a special file.\n # Arguments\n\n* `bytesRead` - Pointer to output the number of bytes read to.\n * `fileOffset` - Offset of the file.\n * `size` - Size of the buffer.\n * `data` - Buffer to read to."]
    pub fn FSPXI_ReadSpecialFile(
        serviceHandle: Handle,
        bytesRead: *mut u32_,
        fileOffset: u64_,
        size: u32_,
        data: *mut ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the size of a special file.\n # Arguments\n\n* `fileSize` - Pointer to output the size to."]
    pub fn FSPXI_GetSpecialFileSize(serviceHandle: Handle, fileSize: *mut u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initiates a device move as the source device.\n # Arguments\n\n* `context` - Pointer to output the context to."]
    pub fn FSPXI_StartDeviceMoveAsSource(
        serviceHandle: Handle,
        context: *mut FS_DeviceMoveContext,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initiates a device move as the destination device.\n # Arguments\n\n* `context` - Context to use.\n * `clear` - Whether to clear the device's data first."]
    pub fn FSPXI_StartDeviceMoveAsDestination(
        serviceHandle: Handle,
        context: FS_DeviceMoveContext,
        clear: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads data and stores SHA256 hashes of blocks\n # Arguments\n\n* `file` - File to read from.\n * `bytesRead` - Pointer to output the number of read bytes to.\n * `offset` - Offset to read from.\n * `readBuffer` - Pointer to store read data in.\n * `readBufferSize` - Size of readBuffer.\n * `hashtable` - Pointer to store SHA256 hashes in.\n * `hashtableSize` - Size of hashtable.\n * `unk` - Unknown. Always 0x00001000? Possibly block size?"]
    pub fn FSPXI_ReadFileSHA256(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesRead: *mut u32_,
        offset: u64_,
        readBuffer: *mut ::libc::c_void,
        readBufferSize: u32_,
        hashtable: *mut ::libc::c_void,
        hashtableSize: u32_,
        unk: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Assumedly writes data and stores SHA256 hashes of blocks\n # Arguments\n\n* `file` - File to write to.\n * `bytesWritten` - Pointer to output the number of written bytes to.\n * `offset` - Offset to write to.\n * `writeBuffer` - Buffer to write from.\n * `writeBufferSize` - Size of writeBuffer.\n * `hashtable` - Pointer to store SHA256 hashes in.\n * `hashtableSize` - Size of hashtable\n * `unk1` - Unknown. Might match with ReadFileSHA256's unknown?\n * `unk2` - Unknown. Might match with ReadFileSHA256's unknown?"]
    pub fn FSPXI_WriteFileSHA256(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesWritten: *mut u32_,
        offset: u64_,
        writeBuffer: *const ::libc::c_void,
        writeBufferSize: u32_,
        hashtable: *mut ::libc::c_void,
        hashtableSize: u32_,
        unk1: u32_,
        unk2: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures CTRCARD latency emulation.\n # Arguments\n\n* `latency` - Latency to apply."]
    pub fn FSPXI_SetCtrCardLatencyParameter(serviceHandle: Handle, latency: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the file system priority.\n # Arguments\n\n* `priority` - Priority to set."]
    pub fn FSPXI_SetPriority(serviceHandle: Handle, priority: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Toggles cleaning up invalid save data.\n # Arguments\n\n* `enable` - Whether to enable cleaning up invalid save data."]
    pub fn FSPXI_SwitchCleanupInvalidSaveData(serviceHandle: Handle, enable: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Enumerates system save data.\n # Arguments\n\n* `idsWritten` - Pointer to output the number of IDs written to.\n * `idsSize` - Size of the IDs buffer.\n * `ids` - Pointer to output IDs to."]
    pub fn FSPXI_EnumerateSystemSaveData(
        serviceHandle: Handle,
        idsWritten: *mut u32_,
        idsSize: u32_,
        ids: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads the NAND report.\n # Arguments\n\n* `unk` - Unknown\n * `buffer` - Buffer to write the report to.\n * `size` - Size of buffer"]
    pub fn FSPXI_ReadNandReport(
        serviceHandle: Handle,
        buffer: *mut ::libc::c_void,
        size: u32_,
        unk: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unknown command 0x56\n > Called by FSUSER_ControlArchive with ArchiveAction 0x789D"]
    pub fn FSPXI_Unknown0x56(
        serviceHandle: Handle,
        out: *mut u32_,
        archive: FS_Archive,
        path: FS_Path,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes fs:REG."]
    pub fn fsRegInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits fs:REG."]
    pub fn fsRegExit();
}
unsafe extern "C" {
    #[doc = "Gets the current fs:REG session handle.\n # Returns\n\nThe current fs:REG session handle."]
    pub fn fsRegGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Registers a program's storage information.\n # Arguments\n\n* `pid` - The Process ID of the program.\n * `programHandle` - The program handle.\n * `programInfo` - Information about the program.\n * `storageInfo` - Storage information to register."]
    pub fn FSREG_Register(
        pid: u32_,
        programHandle: u64_,
        programInfo: *const FS_ProgramInfo,
        storageInfo: *const ExHeader_Arm11StorageInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unregisters a program's storage information.\n # Arguments\n\n* `pid` - The Process ID of the program."]
    pub fn FSREG_Unregister(pid: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrives the exheader information set(s) (SCI+ACI) about a program.\n # Arguments\n\n* `exheaderInfos[out]` - Pointer to the output exheader information set(s).\n * `maxNumEntries` - The maximum number of entries.\n * `programHandle` - The program handle."]
    pub fn FSREG_GetProgramInfo(
        exheaderInfos: *mut ExHeader_Info,
        maxNumEntries: u32_,
        programHandle: u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Loads a program.\n # Arguments\n\n* `programHandle[out]` - Pointer to the output the program handle to.\n * `programInfo` - Information about the program to load."]
    pub fn FSREG_LoadProgram(
        programHandle: *mut u64_,
        programInfo: *const FS_ProgramInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unloads a program.\n # Arguments\n\n* `programHandle` - The program handle."]
    pub fn FSREG_UnloadProgram(programHandle: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if a program has been loaded by fs:REG.\n # Arguments\n\n* `programHandle` - The program handle."]
    pub fn FSREG_CheckHostLoadId(programHandle: u64_) -> Result;
}
#[doc = "< Top screen."]
pub const GSPLCD_SCREEN_TOP: _bindgen_ty_22 = 1;
#[doc = "< Bottom screen."]
pub const GSPLCD_SCREEN_BOTTOM: _bindgen_ty_22 = 2;
#[doc = "< Both screens."]
pub const GSPLCD_SCREEN_BOTH: _bindgen_ty_22 = 3;
#[doc = "LCD screens."]
pub type _bindgen_ty_22 = ::libc::c_uchar;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes GSPLCD."]
    pub fn gspLcdInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits GSPLCD."]
    pub fn gspLcdExit();
}
unsafe extern "C" {
    #[doc = "Gets a pointer to the current gsp::Lcd session handle.\n # Returns\n\nA pointer to the current gsp::Lcd session handle."]
    pub fn gspLcdGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Powers on both backlights."]
    pub fn GSPLCD_PowerOnAllBacklights() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Powers off both backlights."]
    pub fn GSPLCD_PowerOffAllBacklights() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Powers on the backlight.\n # Arguments\n\n* `screen` - Screen to power on."]
    pub fn GSPLCD_PowerOnBacklight(screen: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Powers off the backlight.\n # Arguments\n\n* `screen` - Screen to power off."]
    pub fn GSPLCD_PowerOffBacklight(screen: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets 3D_LEDSTATE to the input state value.\n # Arguments\n\n* `disable` - False = 3D LED enable, true = 3D LED disable."]
    pub fn GSPLCD_SetLedForceOff(disable: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the LCD screens' vendors. Stubbed on old 3ds.\n # Arguments\n\n* `vendor` - Pointer to output the screen vendors to."]
    pub fn GSPLCD_GetVendors(vendors: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the LCD screens' brightness. Stubbed on old 3ds.\n # Arguments\n\n* `screen` - Screen to get the brightness value of.\n * `brightness` - Brightness value returned."]
    pub fn GSPLCD_GetBrightness(screen: u32_, brightness: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the LCD screens' brightness.\n # Arguments\n\n* `screen` - Screen to set the brightness value of.\n * `brightness` - Brightness value set."]
    pub fn GSPLCD_SetBrightness(screen: u32_, brightness: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the LCD screens' raw brightness.\n # Arguments\n\n* `screen` - Screen to set the brightness value of.\n * `brightness` - Brightness value set."]
    pub fn GSPLCD_SetBrightnessRaw(screen: u32_, brightness: u32_) -> Result;
}
#[doc = "< A"]
pub const KEY_A: _bindgen_ty_23 = 1;
#[doc = "< B"]
pub const KEY_B: _bindgen_ty_23 = 2;
#[doc = "< Select"]
pub const KEY_SELECT: _bindgen_ty_23 = 4;
#[doc = "< Start"]
pub const KEY_START: _bindgen_ty_23 = 8;
#[doc = "< D-Pad Right"]
pub const KEY_DRIGHT: _bindgen_ty_23 = 16;
#[doc = "< D-Pad Left"]
pub const KEY_DLEFT: _bindgen_ty_23 = 32;
#[doc = "< D-Pad Up"]
pub const KEY_DUP: _bindgen_ty_23 = 64;
#[doc = "< D-Pad Down"]
pub const KEY_DDOWN: _bindgen_ty_23 = 128;
#[doc = "< R"]
pub const KEY_R: _bindgen_ty_23 = 256;
#[doc = "< L"]
pub const KEY_L: _bindgen_ty_23 = 512;
#[doc = "< X"]
pub const KEY_X: _bindgen_ty_23 = 1024;
#[doc = "< Y"]
pub const KEY_Y: _bindgen_ty_23 = 2048;
#[doc = "< ZL (New 3DS only)"]
pub const KEY_ZL: _bindgen_ty_23 = 16384;
#[doc = "< ZR (New 3DS only)"]
pub const KEY_ZR: _bindgen_ty_23 = 32768;
#[doc = "< Touch (Not actually provided by HID)"]
pub const KEY_TOUCH: _bindgen_ty_23 = 1048576;
#[doc = "< C-Stick Right (New 3DS only)"]
pub const KEY_CSTICK_RIGHT: _bindgen_ty_23 = 16777216;
#[doc = "< C-Stick Left (New 3DS only)"]
pub const KEY_CSTICK_LEFT: _bindgen_ty_23 = 33554432;
#[doc = "< C-Stick Up (New 3DS only)"]
pub const KEY_CSTICK_UP: _bindgen_ty_23 = 67108864;
#[doc = "< C-Stick Down (New 3DS only)"]
pub const KEY_CSTICK_DOWN: _bindgen_ty_23 = 134217728;
#[doc = "< Circle Pad Right"]
pub const KEY_CPAD_RIGHT: _bindgen_ty_23 = 268435456;
#[doc = "< Circle Pad Left"]
pub const KEY_CPAD_LEFT: _bindgen_ty_23 = 536870912;
#[doc = "< Circle Pad Up"]
pub const KEY_CPAD_UP: _bindgen_ty_23 = 1073741824;
#[doc = "< Circle Pad Down"]
pub const KEY_CPAD_DOWN: _bindgen_ty_23 = 2147483648;
#[doc = "< D-Pad Up or Circle Pad Up"]
pub const KEY_UP: _bindgen_ty_23 = 1073741888;
#[doc = "< D-Pad Down or Circle Pad Down"]
pub const KEY_DOWN: _bindgen_ty_23 = 2147483776;
#[doc = "< D-Pad Left or Circle Pad Left"]
pub const KEY_LEFT: _bindgen_ty_23 = 536870944;
#[doc = "< D-Pad Right or Circle Pad Right"]
pub const KEY_RIGHT: _bindgen_ty_23 = 268435472;
#[doc = "Key values."]
pub type _bindgen_ty_23 = ::libc::c_uint;
#[doc = "Touch position."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct touchPosition {
    #[doc = "< Touch X"]
    pub px: u16_,
    #[doc = "< Touch Y"]
    pub py: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of touchPosition"][::core::mem::size_of::<touchPosition>() - 4usize];
    ["Alignment of touchPosition"][::core::mem::align_of::<touchPosition>() - 2usize];
    ["Offset of field: touchPosition::px"][::core::mem::offset_of!(touchPosition, px) - 0usize];
    ["Offset of field: touchPosition::py"][::core::mem::offset_of!(touchPosition, py) - 2usize];
};
#[doc = "Circle Pad position."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct circlePosition {
    #[doc = "< Pad X"]
    pub dx: s16,
    #[doc = "< Pad Y"]
    pub dy: s16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of circlePosition"][::core::mem::size_of::<circlePosition>() - 4usize];
    ["Alignment of circlePosition"][::core::mem::align_of::<circlePosition>() - 2usize];
    ["Offset of field: circlePosition::dx"][::core::mem::offset_of!(circlePosition, dx) - 0usize];
    ["Offset of field: circlePosition::dy"][::core::mem::offset_of!(circlePosition, dy) - 2usize];
};
#[doc = "Accelerometer vector."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct accelVector {
    #[doc = "< Accelerometer X"]
    pub x: s16,
    #[doc = "< Accelerometer Y"]
    pub y: s16,
    #[doc = "< Accelerometer Z"]
    pub z: s16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of accelVector"][::core::mem::size_of::<accelVector>() - 6usize];
    ["Alignment of accelVector"][::core::mem::align_of::<accelVector>() - 2usize];
    ["Offset of field: accelVector::x"][::core::mem::offset_of!(accelVector, x) - 0usize];
    ["Offset of field: accelVector::y"][::core::mem::offset_of!(accelVector, y) - 2usize];
    ["Offset of field: accelVector::z"][::core::mem::offset_of!(accelVector, z) - 4usize];
};
#[doc = "Gyroscope angular rate."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct angularRate {
    #[doc = "< Roll"]
    pub x: s16,
    #[doc = "< Yaw"]
    pub z: s16,
    #[doc = "< Pitch"]
    pub y: s16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of angularRate"][::core::mem::size_of::<angularRate>() - 6usize];
    ["Alignment of angularRate"][::core::mem::align_of::<angularRate>() - 2usize];
    ["Offset of field: angularRate::x"][::core::mem::offset_of!(angularRate, x) - 0usize];
    ["Offset of field: angularRate::z"][::core::mem::offset_of!(angularRate, z) - 2usize];
    ["Offset of field: angularRate::y"][::core::mem::offset_of!(angularRate, y) - 4usize];
};
#[doc = "< Event signaled by HID-module, when the sharedmem+0(PAD/circle-pad)/+0xA8(touch-screen) region was updated."]
pub const HIDEVENT_PAD0: HID_Event = 0;
#[doc = "< Event signaled by HID-module, when the sharedmem+0(PAD/circle-pad)/+0xA8(touch-screen) region was updated."]
pub const HIDEVENT_PAD1: HID_Event = 1;
#[doc = "< Event signaled by HID-module, when the sharedmem accelerometer state was updated."]
pub const HIDEVENT_Accel: HID_Event = 2;
#[doc = "< Event signaled by HID-module, when the sharedmem gyroscope state was updated."]
pub const HIDEVENT_Gyro: HID_Event = 3;
#[doc = "< Event signaled by HID-module, when the sharedmem DebugPad state was updated."]
pub const HIDEVENT_DebugPad: HID_Event = 4;
#[doc = "< Used to know how many events there are."]
pub const HIDEVENT_MAX: HID_Event = 5;
#[doc = "HID events."]
pub type HID_Event = ::libc::c_uchar;
unsafe extern "C" {
    #[doc = "< HID shared memory handle."]
    pub static mut hidMemHandle: Handle;
}
unsafe extern "C" {
    #[doc = "< HID shared memory."]
    pub static mut hidSharedMem: *mut vu32;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes HID."]
    pub fn hidInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits HID."]
    pub fn hidExit();
}
unsafe extern "C" {
    #[doc = "Sets the key repeat parameters for hidKeysRepeat.\n # Arguments\n\n* `delay` - Initial delay.\n * `interval` - Repeat interval."]
    pub fn hidSetRepeatParameters(delay: u32_, interval: u32_);
}
unsafe extern "C" {
    #[doc = "Scans HID for input data."]
    pub fn hidScanInput();
}
unsafe extern "C" {
    #[doc = "Returns a bitmask of held buttons.\n Individual buttons can be extracted using binary AND.\n # Returns\n\n32-bit bitmask of held buttons (1+ frames)."]
    pub fn hidKeysHeld() -> u32_;
}
unsafe extern "C" {
    #[doc = "Returns a bitmask of newly pressed buttons, this frame.\n Individual buttons can be extracted using binary AND.\n # Returns\n\n32-bit bitmask of newly pressed buttons."]
    pub fn hidKeysDown() -> u32_;
}
unsafe extern "C" {
    #[doc = "Returns a bitmask of newly pressed or repeated buttons, this frame.\n Individual buttons can be extracted using binary AND.\n # Returns\n\n32-bit bitmask of newly pressed or repeated buttons."]
    pub fn hidKeysDownRepeat() -> u32_;
}
unsafe extern "C" {
    #[doc = "Returns a bitmask of newly released buttons, this frame.\n Individual buttons can be extracted using binary AND.\n # Returns\n\n32-bit bitmask of newly released buttons."]
    pub fn hidKeysUp() -> u32_;
}
unsafe extern "C" {
    #[doc = "Reads the current touch position.\n # Arguments\n\n* `pos` - Pointer to output the touch position to."]
    pub fn hidTouchRead(pos: *mut touchPosition);
}
unsafe extern "C" {
    #[doc = "Reads the current circle pad position.\n # Arguments\n\n* `pos` - Pointer to output the circle pad position to."]
    pub fn hidCircleRead(pos: *mut circlePosition);
}
unsafe extern "C" {
    #[doc = "Reads the current accelerometer data.\n # Arguments\n\n* `vector` - Pointer to output the accelerometer data to."]
    pub fn hidAccelRead(vector: *mut accelVector);
}
unsafe extern "C" {
    #[doc = "Reads the current gyroscope data.\n # Arguments\n\n* `rate` - Pointer to output the gyroscope data to."]
    pub fn hidGyroRead(rate: *mut angularRate);
}
unsafe extern "C" {
    #[doc = "Waits for an HID event.\n # Arguments\n\n* `id` - ID of the event.\n * `nextEvent` - Whether to discard the current event and wait for the next event."]
    pub fn hidWaitForEvent(id: HID_Event, nextEvent: bool);
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Waits for any HID or IRRST event.\n # Arguments\n\n* `nextEvents` - Whether to discard the current events and wait for the next events.\n * `cancelEvent` - Optional additional handle to wait on, otherwise 0.\n * `timeout` - Timeout."]
    pub fn hidWaitForAnyEvent(nextEvents: bool, cancelEvent: Handle, timeout: s64) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the handles for HID operation.\n # Arguments\n\n* `outMemHandle` - Pointer to output the shared memory handle to.\n * `eventpad0` - Pointer to output the pad 0 event handle to.\n * `eventpad1` - Pointer to output the pad 1 event handle to.\n * `eventaccel` - Pointer to output the accelerometer event handle to.\n * `eventgyro` - Pointer to output the gyroscope event handle to.\n * `eventdebugpad` - Pointer to output the debug pad event handle to."]
    pub fn HIDUSER_GetHandles(
        outMemHandle: *mut Handle,
        eventpad0: *mut Handle,
        eventpad1: *mut Handle,
        eventaccel: *mut Handle,
        eventgyro: *mut Handle,
        eventdebugpad: *mut Handle,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Enables the accelerometer."]
    pub fn HIDUSER_EnableAccelerometer() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Disables the accelerometer."]
    pub fn HIDUSER_DisableAccelerometer() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Enables the gyroscope."]
    pub fn HIDUSER_EnableGyroscope() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Disables the gyroscope."]
    pub fn HIDUSER_DisableGyroscope() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the gyroscope raw to dps coefficient.\n # Arguments\n\n* `coeff` - Pointer to output the coefficient to."]
    pub fn HIDUSER_GetGyroscopeRawToDpsCoefficient(coeff: *mut f32) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current volume slider value. (0-63)\n # Arguments\n\n* `volume` - Pointer to write the volume slider value to."]
    pub fn HIDUSER_GetSoundVolume(volume: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[doc = "IRRST's shared memory handle."]
    pub static mut irrstMemHandle: Handle;
}
unsafe extern "C" {
    #[doc = "IRRST's shared memory."]
    pub static mut irrstSharedMem: *mut vu32;
}
unsafe extern "C" {
    #[doc = "IRRST's state update event"]
    pub static mut irrstEvent: Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes IRRST."]
    pub fn irrstInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits IRRST."]
    pub fn irrstExit();
}
unsafe extern "C" {
    #[doc = "Scans IRRST for input."]
    pub fn irrstScanInput();
}
unsafe extern "C" {
    #[doc = "Gets IRRST's held keys.\n # Returns\n\nIRRST's held keys."]
    pub fn irrstKeysHeld() -> u32_;
}
unsafe extern "C" {
    #[doc = "Reads the current c-stick position.\n # Arguments\n\n* `pos` - Pointer to output the current c-stick position to."]
    pub fn irrstCstickRead(pos: *mut circlePosition);
}
unsafe extern "C" {
    #[doc = "Waits for the IRRST input event to trigger.\n # Arguments\n\n* `nextEvent` - Whether to discard the current event and wait until the next event."]
    pub fn irrstWaitForEvent(nextEvent: bool);
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the shared memory and event handles for IRRST.\n # Arguments\n\n* `outMemHandle` - Pointer to write the shared memory handle to.\n * `outEventHandle` - Pointer to write the event handle to."]
    pub fn IRRST_GetHandles(outMemHandle: *mut Handle, outEventHandle: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes IRRST.\n # Arguments\n\n* `unk1` - Unknown.\n * `unk2` - Unknown."]
    pub fn IRRST_Initialize(unk1: u32_, unk2: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Shuts down IRRST."]
    pub fn IRRST_Shutdown() -> Result;
}
#[doc = "sslc context."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sslcContext {
    #[doc = "< Service handle."]
    pub servhandle: Handle,
    #[doc = "< SSLC handle."]
    pub sslchandle: u32_,
    pub sharedmem_handle: Handle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sslcContext"][::core::mem::size_of::<sslcContext>() - 12usize];
    ["Alignment of sslcContext"][::core::mem::align_of::<sslcContext>() - 4usize];
    ["Offset of field: sslcContext::servhandle"]
        [::core::mem::offset_of!(sslcContext, servhandle) - 0usize];
    ["Offset of field: sslcContext::sslchandle"]
        [::core::mem::offset_of!(sslcContext, sslchandle) - 4usize];
    ["Offset of field: sslcContext::sharedmem_handle"]
        [::core::mem::offset_of!(sslcContext, sharedmem_handle) - 8usize];
};
pub const SSLC_DefaultRootCert_Nintendo_CA: SSLC_DefaultRootCert = 1;
pub const SSLC_DefaultRootCert_Nintendo_CA_G2: SSLC_DefaultRootCert = 2;
pub const SSLC_DefaultRootCert_Nintendo_CA_G3: SSLC_DefaultRootCert = 3;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA: SSLC_DefaultRootCert = 4;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA_G2: SSLC_DefaultRootCert = 5;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA_G3: SSLC_DefaultRootCert = 6;
pub const SSLC_DefaultRootCert_CyberTrust: SSLC_DefaultRootCert = 7;
pub const SSLC_DefaultRootCert_AddTrust_External_CA: SSLC_DefaultRootCert = 8;
pub const SSLC_DefaultRootCert_COMODO: SSLC_DefaultRootCert = 9;
pub const SSLC_DefaultRootCert_USERTrust: SSLC_DefaultRootCert = 10;
pub const SSLC_DefaultRootCert_DigiCert_EV: SSLC_DefaultRootCert = 11;
pub type SSLC_DefaultRootCert = ::libc::c_uchar;
pub const SSLC_DefaultClientCert_ClCertA: SSLC_DefaultClientCert = 64;
pub type SSLC_DefaultClientCert = ::libc::c_uchar;
pub const SSLCOPT_Default: _bindgen_ty_24 = 0;
pub const SSLCOPT_DisableVerify: _bindgen_ty_24 = 512;
pub const SSLCOPT_TLSv10: _bindgen_ty_24 = 2048;
#[doc = "sslc options. https://www.3dbrew.org/wiki/SSL_Services#SSLOpt"]
pub type _bindgen_ty_24 = ::libc::c_ushort;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes SSLC. Normally session_handle should be 0. When non-zero this will use the specified handle for the main-service-session without using the Initialize command, instead of using srvGetServiceHandle."]
    pub fn sslcInit(session_handle: Handle) -> Result;
}
unsafe extern "C" {
    #[doc = "Exits SSLC."]
    pub fn sslcExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - Output contexthandle."]
    pub fn sslcCreateRootCertChain(RootCertChain_contexthandle: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Destroys a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain contexthandle."]
    pub fn sslcDestroyRootCertChain(RootCertChain_contexthandle: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a trusted RootCA cert to a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain to use.\n * `cert` - Pointer to the DER cert.\n * `certsize` - Size of the DER cert."]
    pub fn sslcAddTrustedRootCA(
        RootCertChain_contexthandle: u32_,
        cert: *const u8_,
        certsize: u32_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a default RootCA cert to a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain to use.\n * `certID` - ID of the cert to add.\n * `cert_contexthandle` - Optional, the cert contexthandle can be written here."]
    pub fn sslcRootCertChainAddDefaultCert(
        RootCertChain_contexthandle: u32_,
        certID: SSLC_DefaultRootCert,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Removes the specified cert from the RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain to use.\n * `cert_contexthandle` - Cert contexthandle to remove from the RootCertChain."]
    pub fn sslcRootCertChainRemoveCert(
        RootCertChain_contexthandle: u32_,
        cert_contexthandle: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates an unknown CertChain.\n # Arguments\n\n* `CertChain_contexthandle` - Output contexthandle."]
    pub fn sslcCreate8CertChain(CertChain_contexthandle: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Destroys a CertChain from sslcCreate8CertChain().\n # Arguments\n\n* `CertChain_contexthandle` - CertChain contexthandle."]
    pub fn sslcDestroy8CertChain(CertChain_contexthandle: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a cert to a CertChain from sslcCreate8CertChain().\n # Arguments\n\n* `CertChain_contexthandle` - CertChain to use.\n * `cert` - Pointer to the cert.\n * `certsize` - Size of the cert."]
    pub fn sslc8CertChainAddCert(
        CertChain_contexthandle: u32_,
        cert: *const u8_,
        certsize: u32_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a default cert to a CertChain from sslcCreate8CertChain(). Not actually usable since no certIDs are implemented in SSL-module for this.\n # Arguments\n\n* `CertChain_contexthandle` - CertChain to use.\n * `certID` - ID of the cert to add.\n * `cert_contexthandle` - Optional, the cert contexthandle can be written here."]
    pub fn sslc8CertChainAddDefaultCert(
        CertChain_contexthandle: u32_,
        certID: u8_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Removes the specified cert from the CertChain from sslcCreate8CertChain().\n # Arguments\n\n* `CertChain_contexthandle` - CertChain to use.\n * `cert_contexthandle` - Cert contexthandle to remove from the CertChain."]
    pub fn sslc8CertChainRemoveCert(
        CertChain_contexthandle: u32_,
        cert_contexthandle: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens a new ClientCert-context.\n # Arguments\n\n* `cert` - Pointer to the DER cert.\n * `certsize` - Size of the DER cert.\n * `key` - Pointer to the DER key.\n * `keysize` - Size of the DER key.\n * `ClientCert_contexthandle` - Output contexthandle."]
    pub fn sslcOpenClientCertContext(
        cert: *const u8_,
        certsize: u32_,
        key: *const u8_,
        keysize: u32_,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens a ClientCert-context with a default certID.\n # Arguments\n\n* `certID` - ID of the ClientCert to use.\n * `ClientCert_contexthandle` - Output contexthandle."]
    pub fn sslcOpenDefaultClientCertContext(
        certID: SSLC_DefaultClientCert,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Closes the specified ClientCert-context.\n # Arguments\n\n* `ClientCert_contexthandle` - ClientCert-context to use."]
    pub fn sslcCloseClientCertContext(ClientCert_contexthandle: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This uses ps:ps SeedRNG internally."]
    pub fn sslcSeedRNG() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This uses ps:ps GenerateRandomData internally.\n # Arguments\n\n* `buf` - Output buffer.\n * `size` - Output size."]
    pub fn sslcGenerateRandomData(buf: *mut u8_, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a sslc context.\n # Arguments\n\n* `context` - sslc context.\n * `sockfd` - Socket fd, this code automatically uses the required SOC command before using the actual sslc command.\n * `input_opt` - Input sslc options bitmask.\n * `hostname` - Server hostname."]
    pub fn sslcCreateContext(
        context: *mut sslcContext,
        sockfd: ::libc::c_int,
        input_opt: u32_,
        hostname: *const ::libc::c_char,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    pub fn sslcDestroyContext(context: *mut sslcContext) -> Result;
}
unsafe extern "C" {
    #[must_use]
    pub fn sslcStartConnection(
        context: *mut sslcContext,
        internal_retval: *mut ::libc::c_int,
        out: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    pub fn sslcRead(
        context: *mut sslcContext,
        buf: *mut ::libc::c_void,
        len: usize,
        peek: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    pub fn sslcWrite(context: *mut sslcContext, buf: *const ::libc::c_void, len: usize) -> Result;
}
unsafe extern "C" {
    #[must_use]
    pub fn sslcContextSetRootCertChain(context: *mut sslcContext, handle: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    pub fn sslcContextSetClientCert(context: *mut sslcContext, handle: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    pub fn sslcContextSetHandle8(context: *mut sslcContext, handle: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    pub fn sslcContextClearOpt(context: *mut sslcContext, bitmask: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    pub fn sslcContextGetProtocolCipher(
        context: *mut sslcContext,
        outprotocols: *mut ::libc::c_char,
        outprotocols_maxsize: u32_,
        outcipher: *mut ::libc::c_char,
        outcipher_maxsize: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    pub fn sslcContextGetState(context: *mut sslcContext, out: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    pub fn sslcContextInitSharedmem(context: *mut sslcContext, buf: *mut u8_, size: u32_)
    -> Result;
}
unsafe extern "C" {
    #[must_use]
    pub fn sslcAddCert(context: *mut sslcContext, buf: *const u8_, size: u32_) -> Result;
}
#[doc = "HTTP context."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct httpcContext {
    #[doc = "< Service handle."]
    pub servhandle: Handle,
    #[doc = "< HTTP handle."]
    pub httphandle: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of httpcContext"][::core::mem::size_of::<httpcContext>() - 8usize];
    ["Alignment of httpcContext"][::core::mem::align_of::<httpcContext>() - 4usize];
    ["Offset of field: httpcContext::servhandle"]
        [::core::mem::offset_of!(httpcContext, servhandle) - 0usize];
    ["Offset of field: httpcContext::httphandle"]
        [::core::mem::offset_of!(httpcContext, httphandle) - 4usize];
};
pub const HTTPC_METHOD_GET: HTTPC_RequestMethod = 1;
pub const HTTPC_METHOD_POST: HTTPC_RequestMethod = 2;
pub const HTTPC_METHOD_HEAD: HTTPC_RequestMethod = 3;
pub const HTTPC_METHOD_PUT: HTTPC_RequestMethod = 4;
pub const HTTPC_METHOD_DELETE: HTTPC_RequestMethod = 5;
#[doc = "HTTP request method."]
pub type HTTPC_RequestMethod = ::libc::c_uchar;
#[doc = "< Request in progress."]
pub const HTTPC_STATUS_REQUEST_IN_PROGRESS: HTTPC_RequestStatus = 5;
#[doc = "< Download ready."]
pub const HTTPC_STATUS_DOWNLOAD_READY: HTTPC_RequestStatus = 7;
#[doc = "HTTP request status."]
pub type HTTPC_RequestStatus = ::libc::c_uchar;
pub const HTTPC_KEEPALIVE_DISABLED: HTTPC_KeepAlive = 0;
pub const HTTPC_KEEPALIVE_ENABLED: HTTPC_KeepAlive = 1;
#[doc = "HTTP KeepAlive option."]
pub type HTTPC_KeepAlive = ::libc::c_uchar;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes HTTPC. For HTTP GET the sharedmem_size can be zero. The sharedmem contains data which will be later uploaded for HTTP POST. sharedmem_size should be aligned to 0x1000-bytes."]
    pub fn httpcInit(sharedmem_size: u32_) -> Result;
}
unsafe extern "C" {
    #[doc = "Exits HTTPC."]
    pub fn httpcExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens a HTTP context.\n # Arguments\n\n* `context` - Context to open.\n * `url` - URL to connect to.\n * `use_defaultproxy` - Whether the default proxy should be used (0 for default)"]
    pub fn httpcOpenContext(
        context: *mut httpcContext,
        method: HTTPC_RequestMethod,
        url: *const ::libc::c_char,
        use_defaultproxy: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Closes a HTTP context.\n # Arguments\n\n* `context` - Context to close."]
    pub fn httpcCloseContext(context: *mut httpcContext) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Cancels a HTTP connection.\n # Arguments\n\n* `context` - Context to close."]
    pub fn httpcCancelConnection(context: *mut httpcContext) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a request header field to a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `name` - Name of the field.\n * `value` - Value of the field."]
    pub fn httpcAddRequestHeaderField(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const ::libc::c_char,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a POST form field to a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `name` - Name of the field.\n * `value` - Value of the field."]
    pub fn httpcAddPostDataAscii(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const ::libc::c_char,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a POST form field with binary data to a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `name` - Name of the field.\n * `value` - The binary data to pass as a value.\n * `len` - Length of the binary data which has been passed."]
    pub fn httpcAddPostDataBinary(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const u8_,
        len: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a POST body to a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `data` - The data to be passed as raw into the body of the post request.\n * `len` - Length of data passed by data param."]
    pub fn httpcAddPostDataRaw(context: *mut httpcContext, data: *const u32_, len: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Begins a HTTP request.\n # Arguments\n\n* `context` - Context to use."]
    pub fn httpcBeginRequest(context: *mut httpcContext) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Receives data from a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `buffer` - Buffer to receive data to.\n * `size` - Size of the buffer."]
    pub fn httpcReceiveData(context: *mut httpcContext, buffer: *mut u8_, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Receives data from a HTTP context with a timeout value.\n # Arguments\n\n* `context` - Context to use.\n * `buffer` - Buffer to receive data to.\n * `size` - Size of the buffer.\n * `timeout` - Maximum time in nanoseconds to wait for a reply."]
    pub fn httpcReceiveDataTimeout(
        context: *mut httpcContext,
        buffer: *mut u8_,
        size: u32_,
        timeout: u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the request state of a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `out` - Pointer to output the HTTP request state to."]
    pub fn httpcGetRequestState(
        context: *mut httpcContext,
        out: *mut HTTPC_RequestStatus,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the download size state of a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `downloadedsize` - Pointer to output the downloaded size to.\n * `contentsize` - Pointer to output the total content size to."]
    pub fn httpcGetDownloadSizeState(
        context: *mut httpcContext,
        downloadedsize: *mut u32_,
        contentsize: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the response code of the HTTP context.\n # Arguments\n\n* `context` - Context to get the response code of.\n * `out` - Pointer to write the response code to."]
    pub fn httpcGetResponseStatusCode(context: *mut httpcContext, out: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the response code of the HTTP context with a timeout value.\n # Arguments\n\n* `context` - Context to get the response code of.\n * `out` - Pointer to write the response code to.\n * `timeout` - Maximum time in nanoseconds to wait for a reply."]
    pub fn httpcGetResponseStatusCodeTimeout(
        context: *mut httpcContext,
        out: *mut u32_,
        timeout: u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a response header field from a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `name` - Name of the field.\n * `value` - Pointer to output the value of the field to.\n * `valuebuf_maxsize` - Maximum size of the value buffer."]
    pub fn httpcGetResponseHeader(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *mut ::libc::c_char,
        valuebuf_maxsize: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a trusted RootCA cert to a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `cert` - Pointer to DER cert.\n * `certsize` - Size of the DER cert."]
    pub fn httpcAddTrustedRootCA(
        context: *mut httpcContext,
        cert: *const u8_,
        certsize: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a default RootCA cert to a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `certID` - ID of the cert to add, see sslc.h."]
    pub fn httpcAddDefaultCert(context: *mut httpcContext, certID: SSLC_DefaultRootCert) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the RootCertChain for a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `RootCertChain_contexthandle` - Contexthandle for the RootCertChain."]
    pub fn httpcSelectRootCertChain(
        context: *mut httpcContext,
        RootCertChain_contexthandle: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the ClientCert for a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `cert` - Pointer to DER cert.\n * `certsize` - Size of the DER cert.\n * `privk` - Pointer to the DER private key.\n * `privk_size` - Size of the privk."]
    pub fn httpcSetClientCert(
        context: *mut httpcContext,
        cert: *const u8_,
        certsize: u32_,
        privk: *const u8_,
        privk_size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the default clientcert for a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `certID` - ID of the cert to add, see sslc.h."]
    pub fn httpcSetClientCertDefault(
        context: *mut httpcContext,
        certID: SSLC_DefaultClientCert,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the ClientCert contexthandle for a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `ClientCert_contexthandle` - Contexthandle for the ClientCert."]
    pub fn httpcSetClientCertContext(
        context: *mut httpcContext,
        ClientCert_contexthandle: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets SSL options for the context.\n The HTTPC SSL option bits are the same as those defined in sslc.h\n # Arguments\n\n* `context` - Context to set flags on.\n * `options` - SSL option flags."]
    pub fn httpcSetSSLOpt(context: *mut httpcContext, options: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the SSL options which will be cleared for the context.\n The HTTPC SSL option bits are the same as those defined in sslc.h\n # Arguments\n\n* `context` - Context to clear flags on.\n * `options` - SSL option flags."]
    pub fn httpcSetSSLClearOpt(context: *mut httpcContext, options: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Creates a RootCertChain. Up to 2 RootCertChains can be created under this user-process.\n # Arguments\n\n* `RootCertChain_contexthandle` - Output RootCertChain contexthandle."]
    pub fn httpcCreateRootCertChain(RootCertChain_contexthandle: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Destroy a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain to use."]
    pub fn httpcDestroyRootCertChain(RootCertChain_contexthandle: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a RootCA cert to a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain to use.\n * `cert` - Pointer to DER cert.\n * `certsize` - Size of the DER cert.\n * `cert_contexthandle` - Optional output ptr for the cert contexthandle(this can be NULL)."]
    pub fn httpcRootCertChainAddCert(
        RootCertChain_contexthandle: u32_,
        cert: *const u8_,
        certsize: u32_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a default RootCA cert to a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain to use.\n * `certID` - ID of the cert to add, see sslc.h.\n * `cert_contexthandle` - Optional output ptr for the cert contexthandle(this can be NULL)."]
    pub fn httpcRootCertChainAddDefaultCert(
        RootCertChain_contexthandle: u32_,
        certID: SSLC_DefaultRootCert,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Removes a cert from a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain to use.\n * `cert_contexthandle` - Contexthandle of the cert to remove."]
    pub fn httpcRootCertChainRemoveCert(
        RootCertChain_contexthandle: u32_,
        cert_contexthandle: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens a ClientCert-context. Up to 2 ClientCert-contexts can be open under this user-process.\n # Arguments\n\n* `cert` - Pointer to DER cert.\n * `certsize` - Size of the DER cert.\n * `privk` - Pointer to the DER private key.\n * `privk_size` - Size of the privk.\n * `ClientCert_contexthandle` - Output ClientCert context handle."]
    pub fn httpcOpenClientCertContext(
        cert: *const u8_,
        certsize: u32_,
        privk: *const u8_,
        privk_size: u32_,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens a ClientCert-context with a default clientclient. Up to 2 ClientCert-contexts can be open under this user-process.\n # Arguments\n\n* `certID` - ID of the cert to add, see sslc.h.\n * `ClientCert_contexthandle` - Output ClientCert context handle."]
    pub fn httpcOpenDefaultClientCertContext(
        certID: SSLC_DefaultClientCert,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Closes a ClientCert context.\n # Arguments\n\n* `ClientCert_contexthandle` - ClientCert context to use."]
    pub fn httpcCloseClientCertContext(ClientCert_contexthandle: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Downloads data from the HTTP context into a buffer.\n The *entire* content must be downloaded before using httpcCloseContext(), otherwise httpcCloseContext() will hang.\n # Arguments\n\n* `context` - Context to download data from.\n * `buffer` - Buffer to write data to.\n * `size` - Size of the buffer.\n * `downloadedsize` - Pointer to write the size of the downloaded data to."]
    pub fn httpcDownloadData(
        context: *mut httpcContext,
        buffer: *mut u8_,
        size: u32_,
        downloadedsize: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets Keep-Alive for the context.\n # Arguments\n\n* `context` - Context to set the KeepAlive flag on.\n * `option` - HTTPC_KeepAlive option."]
    pub fn httpcSetKeepAlive(context: *mut httpcContext, option: HTTPC_KeepAlive) -> Result;
}
#[doc = "Node info struct."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct udsNodeInfo {
    pub uds_friendcodeseed: u64_,
    pub __bindgen_anon_1: udsNodeInfo__bindgen_ty_1,
    pub NetworkNodeID: u16_,
    pub pad_x22: u16_,
    pub word_x24: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union udsNodeInfo__bindgen_ty_1 {
    pub usercfg: [u8_; 24usize],
    pub __bindgen_anon_1: udsNodeInfo__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct udsNodeInfo__bindgen_ty_1__bindgen_ty_1 {
    pub username: [u16_; 10usize],
    pub unk_x1c: u16_,
    pub flag: u8_,
    pub pad_x1f: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of udsNodeInfo__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<udsNodeInfo__bindgen_ty_1__bindgen_ty_1>() - 24usize];
    ["Alignment of udsNodeInfo__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<udsNodeInfo__bindgen_ty_1__bindgen_ty_1>() - 2usize];
    ["Offset of field: udsNodeInfo__bindgen_ty_1__bindgen_ty_1::username"]
        [::core::mem::offset_of!(udsNodeInfo__bindgen_ty_1__bindgen_ty_1, username) - 0usize];
    ["Offset of field: udsNodeInfo__bindgen_ty_1__bindgen_ty_1::unk_x1c"]
        [::core::mem::offset_of!(udsNodeInfo__bindgen_ty_1__bindgen_ty_1, unk_x1c) - 20usize];
    ["Offset of field: udsNodeInfo__bindgen_ty_1__bindgen_ty_1::flag"]
        [::core::mem::offset_of!(udsNodeInfo__bindgen_ty_1__bindgen_ty_1, flag) - 22usize];
    ["Offset of field: udsNodeInfo__bindgen_ty_1__bindgen_ty_1::pad_x1f"]
        [::core::mem::offset_of!(udsNodeInfo__bindgen_ty_1__bindgen_ty_1, pad_x1f) - 23usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of udsNodeInfo__bindgen_ty_1"]
        [::core::mem::size_of::<udsNodeInfo__bindgen_ty_1>() - 24usize];
    ["Alignment of udsNodeInfo__bindgen_ty_1"]
        [::core::mem::align_of::<udsNodeInfo__bindgen_ty_1>() - 2usize];
    ["Offset of field: udsNodeInfo__bindgen_ty_1::usercfg"]
        [::core::mem::offset_of!(udsNodeInfo__bindgen_ty_1, usercfg) - 0usize];
};
impl Default for udsNodeInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of udsNodeInfo"][::core::mem::size_of::<udsNodeInfo>() - 40usize];
    ["Alignment of udsNodeInfo"][::core::mem::align_of::<udsNodeInfo>() - 8usize];
    ["Offset of field: udsNodeInfo::uds_friendcodeseed"]
        [::core::mem::offset_of!(udsNodeInfo, uds_friendcodeseed) - 0usize];
    ["Offset of field: udsNodeInfo::NetworkNodeID"]
        [::core::mem::offset_of!(udsNodeInfo, NetworkNodeID) - 32usize];
    ["Offset of field: udsNodeInfo::pad_x22"]
        [::core::mem::offset_of!(udsNodeInfo, pad_x22) - 34usize];
    ["Offset of field: udsNodeInfo::word_x24"]
        [::core::mem::offset_of!(udsNodeInfo, word_x24) - 36usize];
};
impl Default for udsNodeInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Connection status struct."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct udsConnectionStatus {
    pub status: u32_,
    pub unk_x4: u32_,
    pub cur_NetworkNodeID: u16_,
    pub unk_xa: u16_,
    pub unk_xc: [u32_; 8usize],
    pub total_nodes: u8_,
    pub max_nodes: u8_,
    pub node_bitmask: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of udsConnectionStatus"][::core::mem::size_of::<udsConnectionStatus>() - 48usize];
    ["Alignment of udsConnectionStatus"][::core::mem::align_of::<udsConnectionStatus>() - 4usize];
    ["Offset of field: udsConnectionStatus::status"]
        [::core::mem::offset_of!(udsConnectionStatus, status) - 0usize];
    ["Offset of field: udsConnectionStatus::unk_x4"]
        [::core::mem::offset_of!(udsConnectionStatus, unk_x4) - 4usize];
    ["Offset of field: udsConnectionStatus::cur_NetworkNodeID"]
        [::core::mem::offset_of!(udsConnectionStatus, cur_NetworkNodeID) - 8usize];
    ["Offset of field: udsConnectionStatus::unk_xa"]
        [::core::mem::offset_of!(udsConnectionStatus, unk_xa) - 10usize];
    ["Offset of field: udsConnectionStatus::unk_xc"]
        [::core::mem::offset_of!(udsConnectionStatus, unk_xc) - 12usize];
    ["Offset of field: udsConnectionStatus::total_nodes"]
        [::core::mem::offset_of!(udsConnectionStatus, total_nodes) - 44usize];
    ["Offset of field: udsConnectionStatus::max_nodes"]
        [::core::mem::offset_of!(udsConnectionStatus, max_nodes) - 45usize];
    ["Offset of field: udsConnectionStatus::node_bitmask"]
        [::core::mem::offset_of!(udsConnectionStatus, node_bitmask) - 46usize];
};
#[doc = "Network struct stored as big-endian."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udsNetworkStruct {
    pub host_macaddress: [u8_; 6usize],
    pub channel: u8_,
    pub pad_x7: u8_,
    pub initialized_flag: u8_,
    pub unk_x9: [u8_; 3usize],
    pub oui_value: [u8_; 3usize],
    pub oui_type: u8_,
    pub wlancommID: u32_,
    pub id8: u8_,
    pub unk_x15: u8_,
    pub attributes: u16_,
    pub networkID: u32_,
    pub total_nodes: u8_,
    pub max_nodes: u8_,
    pub unk_x1e: u8_,
    pub unk_x1f: u8_,
    pub unk_x20: [u8_; 31usize],
    pub appdata_size: u8_,
    pub appdata: [u8_; 200usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of udsNetworkStruct"][::core::mem::size_of::<udsNetworkStruct>() - 264usize];
    ["Alignment of udsNetworkStruct"][::core::mem::align_of::<udsNetworkStruct>() - 4usize];
    ["Offset of field: udsNetworkStruct::host_macaddress"]
        [::core::mem::offset_of!(udsNetworkStruct, host_macaddress) - 0usize];
    ["Offset of field: udsNetworkStruct::channel"]
        [::core::mem::offset_of!(udsNetworkStruct, channel) - 6usize];
    ["Offset of field: udsNetworkStruct::pad_x7"]
        [::core::mem::offset_of!(udsNetworkStruct, pad_x7) - 7usize];
    ["Offset of field: udsNetworkStruct::initialized_flag"]
        [::core::mem::offset_of!(udsNetworkStruct, initialized_flag) - 8usize];
    ["Offset of field: udsNetworkStruct::unk_x9"]
        [::core::mem::offset_of!(udsNetworkStruct, unk_x9) - 9usize];
    ["Offset of field: udsNetworkStruct::oui_value"]
        [::core::mem::offset_of!(udsNetworkStruct, oui_value) - 12usize];
    ["Offset of field: udsNetworkStruct::oui_type"]
        [::core::mem::offset_of!(udsNetworkStruct, oui_type) - 15usize];
    ["Offset of field: udsNetworkStruct::wlancommID"]
        [::core::mem::offset_of!(udsNetworkStruct, wlancommID) - 16usize];
    ["Offset of field: udsNetworkStruct::id8"]
        [::core::mem::offset_of!(udsNetworkStruct, id8) - 20usize];
    ["Offset of field: udsNetworkStruct::unk_x15"]
        [::core::mem::offset_of!(udsNetworkStruct, unk_x15) - 21usize];
    ["Offset of field: udsNetworkStruct::attributes"]
        [::core::mem::offset_of!(udsNetworkStruct, attributes) - 22usize];
    ["Offset of field: udsNetworkStruct::networkID"]
        [::core::mem::offset_of!(udsNetworkStruct, networkID) - 24usize];
    ["Offset of field: udsNetworkStruct::total_nodes"]
        [::core::mem::offset_of!(udsNetworkStruct, total_nodes) - 28usize];
    ["Offset of field: udsNetworkStruct::max_nodes"]
        [::core::mem::offset_of!(udsNetworkStruct, max_nodes) - 29usize];
    ["Offset of field: udsNetworkStruct::unk_x1e"]
        [::core::mem::offset_of!(udsNetworkStruct, unk_x1e) - 30usize];
    ["Offset of field: udsNetworkStruct::unk_x1f"]
        [::core::mem::offset_of!(udsNetworkStruct, unk_x1f) - 31usize];
    ["Offset of field: udsNetworkStruct::unk_x20"]
        [::core::mem::offset_of!(udsNetworkStruct, unk_x20) - 32usize];
    ["Offset of field: udsNetworkStruct::appdata_size"]
        [::core::mem::offset_of!(udsNetworkStruct, appdata_size) - 63usize];
    ["Offset of field: udsNetworkStruct::appdata"]
        [::core::mem::offset_of!(udsNetworkStruct, appdata) - 64usize];
};
impl Default for udsNetworkStruct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct udsBindContext {
    pub BindNodeID: u32_,
    pub event: Handle,
    pub spectator: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of udsBindContext"][::core::mem::size_of::<udsBindContext>() - 12usize];
    ["Alignment of udsBindContext"][::core::mem::align_of::<udsBindContext>() - 4usize];
    ["Offset of field: udsBindContext::BindNodeID"]
        [::core::mem::offset_of!(udsBindContext, BindNodeID) - 0usize];
    ["Offset of field: udsBindContext::event"]
        [::core::mem::offset_of!(udsBindContext, event) - 4usize];
    ["Offset of field: udsBindContext::spectator"]
        [::core::mem::offset_of!(udsBindContext, spectator) - 8usize];
};
#[doc = "General NWM input structure used for AP scanning."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nwmScanInputStruct {
    pub unk_x0: u16_,
    pub unk_x2: u16_,
    pub unk_x4: u16_,
    pub unk_x6: u16_,
    pub mac_address: [u8_; 6usize],
    pub unk_xe: [u8_; 38usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nwmScanInputStruct"][::core::mem::size_of::<nwmScanInputStruct>() - 52usize];
    ["Alignment of nwmScanInputStruct"][::core::mem::align_of::<nwmScanInputStruct>() - 2usize];
    ["Offset of field: nwmScanInputStruct::unk_x0"]
        [::core::mem::offset_of!(nwmScanInputStruct, unk_x0) - 0usize];
    ["Offset of field: nwmScanInputStruct::unk_x2"]
        [::core::mem::offset_of!(nwmScanInputStruct, unk_x2) - 2usize];
    ["Offset of field: nwmScanInputStruct::unk_x4"]
        [::core::mem::offset_of!(nwmScanInputStruct, unk_x4) - 4usize];
    ["Offset of field: nwmScanInputStruct::unk_x6"]
        [::core::mem::offset_of!(nwmScanInputStruct, unk_x6) - 6usize];
    ["Offset of field: nwmScanInputStruct::mac_address"]
        [::core::mem::offset_of!(nwmScanInputStruct, mac_address) - 8usize];
    ["Offset of field: nwmScanInputStruct::unk_xe"]
        [::core::mem::offset_of!(nwmScanInputStruct, unk_xe) - 14usize];
};
impl Default for nwmScanInputStruct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "General NWM output structure from AP scanning."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nwmBeaconDataReplyHeader {
    pub maxsize: u32_,
    pub size: u32_,
    pub total_entries: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nwmBeaconDataReplyHeader"]
        [::core::mem::size_of::<nwmBeaconDataReplyHeader>() - 12usize];
    ["Alignment of nwmBeaconDataReplyHeader"]
        [::core::mem::align_of::<nwmBeaconDataReplyHeader>() - 4usize];
    ["Offset of field: nwmBeaconDataReplyHeader::maxsize"]
        [::core::mem::offset_of!(nwmBeaconDataReplyHeader, maxsize) - 0usize];
    ["Offset of field: nwmBeaconDataReplyHeader::size"]
        [::core::mem::offset_of!(nwmBeaconDataReplyHeader, size) - 4usize];
    ["Offset of field: nwmBeaconDataReplyHeader::total_entries"]
        [::core::mem::offset_of!(nwmBeaconDataReplyHeader, total_entries) - 8usize];
};
#[doc = "General NWM output structure from AP scanning, for each entry."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nwmBeaconDataReplyEntry {
    pub size: u32_,
    pub unk_x4: u8_,
    pub channel: u8_,
    pub unk_x6: u8_,
    pub unk_x7: u8_,
    pub mac_address: [u8_; 6usize],
    pub unk_xe: [u8_; 6usize],
    pub unk_x14: u32_,
    pub val_x1c: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nwmBeaconDataReplyEntry"]
        [::core::mem::size_of::<nwmBeaconDataReplyEntry>() - 28usize];
    ["Alignment of nwmBeaconDataReplyEntry"]
        [::core::mem::align_of::<nwmBeaconDataReplyEntry>() - 4usize];
    ["Offset of field: nwmBeaconDataReplyEntry::size"]
        [::core::mem::offset_of!(nwmBeaconDataReplyEntry, size) - 0usize];
    ["Offset of field: nwmBeaconDataReplyEntry::unk_x4"]
        [::core::mem::offset_of!(nwmBeaconDataReplyEntry, unk_x4) - 4usize];
    ["Offset of field: nwmBeaconDataReplyEntry::channel"]
        [::core::mem::offset_of!(nwmBeaconDataReplyEntry, channel) - 5usize];
    ["Offset of field: nwmBeaconDataReplyEntry::unk_x6"]
        [::core::mem::offset_of!(nwmBeaconDataReplyEntry, unk_x6) - 6usize];
    ["Offset of field: nwmBeaconDataReplyEntry::unk_x7"]
        [::core::mem::offset_of!(nwmBeaconDataReplyEntry, unk_x7) - 7usize];
    ["Offset of field: nwmBeaconDataReplyEntry::mac_address"]
        [::core::mem::offset_of!(nwmBeaconDataReplyEntry, mac_address) - 8usize];
    ["Offset of field: nwmBeaconDataReplyEntry::unk_xe"]
        [::core::mem::offset_of!(nwmBeaconDataReplyEntry, unk_xe) - 14usize];
    ["Offset of field: nwmBeaconDataReplyEntry::unk_x14"]
        [::core::mem::offset_of!(nwmBeaconDataReplyEntry, unk_x14) - 20usize];
    ["Offset of field: nwmBeaconDataReplyEntry::val_x1c"]
        [::core::mem::offset_of!(nwmBeaconDataReplyEntry, val_x1c) - 24usize];
};
#[doc = "Output structure generated from host scanning output."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct udsNetworkScanInfo {
    pub datareply_entry: nwmBeaconDataReplyEntry,
    pub network: udsNetworkStruct,
    pub nodes: [udsNodeInfo; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of udsNetworkScanInfo"][::core::mem::size_of::<udsNetworkScanInfo>() - 936usize];
    ["Alignment of udsNetworkScanInfo"][::core::mem::align_of::<udsNetworkScanInfo>() - 8usize];
    ["Offset of field: udsNetworkScanInfo::datareply_entry"]
        [::core::mem::offset_of!(udsNetworkScanInfo, datareply_entry) - 0usize];
    ["Offset of field: udsNetworkScanInfo::network"]
        [::core::mem::offset_of!(udsNetworkScanInfo, network) - 28usize];
    ["Offset of field: udsNetworkScanInfo::nodes"]
        [::core::mem::offset_of!(udsNetworkScanInfo, nodes) - 296usize];
};
impl Default for udsNetworkScanInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const UDSNETATTR_DisableConnectSpectators: _bindgen_ty_25 = 1;
pub const UDSNETATTR_DisableConnectClients: _bindgen_ty_25 = 2;
pub const UDSNETATTR_x4: _bindgen_ty_25 = 4;
pub const UDSNETATTR_Default: _bindgen_ty_25 = 32768;
pub type _bindgen_ty_25 = ::libc::c_ushort;
pub const UDS_SENDFLAG_Default: _bindgen_ty_26 = 1;
pub const UDS_SENDFLAG_Broadcast: _bindgen_ty_26 = 2;
pub type _bindgen_ty_26 = ::libc::c_uchar;
pub const UDSCONTYPE_Client: udsConnectionType = 1;
pub const UDSCONTYPE_Spectator: udsConnectionType = 2;
pub type udsConnectionType = ::libc::c_uchar;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes UDS.\n # Arguments\n\n* `sharedmem_size` - This must be 0x1000-byte aligned.\n * `username` - Optional custom UTF-8 username(converted to UTF-16 internally) that other nodes on the UDS network can use. If not set the username from system-config is used. Max len is 10 characters without NUL-terminator."]
    pub fn udsInit(sharedmem_size: usize, username: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[doc = "Exits UDS."]
    pub fn udsExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Generates a NodeInfo struct with data loaded from system-config.\n # Arguments\n\n* `nodeinfo` - Output NodeInfo struct.\n * `username` - If set, this is the UTF-8 string to convert for use in the struct. Max len is 10 characters without NUL-terminator."]
    pub fn udsGenerateNodeInfo(
        nodeinfo: *mut udsNodeInfo,
        username: *const ::libc::c_char,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Loads the UTF-16 username stored in the input NodeInfo struct, converted to UTF-8.\n # Arguments\n\n* `nodeinfo` - Input NodeInfo struct.\n * `username` - This is the output UTF-8 string. Max len is 10 characters without NUL-terminator."]
    pub fn udsGetNodeInfoUsername(
        nodeinfo: *const udsNodeInfo,
        username: *mut ::libc::c_char,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Checks whether a NodeInfo struct was initialized by NWM-module(not any output from udsGenerateNodeInfo()).\n # Arguments\n\n* `nodeinfo` - Input NodeInfo struct."]
    pub fn udsCheckNodeInfoInitialized(nodeinfo: *const udsNodeInfo) -> bool;
}
unsafe extern "C" {
    #[doc = "Generates a default NetworkStruct for creating networks.\n # Arguments\n\n* `network` - The output struct.\n * `wlancommID` - Unique local-WLAN communications ID for each application.\n * `id8` - Additional ID that can be used by the application for different types of networks.\n * `max_nodes` - Maximum number of nodes(devices) that can be connected to the network, including the host."]
    pub fn udsGenerateDefaultNetworkStruct(
        network: *mut udsNetworkStruct,
        wlancommID: u32_,
        id8: u8_,
        max_nodes: u8_,
    );
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Scans for networks via beacon-scanning.\n # Arguments\n\n* `outbuf` - Buffer which will be used by the beacon-scanning command and for the data parsing afterwards. Normally there's no need to use the contents of this buffer once this function returns.\n * `maxsize` - Max size of the buffer.\n networks Ptr where the allocated udsNetworkScanInfo array buffer is written. The allocsize is sizeof(udsNetworkScanInfo)*total_networks.\n total_networks Total number of networks stored under the networks buffer.\n * `wlancommID` - Unique local-WLAN communications ID for each application.\n * `id8` - Additional ID that can be used by the application for different types of networks.\n * `host_macaddress` - When set, this code will only return network info from the specified host MAC address.\n When not connected to a network this *must* be false. When connected to a network this *must* be true."]
    pub fn udsScanBeacons(
        outbuf: *mut ::libc::c_void,
        maxsize: usize,
        networks: *mut *mut udsNetworkScanInfo,
        total_networks: *mut usize,
        wlancommID: u32_,
        id8: u8_,
        host_macaddress: *const u8_,
        connected: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This can be used by the host to set the appdata contained in the broadcasted beacons.\n # Arguments\n\n* `buf` - Appdata buffer.\n * `size` - Size of the input appdata."]
    pub fn udsSetApplicationData(buf: *const ::libc::c_void, size: usize) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This can be used while on a network(host/client) to get the appdata from the current beacon.\n # Arguments\n\n* `buf` - Appdata buffer.\n * `size` - Max size of the output buffer.\n * `actual_size` - If set, the actual size of the appdata written into the buffer is stored here."]
    pub fn udsGetApplicationData(
        buf: *mut ::libc::c_void,
        size: usize,
        actual_size: *mut usize,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This can be used with a NetworkStruct, from udsScanBeacons() mainly, for getting the appdata.\n # Arguments\n\n* `buf` - Appdata buffer.\n * `size` - Max size of the output buffer.\n * `actual_size` - If set, the actual size of the appdata written into the buffer is stored here."]
    pub fn udsGetNetworkStructApplicationData(
        network: *const udsNetworkStruct,
        buf: *mut ::libc::c_void,
        size: usize,
        actual_size: *mut usize,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Create a bind.\n # Arguments\n\n* `bindcontext` - The output bind context.\n * `NetworkNodeID` - This is the NetworkNodeID which this bind can receive data from.\n * `spectator` - False for a regular bind, true for a spectator.\n * `data_channel` - This is an arbitrary value to use for data-frame filtering. This bind will only receive data frames which contain a matching data_channel value, which was specified by udsSendTo(). The data_channel must be non-zero.\n * `recv_buffer_size` - Size of the buffer under sharedmem used for temporarily storing received data-frames which are then loaded by udsPullPacket(). The system requires this to be >=0x5F4. UDS_DEFAULT_RECVBUFSIZE can be used for this."]
    pub fn udsBind(
        bindcontext: *mut udsBindContext,
        NetworkNodeID: u16_,
        spectator: bool,
        data_channel: u8_,
        recv_buffer_size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Remove a bind.\n # Arguments\n\n* `bindcontext` - The bind context."]
    pub fn udsUnbind(bindcontext: *mut udsBindContext) -> Result;
}
unsafe extern "C" {
    #[doc = "Waits for the bind event to occur, or checks if the event was signaled. This event is signaled every time new data is available via udsPullPacket().\n # Returns\n\nAlways true. However if wait=false, this will return false if the event wasn't signaled.\n # Arguments\n\n* `bindcontext` - The bind context.\n * `nextEvent` - Whether to discard the current event and wait for the next event.\n * `wait` - When true this will not return until the event is signaled. When false this checks if the event was signaled without waiting for it."]
    pub fn udsWaitDataAvailable(
        bindcontext: *const udsBindContext,
        nextEvent: bool,
        wait: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Receives data over the network. This data is loaded from the recv_buffer setup by udsBind(). When a node disconnects, this will still return data from that node until there's no more frames from that node in the recv_buffer.\n # Arguments\n\n* `bindcontext` - Bind context.\n * `buf` - Output receive buffer.\n * `size` - Size of the buffer.\n * `actual_size` - If set, the actual size written into the output buffer is stored here. This is zero when no data was received.\n * `src_NetworkNodeID` - If set, the source NetworkNodeID is written here. This is zero when no data was received."]
    pub fn udsPullPacket(
        bindcontext: *const udsBindContext,
        buf: *mut ::libc::c_void,
        size: usize,
        actual_size: *mut usize,
        src_NetworkNodeID: *mut u16_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sends data over the network.\n # Arguments\n\n* `dst_NetworkNodeID` - Destination NetworkNodeID.\n * `data_channel` - See udsBind().\n * `flags` - Send flags, see the UDS_SENDFLAG enum values.\n * `buf` - Input send buffer.\n * `size` - Size of the buffer."]
    pub fn udsSendTo(
        dst_NetworkNodeID: u16_,
        data_channel: u8_,
        flags: u8_,
        buf: *const ::libc::c_void,
        size: usize,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the wifi channel currently being used.\n # Arguments\n\n* `channel` - Output channel."]
    pub fn udsGetChannel(channel: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Starts hosting a new network.\n # Arguments\n\n* `network` - The NetworkStruct, you can use udsGenerateDefaultNetworkStruct() for generating this.\n * `passphrase` - Raw input passphrase buffer.\n * `passphrase_size` - Size of the passphrase buffer.\n * `context` - Optional output bind context which will be created for this host, with NetworkNodeID=UDS_BROADCAST_NETWORKNODEID.\n * `data_channel` - This is the data_channel value which will be passed to udsBind() internally.\n * `recv_buffer_size` - This is the recv_buffer_size value which will be passed to udsBind() internally."]
    pub fn udsCreateNetwork(
        network: *const udsNetworkStruct,
        passphrase: *const ::libc::c_void,
        passphrase_size: usize,
        context: *mut udsBindContext,
        data_channel: u8_,
        recv_buffer_size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Connect to a network.\n # Arguments\n\n* `network` - The NetworkStruct, you can use udsScanBeacons() for this.\n * `passphrase` - Raw input passphrase buffer.\n * `passphrase_size` - Size of the passphrase buffer.\n * `context` - Optional output bind context which will be created for this host.\n * `recv_NetworkNodeID` - This is the NetworkNodeID passed to udsBind() internally.\n * `connection_type` - Type of connection, see the udsConnectionType enum values.\n * `data_channel` - This is the data_channel value which will be passed to udsBind() internally.\n * `recv_buffer_size` - This is the recv_buffer_size value which will be passed to udsBind() internally."]
    pub fn udsConnectNetwork(
        network: *const udsNetworkStruct,
        passphrase: *const ::libc::c_void,
        passphrase_size: usize,
        context: *mut udsBindContext,
        recv_NetworkNodeID: u16_,
        connection_type: udsConnectionType,
        data_channel: u8_,
        recv_buffer_size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Stop hosting the network."]
    pub fn udsDestroyNetwork() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Disconnect this client device from the network."]
    pub fn udsDisconnectNetwork() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This can be used by the host to force-disconnect client(s).\n # Arguments\n\n* `NetworkNodeID` - Target NetworkNodeID. UDS_BROADCAST_NETWORKNODEID can be used to disconnect all clients."]
    pub fn udsEjectClient(NetworkNodeID: u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This can be used by the host to force-disconnect the spectators. Afterwards new spectators will not be allowed to connect until udsAllowSpectators() is used."]
    pub fn udsEjectSpectator() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This can be used by the host to update the network attributes. If bitmask 0x4 is clear in the input bitmask, this clears that bit in the value before actually writing the value into state. Normally you should use the below wrapper functions.\n # Arguments\n\n* `bitmask` - Bitmask to clear/set in the attributes. See the UDSNETATTR enum values.\n * `flag` - When false, bit-clear, otherwise bit-set."]
    pub fn udsUpdateNetworkAttribute(bitmask: u16_, flag: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This uses udsUpdateNetworkAttribute() for (un)blocking new connections to this host.\n # Arguments\n\n* `block` - When true, block the specified connection types(bitmask set). Otherwise allow them(bitmask clear).\n * `clients` - When true, (un)block regular clients.\n * `flag` - When true, update UDSNETATTR_x4. Normally this should be false."]
    pub fn udsSetNewConnectionsBlocked(block: bool, clients: bool, flag: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This uses udsUpdateNetworkAttribute() for unblocking new spectator connections to this host. See udsEjectSpectator() for blocking new spectators."]
    pub fn udsAllowSpectators() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This loads the current ConnectionStatus struct.\n # Arguments\n\n* `output` - Output ConnectionStatus struct."]
    pub fn udsGetConnectionStatus(output: *mut udsConnectionStatus) -> Result;
}
unsafe extern "C" {
    #[doc = "Waits for the ConnectionStatus event to occur, or checks if the event was signaled. This event is signaled when the data from udsGetConnectionStatus() was updated internally.\n # Returns\n\nAlways true. However if wait=false, this will return false if the event wasn't signaled.\n # Arguments\n\n* `nextEvent` - Whether to discard the current event and wait for the next event.\n * `wait` - When true this will not return until the event is signaled. When false this checks if the event was signaled without waiting for it."]
    pub fn udsWaitConnectionStatusEvent(nextEvent: bool, wait: bool) -> bool;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This loads a NodeInfo struct for the specified NetworkNodeID. The broadcast alias can't be used with this.\n # Arguments\n\n* `NetworkNodeID` - Target NetworkNodeID.\n * `output` - Output NodeInfo struct."]
    pub fn udsGetNodeInformation(NetworkNodeID: u16_, output: *mut udsNodeInfo) -> Result;
}
pub const NDM_EXCLUSIVE_STATE_NONE: ndmExclusiveState = 0;
pub const NDM_EXCLUSIVE_STATE_INFRASTRUCTURE: ndmExclusiveState = 1;
pub const NDM_EXCLUSIVE_STATE_LOCAL_COMMUNICATIONS: ndmExclusiveState = 2;
pub const NDM_EXCLUSIVE_STATE_STREETPASS: ndmExclusiveState = 3;
pub const NDM_EXCLUSIVE_STATE_STREETPASS_DATA: ndmExclusiveState = 4;
#[doc = "Exclusive states."]
pub type ndmExclusiveState = ::libc::c_uchar;
pub const NDM_STATE_INITIAL: ndmState = 0;
pub const NDM_STATE_SUSPENDED: ndmState = 1;
pub const NDM_STATE_INFRASTRUCTURE_CONNECTING: ndmState = 2;
pub const NDM_STATE_INFRASTRUCTURE_CONNECTED: ndmState = 3;
pub const NDM_STATE_INFRASTRUCTURE_WORKING: ndmState = 4;
pub const NDM_STATE_INFRASTRUCTURE_SUSPENDING: ndmState = 5;
pub const NDM_STATE_INFRASTRUCTURE_FORCE_SUSPENDING: ndmState = 6;
pub const NDM_STATE_INFRASTRUCTURE_DISCONNECTING: ndmState = 7;
pub const NDM_STATE_INFRASTRUCTURE_FORCE_DISCONNECTING: ndmState = 8;
pub const NDM_STATE_CEC_WORKING: ndmState = 9;
pub const NDM_STATE_CEC_FORCE_SUSPENDING: ndmState = 10;
pub const NDM_STATE_CEC_SUSPENDING: ndmState = 11;
#[doc = "Current states."]
pub type ndmState = ::libc::c_uchar;
pub const NDM_DAEMON_CEC: ndmDaemon = 0;
pub const NDM_DAEMON_BOSS: ndmDaemon = 1;
pub const NDM_DAEMON_NIM: ndmDaemon = 2;
pub const NDM_DAEMON_FRIENDS: ndmDaemon = 3;
pub type ndmDaemon = ::libc::c_uchar;
pub const NDM_DAEMON_MASK_CEC: ndmDaemonMask = 1;
pub const NDM_DAEMON_MASK_BOSS: ndmDaemonMask = 2;
pub const NDM_DAEMON_MASK_NIM: ndmDaemonMask = 4;
pub const NDM_DAEMON_MASK_FRIENDS: ndmDaemonMask = 8;
pub const NDM_DAEMON_MASK_BACKGROUOND: ndmDaemonMask = 7;
pub const NDM_DAEMON_MASK_ALL: ndmDaemonMask = 15;
pub const NDM_DAEMON_MASK_DEFAULT: ndmDaemonMask = 9;
#[doc = "Used to specify multiple daemons."]
pub type ndmDaemonMask = ::libc::c_uchar;
pub const NDM_DAEMON_STATUS_BUSY: ndmDaemonStatus = 0;
pub const NDM_DAEMON_STATUS_IDLE: ndmDaemonStatus = 1;
pub const NDM_DAEMON_STATUS_SUSPENDING: ndmDaemonStatus = 2;
pub const NDM_DAEMON_STATUS_SUSPENDED: ndmDaemonStatus = 3;
pub type ndmDaemonStatus = ::libc::c_uchar;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes ndmu."]
    pub fn ndmuInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits ndmu."]
    pub fn ndmuExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the network daemon to an exclusive state.\n # Arguments\n\n* `state` - State specified in the ndmExclusiveState enumerator."]
    pub fn NDMU_EnterExclusiveState(state: ndmExclusiveState) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Cancels an exclusive state for the network daemon."]
    pub fn NDMU_LeaveExclusiveState() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns the exclusive state for the network daemon.\n # Arguments\n\n* `state` - Pointer to write the exclsuive state to."]
    pub fn NDMU_GetExclusiveState(state: *mut ndmExclusiveState) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Locks the exclusive state."]
    pub fn NDMU_LockState() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unlocks the exclusive state."]
    pub fn NDMU_UnlockState() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Suspends network daemon.\n # Arguments\n\n* `mask` - The specified daemon."]
    pub fn NDMU_SuspendDaemons(mask: ndmDaemonMask) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Resumes network daemon.\n # Arguments\n\n* `mask` - The specified daemon."]
    pub fn NDMU_ResumeDaemons(mask: ndmDaemonMask) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Suspends scheduling for all network daemons.\n # Arguments\n\n* `flag` - 0 = Wait for completion, 1 = Perform in background."]
    pub fn NDMU_SuspendScheduler(flag: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Resumes daemon scheduling."]
    pub fn NDMU_ResumeScheduler() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns the current state for the network daemon.\n # Arguments\n\n* `state` - Pointer to write the current state to."]
    pub fn NDMU_GetCurrentState(state: *mut ndmState) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns a daemon state.\n # Arguments\n\n* `daemon` - The specified daemon.\n * `state` - Pointer to write the daemon state to."]
    pub fn NDMU_QueryStatus(daemon: ndmDaemon, status: *mut ndmDaemonStatus) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the scan interval.\n # Arguments\n\n* `interval` - Value to set the scan interval to."]
    pub fn NDMU_SetScanInterval(interval: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns the scan interval.\n # Arguments\n\n* `interval` - Pointer to write the interval value to."]
    pub fn NDMU_GetScanInterval(interval: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns the retry interval.\n # Arguments\n\n* `interval` - Pointer to write the interval value to."]
    pub fn NDMU_GetRetryInterval(interval: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reverts network daemon to defaults."]
    pub fn NDMU_ResetDaemons() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current default daemon bit mask.\n # Arguments\n\n* `interval` - Pointer to write the default daemon mask value to. The default value is (DAEMONMASK_CEC | DAEMONMASK_FRIENDS)"]
    pub fn NDMU_GetDefaultDaemons(mask: *mut ndmDaemonMask) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Clears half awake mac filter."]
    pub fn NDMU_ClearMacFilter() -> Result;
}
#[doc = "< Initial installation"]
pub const IM_DEFAULT: NIM_InstallationMode = 0;
#[doc = "< Unknown"]
pub const IM_UNKNOWN1: NIM_InstallationMode = 1;
#[doc = "< Unknown"]
pub const IM_UNKNOWN2: NIM_InstallationMode = 2;
#[doc = "< Reinstall currently installed title; use this if the title is already installed (including updates)"]
pub const IM_REINSTALL: NIM_InstallationMode = 3;
#[doc = "Mode that NIM downloads/installs a title with."]
pub type NIM_InstallationMode = ::libc::c_uchar;
#[doc = "< Download not yet initialized"]
pub const DS_NOT_INITIALIZED: NIM_DownloadState = 0;
#[doc = "< Download initialized"]
pub const DS_INITIALIZED: NIM_DownloadState = 1;
#[doc = "< Downloading and installing TMD"]
pub const DS_DOWNLOAD_TMD: NIM_DownloadState = 2;
#[doc = "< Initializing save data"]
pub const DS_PREPARE_SAVE_DATA: NIM_DownloadState = 3;
#[doc = "< Downloading and installing contents"]
pub const DS_DOWNLOAD_CONTENTS: NIM_DownloadState = 4;
#[doc = "< Waiting before calling AM_CommitImportTitles"]
pub const DS_WAIT_COMMIT: NIM_DownloadState = 5;
#[doc = "< Running AM_CommitImportTitles"]
pub const DS_COMMITTING: NIM_DownloadState = 6;
#[doc = "< Title installation finished"]
pub const DS_FINISHED: NIM_DownloadState = 7;
#[doc = "< (unknown error regarding title version)"]
pub const DS_VERSION_ERROR: NIM_DownloadState = 8;
#[doc = "< Creating the .ctx file?"]
pub const DS_CREATE_CONTEXT: NIM_DownloadState = 9;
#[doc = "< Irrecoverable error encountered (e.g. out of space)"]
pub const DS_CANNOT_RECOVER: NIM_DownloadState = 10;
#[doc = "< Invalid state"]
pub const DS_INVALID: NIM_DownloadState = 11;
#[doc = "Current state of a NIM download/installation."]
pub type NIM_DownloadState = ::libc::c_uchar;
#[doc = "Input configuration for NIM download/installation tasks."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NIM_TitleConfig {
    #[doc = "< Title ID"]
    pub titleId: u64_,
    #[doc = "< Title version"]
    pub version: u32_,
    #[doc = "< Always 0"]
    pub unknown_0: u32_,
    #[doc = "< Age for the HOME Menu parental controls"]
    pub ratingAge: u8_,
    #[doc = "< Media type, see FS_MediaType enum"]
    pub mediaType: u8_,
    #[doc = "< Padding"]
    pub padding: [u8_; 2usize],
    #[doc = "< Unknown input, seems to be always 0"]
    pub unknown_1: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NIM_TitleConfig"][::core::mem::size_of::<NIM_TitleConfig>() - 24usize];
    ["Alignment of NIM_TitleConfig"][::core::mem::align_of::<NIM_TitleConfig>() - 8usize];
    ["Offset of field: NIM_TitleConfig::titleId"]
        [::core::mem::offset_of!(NIM_TitleConfig, titleId) - 0usize];
    ["Offset of field: NIM_TitleConfig::version"]
        [::core::mem::offset_of!(NIM_TitleConfig, version) - 8usize];
    ["Offset of field: NIM_TitleConfig::unknown_0"]
        [::core::mem::offset_of!(NIM_TitleConfig, unknown_0) - 12usize];
    ["Offset of field: NIM_TitleConfig::ratingAge"]
        [::core::mem::offset_of!(NIM_TitleConfig, ratingAge) - 16usize];
    ["Offset of field: NIM_TitleConfig::mediaType"]
        [::core::mem::offset_of!(NIM_TitleConfig, mediaType) - 17usize];
    ["Offset of field: NIM_TitleConfig::padding"]
        [::core::mem::offset_of!(NIM_TitleConfig, padding) - 18usize];
    ["Offset of field: NIM_TitleConfig::unknown_1"]
        [::core::mem::offset_of!(NIM_TitleConfig, unknown_1) - 20usize];
};
#[doc = "Output struct for NIM downloads/installations in progress."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NIM_TitleProgress {
    #[doc = "< State, see NIM_DownloadState enum"]
    pub state: u32_,
    #[doc = "< Last result code in NIM"]
    pub lastResult: Result,
    #[doc = "< Amount of bytes that have been downloaded"]
    pub downloadedSize: u64_,
    #[doc = "< Amount of bytes that need to be downloaded in total"]
    pub totalSize: u64_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NIM_TitleProgress"][::core::mem::size_of::<NIM_TitleProgress>() - 24usize];
    ["Alignment of NIM_TitleProgress"][::core::mem::align_of::<NIM_TitleProgress>() - 8usize];
    ["Offset of field: NIM_TitleProgress::state"]
        [::core::mem::offset_of!(NIM_TitleProgress, state) - 0usize];
    ["Offset of field: NIM_TitleProgress::lastResult"]
        [::core::mem::offset_of!(NIM_TitleProgress, lastResult) - 4usize];
    ["Offset of field: NIM_TitleProgress::downloadedSize"]
        [::core::mem::offset_of!(NIM_TitleProgress, downloadedSize) - 8usize];
    ["Offset of field: NIM_TitleProgress::totalSize"]
        [::core::mem::offset_of!(NIM_TitleProgress, totalSize) - 16usize];
};
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes nim:s. This uses networking and is blocking.\n # Arguments\n\n* `buffer` - A buffer for internal use. It must be at least 0x20000 bytes long.\n * `buffer_len` - Length of the passed buffer."]
    pub fn nimsInit(buffer: *mut ::libc::c_void, buffer_len: usize) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes nim:s with the given TIN. This uses networking and is blocking.\n # Arguments\n\n* `buffer` - A buffer for internal use. It must be at least 0x20000 bytes long.\n * `buffer_len` - Length of the passed buffer.\n * `TIN` - The TIN to initialize nim:s with. If you do not know what a TIN is or why you would want to change it, use nimsInit instead."]
    pub fn nimsInitWithTIN(
        buffer: *mut ::libc::c_void,
        buffer_len: usize,
        TIN: *const ::libc::c_char,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Exits nim:s."]
    pub fn nimsExit();
}
unsafe extern "C" {
    #[doc = "Gets the current nim:s session handle."]
    pub fn nimsGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets an attribute.\n # Arguments\n\n* `attr` - Name of the attribute.\n * `val` - Value of the attribute."]
    pub fn NIMS_SetAttribute(attr: *const ::libc::c_char, val: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks if nim wants a system update.\n # Arguments\n\n* `want_update` - Set to true if a system update is required. Can be NULL."]
    pub fn NIMS_WantUpdate(want_update: *mut bool) -> Result;
}
unsafe extern "C" {
    #[doc = "Makes a TitleConfig struct for use with NIMS_RegisterTask, NIMS_StartDownload or NIMS_StartDownloadSimple.\n # Arguments\n\n* `cfg` - Struct to initialize.\n * `titleId` - Title ID to download and install.\n * `version` - Version of the title to download and install.\n * `ratingAge` - Age for which the title is aged; used by parental controls in HOME Menu.\n * `mediaType` - Media type of the title to download and install."]
    pub fn NIMS_MakeTitleConfig(
        cfg: *mut NIM_TitleConfig,
        titleId: u64_,
        version: u32_,
        ratingAge: u8_,
        mediaType: FS_MediaType,
    );
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Registers a background download task with NIM. These are processed in sleep mode only.\n # Arguments\n\n* `cfg` - Title config to use. See NIMS_MakeTitleConfig.\n * `name` - Name of the title in UTF-8. Will be displayed on the HOME Menu. Maximum 73 characters.\n * `maker` - Name of the maker/publisher in UTF-8. Will be displayed on the HOME Menu. Maximum 37 characters."]
    pub fn NIMS_RegisterTask(
        cfg: *const NIM_TitleConfig,
        name: *const ::libc::c_char,
        maker: *const ::libc::c_char,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks whether a background download task for the given title is registered with NIM.\n # Arguments\n\n* `titleId` - Title ID to check for.\n * `registered` - Whether there is a background download task registered."]
    pub fn NIMS_IsTaskRegistered(titleId: u64_, registered: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unregisters a background download task.\n # Arguments\n\n* `titleId` - Title ID whose background download task to cancel."]
    pub fn NIMS_UnregisterTask(titleId: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Starts an active download with NIM. Progress can be checked with NIMS_GetProcess. Do not exit the process while a download is in progress without calling NIMS_CancelDownload.\n # Arguments\n\n* `cfg` - Title config to use. See NIMS_MakeTitleConfig.\n * `mode` - The installation mode to use. See NIM_InstallationMode."]
    pub fn NIMS_StartDownload(cfg: *const NIM_TitleConfig, mode: NIM_InstallationMode) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Starts an active download with NIM with default installation mode; cannot reinstall titles. Progress can be checked with NIMS_GetProcess. Do not exit the process while a download is in progress without calling NIMS_CancelDownload.\n # Arguments\n\n* `cfg` - Title config to use. See NIMS_MakeTitleConfig."]
    pub fn NIMS_StartDownloadSimple(cfg: *const NIM_TitleConfig) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks the status of the current active download.\n # Arguments\n\n* `tp` - Title progress struct to write to. See NIM_TitleProgress."]
    pub fn NIMS_GetProgress(tp: *mut NIM_TitleProgress) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Cancels the current active download with NIM."]
    pub fn NIMS_CancelDownload() -> Result;
}
unsafe extern "C" {
    #[must_use]
    pub fn nwmExtInit() -> Result;
}
unsafe extern "C" {
    pub fn nwmExtExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Turns wireless on or off.\n # Arguments\n\n* `enableWifi` - True enables it, false disables it."]
    pub fn NWMEXT_ControlWirelessEnabled(enableWifi: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes IRU.\n The permissions for the specified memory is set to RO. This memory must be already mapped.\n # Arguments\n\n* `sharedmem_addr` - Address of the shared memory block to use.\n * `sharedmem_size` - Size of the shared memory block."]
    pub fn iruInit(sharedmem_addr: *mut u32_, sharedmem_size: u32_) -> Result;
}
unsafe extern "C" {
    #[doc = "Shuts down IRU."]
    pub fn iruExit();
}
unsafe extern "C" {
    #[doc = "Gets the IRU service handle.\n # Returns\n\nThe IRU service handle."]
    pub fn iruGetServHandle() -> Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sends IR data.\n # Arguments\n\n* `buf` - Buffer to send data from.\n * `size` - Size of the buffer.\n * `wait` - Whether to wait for the data to be sent."]
    pub fn iruSendData(buf: *mut u8_, size: u32_, wait: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Receives IR data.\n # Arguments\n\n* `buf` - Buffer to receive data to.\n * `size` - Size of the buffer.\n * `flag` - Flags to receive data with.\n * `transfercount` - Pointer to output the number of bytes read to.\n * `wait` - Whether to wait for the data to be received."]
    pub fn iruRecvData(
        buf: *mut u8_,
        size: u32_,
        flag: u8_,
        transfercount: *mut u32_,
        wait: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the IR session."]
    pub fn IRU_Initialize() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Shuts down the IR session."]
    pub fn IRU_Shutdown() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Begins sending data.\n # Arguments\n\n* `buf` - Buffer to send.\n * `size` - Size of the buffer."]
    pub fn IRU_StartSendTransfer(buf: *mut u8_, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Waits for a send operation to complete."]
    pub fn IRU_WaitSendTransfer() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Begins receiving data.\n # Arguments\n\n* `size` - Size of the data to receive.\n * `flag` - Flags to use when receiving."]
    pub fn IRU_StartRecvTransfer(size: u32_, flag: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Waits for a receive operation to complete.\n # Arguments\n\n* `transfercount` - Pointer to output the number of bytes read to."]
    pub fn IRU_WaitRecvTransfer(transfercount: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the IR bit rate.\n # Arguments\n\n* `value` - Bit rate to set."]
    pub fn IRU_SetBitRate(value: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the IR bit rate.\n # Arguments\n\n* `out` - Pointer to write the bit rate to."]
    pub fn IRU_GetBitRate(out: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the IR LED state.\n # Arguments\n\n* `value` - IR LED state to set."]
    pub fn IRU_SetIRLEDState(value: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the IR LED state.\n # Arguments\n\n* `out` - Pointer to write the IR LED state to."]
    pub fn IRU_GetIRLEDRecvState(out: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets an event which is signaled once a send finishes.\n # Arguments\n\n* `out` - Pointer to write the event handle to."]
    pub fn IRU_GetSendFinishedEvent(out: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets an event which is signaled once a receive finishes.\n # Arguments\n\n* `out` - Pointer to write the event handle to."]
    pub fn IRU_GetRecvFinishedEvent(out: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes NS."]
    pub fn nsInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits NS."]
    pub fn nsExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Launches a title and the required firmware (only if necessary).\n # Arguments\n\n* `titleid` - ID of the title to launch, 0 for gamecard, JPN System Settings' titleID for System Settings."]
    pub fn NS_LaunchFIRM(titleid: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Launches a title.\n # Arguments\n\n* `titleid` - ID of the title to launch, or 0 for gamecard.\n * `launch_flags` - Flags used when launching the title.\n * `procid` - Pointer to write the process ID of the launched title to."]
    pub fn NS_LaunchTitle(titleid: u64_, launch_flags: u32_, procid: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Terminates the application from which this function is called"]
    pub fn NS_TerminateTitle() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Launches a title and the required firmware.\n # Arguments\n\n* `titleid` - ID of the title to launch, 0 for gamecard.\n * `flags` - Flags for firm-launch. bit0: require an application title-info structure in FIRM paramters to be specified via FIRM parameters. bit1: if clear, NS will check certain Configuration Memory fields."]
    pub fn NS_LaunchApplicationFIRM(titleid: u64_, flags: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reboots to a title.\n # Arguments\n\n* `mediatype` - Mediatype of the title.\n * `titleid` - ID of the title to launch."]
    pub fn NS_RebootToTitle(mediatype: u8_, titleid: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Terminates the process with the specified titleid.\n # Arguments\n\n* `titleid` - ID of the title to terminate.\n * `timeout` - Timeout in nanoseconds. Pass 0 if not required."]
    pub fn NS_TerminateProcessTID(titleid: u64_, timeout: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reboots the system"]
    pub fn NS_RebootSystem() -> Result;
}
pub const PMLAUNCHFLAG_NORMAL_APPLICATION: _bindgen_ty_27 = 1;
pub const PMLAUNCHFLAG_LOAD_DEPENDENCIES: _bindgen_ty_27 = 2;
pub const PMLAUNCHFLAG_NOTIFY_TERMINATION: _bindgen_ty_27 = 4;
pub const PMLAUNCHFLAG_QUEUE_DEBUG_APPLICATION: _bindgen_ty_27 = 8;
pub const PMLAUNCHFLAG_TERMINATION_NOTIFICATION_MASK: _bindgen_ty_27 = 240;
#[doc = "< Forces the usage of the O3DS system mode app memory setting even if N3DS system mode is not \"Legacy\". Dev4 and Dev5 not supported. N3DS only."]
pub const PMLAUNCHFLAG_FORCE_USE_O3DS_APP_MEM: _bindgen_ty_27 = 256;
#[doc = "< In conjunction with the above, forces the 96MB app memory setting. N3DS only."]
pub const PMLAUNCHFLAG_FORCE_USE_O3DS_MAX_APP_MEM: _bindgen_ty_27 = 512;
pub const PMLAUNCHFLAG_USE_UPDATE_TITLE: _bindgen_ty_27 = 65536;
#[doc = "Launch flags for PM launch commands."]
pub type _bindgen_ty_27 = ::libc::c_uint;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes pm:app."]
    pub fn pmAppInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits pm:app."]
    pub fn pmAppExit();
}
unsafe extern "C" {
    #[doc = "Gets the current pm:app session handle.\n # Returns\n\nThe current pm:app session handle."]
    pub fn pmAppGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Launches a title.\n # Arguments\n\n* `programInfo` - Program information of the title.\n * `launchFlags` - Flags to launch the title with."]
    pub fn PMAPP_LaunchTitle(programInfo: *const FS_ProgramInfo, launchFlags: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Launches a title, applying patches.\n # Arguments\n\n* `programInfo` - Program information of the title.\n * `programInfoUpdate` - Program information of the update title.\n * `launchFlags` - Flags to launch the title with."]
    pub fn PMAPP_LaunchTitleUpdate(
        programInfo: *const FS_ProgramInfo,
        programInfoUpdate: *const FS_ProgramInfo,
        launchFlags: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a title's ExHeader Arm11CoreInfo and SystemInfo flags.\n # Arguments\n\n* `outCoreInfo` (direction out) - Pointer to write the ExHeader Arm11CoreInfo to.\n * `outSiFlags` (direction out) - Pointer to write the ExHeader SystemInfo flags to.\n * `programInfo` - Program information of the title."]
    pub fn PMAPP_GetTitleExheaderFlags(
        outCoreInfo: *mut ExHeader_Arm11CoreInfo,
        outSiFlags: *mut ExHeader_SystemInfoFlags,
        programInfo: *const FS_ProgramInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the current FIRM launch parameters.\n # Arguments\n\n* `size` - Size of the FIRM launch parameter buffer.\n * `in` - Buffer to retrieve the launch parameters from."]
    pub fn PMAPP_SetFIRMLaunchParams(size: u32_, in_: *const ::libc::c_void) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current FIRM launch parameters.\n # Arguments\n\n* `size` - Size of the FIRM launch parameter buffer.\n * `out` (direction out) - Buffer to write the launch parameters to."]
    pub fn PMAPP_GetFIRMLaunchParams(out: *mut ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the current FIRM launch parameters.\n # Arguments\n\n* `firmTidLow` - Low Title ID of the FIRM title to launch.\n * `size` - Size of the FIRM launch parameter buffer.\n * `in` - Buffer to retrieve the launch parameters from."]
    pub fn PMAPP_LaunchFIRMSetParams(
        firmTidLow: u32_,
        size: u32_,
        in_: *const ::libc::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Terminate most processes, to prepare for a reboot or a shutdown.\n # Arguments\n\n* `timeout` - Time limit in ns for process termination, after which the remaining processes are killed."]
    pub fn PMAPP_PrepareForReboot(timeout: s64) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Terminates the current Application\n # Arguments\n\n* `timeout` - Timeout in nanoseconds"]
    pub fn PMAPP_TerminateCurrentApplication(timeout: s64) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Terminates the processes having the specified titleId.\n # Arguments\n\n* `titleId` - Title ID of the processes to terminate\n * `timeout` - Timeout in nanoseconds"]
    pub fn PMAPP_TerminateTitle(titleId: u64_, timeout: s64) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Terminates the specified process\n # Arguments\n\n* `pid` - Process-ID of the process to terminate\n * `timeout` - Timeout in nanoseconds"]
    pub fn PMAPP_TerminateProcess(pid: u32_, timeout: s64) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unregisters a process\n # Arguments\n\n* `tid` - TitleID of the process to unregister"]
    pub fn PMAPP_UnregisterProcess(tid: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the APPLICATION cputime reslimit.\n # Arguments\n\n* `cpuTime` - Reslimit value.\n > **Note:** cpuTime can be no higher than reslimitdesc[0] & 0x7F in exheader (or 80 if the latter is 0)."]
    pub fn PMAPP_SetAppResourceLimit(cpuTime: s64) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the APPLICATION cputime reslimit.\n # Arguments\n\n* `cpuTime` (direction out) - Pointer to write the reslimit value to."]
    pub fn PMAPP_GetAppResourceLimit(outCpuTime: *mut s64) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes pm:dbg."]
    pub fn pmDbgInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits pm:dbg."]
    pub fn pmDbgExit();
}
unsafe extern "C" {
    #[doc = "Gets the current pm:dbg session handle.\n # Returns\n\nThe current pm:dbg session handle."]
    pub fn pmDbgGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Enqueues an application for debug after setting cpuTime to 0, and returns a debug handle to it.\n If another process was enqueued, this just calls RunQueuedProcess instead.\n # Arguments\n\n* `Pointer` (direction out) - to output the debug handle to.\n * `programInfo` - Program information of the title.\n * `launchFlags` - Flags to launch the title with."]
    pub fn PMDBG_LaunchAppDebug(
        outDebug: *mut Handle,
        programInfo: *const FS_ProgramInfo,
        launchFlags: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Launches an application for debug after setting cpuTime to 0.\n # Arguments\n\n* `programInfo` - Program information of the title.\n * `launchFlags` - Flags to launch the title with."]
    pub fn PMDBG_LaunchApp(programInfo: *const FS_ProgramInfo, launchFlags: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Runs the queued process and returns a debug handle to it.\n # Arguments\n\n* `Pointer` (direction out) - to output the debug handle to."]
    pub fn PMDBG_RunQueuedProcess(outDebug: *mut Handle) -> Result;
}
#[doc = "< CBC encryption."]
pub const PS_ALGORITHM_CBC_ENC: PS_AESAlgorithm = 0;
#[doc = "< CBC decryption."]
pub const PS_ALGORITHM_CBC_DEC: PS_AESAlgorithm = 1;
#[doc = "< CTR encryption."]
pub const PS_ALGORITHM_CTR_ENC: PS_AESAlgorithm = 2;
#[doc = "< CTR decryption(same as PS_ALGORITHM_CTR_ENC)."]
pub const PS_ALGORITHM_CTR_DEC: PS_AESAlgorithm = 3;
#[doc = "< CCM encryption."]
pub const PS_ALGORITHM_CCM_ENC: PS_AESAlgorithm = 4;
#[doc = "< CCM decryption."]
pub const PS_ALGORITHM_CCM_DEC: PS_AESAlgorithm = 5;
#[doc = "PS AES algorithms."]
pub type PS_AESAlgorithm = ::libc::c_uchar;
#[doc = "< Key slot 0x0D."]
pub const PS_KEYSLOT_0D: PS_AESKeyType = 0;
#[doc = "< Key slot 0x2D."]
pub const PS_KEYSLOT_2D: PS_AESKeyType = 1;
#[doc = "< Key slot 0x31."]
pub const PS_KEYSLOT_31: PS_AESKeyType = 2;
#[doc = "< Key slot 0x38."]
pub const PS_KEYSLOT_38: PS_AESKeyType = 3;
#[doc = "< Key slot 0x32."]
pub const PS_KEYSLOT_32: PS_AESKeyType = 4;
#[doc = "< Key slot 0x39. (DLP)"]
pub const PS_KEYSLOT_39_DLP: PS_AESKeyType = 5;
#[doc = "< Key slot 0x2E."]
pub const PS_KEYSLOT_2E: PS_AESKeyType = 6;
#[doc = "< Invalid key slot."]
pub const PS_KEYSLOT_INVALID: PS_AESKeyType = 7;
#[doc = "< Key slot 0x36."]
pub const PS_KEYSLOT_36: PS_AESKeyType = 8;
#[doc = "< Key slot 0x39. (NFC)"]
pub const PS_KEYSLOT_39_NFC: PS_AESKeyType = 9;
#[doc = "PS key slots."]
pub type PS_AESKeyType = ::libc::c_uchar;
#[doc = "RSA context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psRSAContext {
    pub modulo: [u8_; 256usize],
    pub exponent: [u8_; 256usize],
    pub rsa_bitsize: u32_,
    pub unk: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of psRSAContext"][::core::mem::size_of::<psRSAContext>() - 520usize];
    ["Alignment of psRSAContext"][::core::mem::align_of::<psRSAContext>() - 4usize];
    ["Offset of field: psRSAContext::modulo"]
        [::core::mem::offset_of!(psRSAContext, modulo) - 0usize];
    ["Offset of field: psRSAContext::exponent"]
        [::core::mem::offset_of!(psRSAContext, exponent) - 256usize];
    ["Offset of field: psRSAContext::rsa_bitsize"]
        [::core::mem::offset_of!(psRSAContext, rsa_bitsize) - 512usize];
    ["Offset of field: psRSAContext::unk"][::core::mem::offset_of!(psRSAContext, unk) - 516usize];
};
impl Default for psRSAContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes PS."]
    pub fn psInit() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes PS with the specified session handle.\n # Arguments\n\n* `handle` - Session handle."]
    pub fn psInitHandle(handle: Handle) -> Result;
}
unsafe extern "C" {
    #[doc = "Exits PS."]
    pub fn psExit();
}
unsafe extern "C" {
    #[doc = "Returns the PS session handle."]
    pub fn psGetSessionHandle() -> Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Signs a RSA signature.\n # Arguments\n\n* `hash` - SHA256 hash to sign.\n * `ctx` - RSA context.\n * `signature` - RSA signature."]
    pub fn PS_SignRsaSha256(hash: *mut u8_, ctx: *mut psRSAContext, signature: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Verifies a RSA signature.\n # Arguments\n\n* `hash` - SHA256 hash to compare with.\n * `ctx` - RSA context.\n * `signature` - RSA signature."]
    pub fn PS_VerifyRsaSha256(
        hash: *mut u8_,
        ctx: *mut psRSAContext,
        signature: *mut u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Encrypts/Decrypts AES data. Does not support AES CCM.\n # Arguments\n\n* `size` - Size of the data.\n * `in` - Input buffer.\n * `out` - Output buffer.\n * `aes_algo` - AES algorithm to use.\n * `key_type` - Key type to use.\n * `iv` - Pointer to the CTR/IV. The output CTR/IV is also written here."]
    pub fn PS_EncryptDecryptAes(
        size: u32_,
        in_: *mut u8_,
        out: *mut u8_,
        aes_algo: PS_AESAlgorithm,
        key_type: PS_AESKeyType,
        iv: *mut u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Encrypts/Decrypts signed AES CCM data.\n When decrypting, if the MAC is invalid, 0xC9010401 is returned. After encrypting the MAC is located at inputbufptr.\n # Arguments\n\n* `in` - Input buffer.\n * `in_size` - Size of the input buffer. Must include MAC size when decrypting.\n * `out` - Output buffer.\n * `out_size` - Size of the output buffer. Must include MAC size when encrypting.\n * `data_len` - Length of the data to be encrypted/decrypted.\n * `mac_data_len` - Length of the MAC data.\n * `mac_len` - Length of the MAC.\n * `aes_algo` - AES algorithm to use.\n * `key_type` - Key type to use.\n * `nonce` - Pointer to the nonce."]
    pub fn PS_EncryptSignDecryptVerifyAesCcm(
        in_: *mut u8_,
        in_size: u32_,
        out: *mut u8_,
        out_size: u32_,
        data_len: u32_,
        mac_data_len: u32_,
        mac_len: u32_,
        aes_algo: PS_AESAlgorithm,
        key_type: PS_AESKeyType,
        nonce: *mut u8_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the 64-bit console friend code seed.\n # Arguments\n\n* `seed` - Pointer to write the friend code seed to."]
    pub fn PS_GetLocalFriendCodeSeed(seed: *mut u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the 32-bit device ID.\n # Arguments\n\n* `device_id` - Pointer to write the device ID to."]
    pub fn PS_GetDeviceId(device_id: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Generates cryptographically secure random bytes.\n # Arguments\n\n* `out` - Pointer to the buffer to write the bytes to.\n * `len` - Number of bytes to write."]
    pub fn PS_GenerateRandomBytes(out: *mut ::libc::c_void, len: usize) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes PTMU."]
    pub fn ptmuInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits PTMU."]
    pub fn ptmuExit();
}
unsafe extern "C" {
    #[doc = "Gets a pointer to the current ptm:u session handle.\n # Returns\n\nA pointer to the current ptm:u session handle."]
    pub fn ptmuGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the system's current shell state.\n # Arguments\n\n* `out` - Pointer to write the current shell state to. (0 = closed, 1 = open)"]
    pub fn PTMU_GetShellState(out: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the system's current battery level.\n # Arguments\n\n* `out` - Pointer to write the current battery level to. (0-5)"]
    pub fn PTMU_GetBatteryLevel(out: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the system's current battery charge state.\n # Arguments\n\n* `out` - Pointer to write the current battery charge state to. (0 = not charging, 1 = charging)"]
    pub fn PTMU_GetBatteryChargeState(out: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the system's current pedometer state.\n # Arguments\n\n* `out` - Pointer to write the current pedometer state to. (0 = not counting, 1 = counting)"]
    pub fn PTMU_GetPedometerState(out: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the system's step count history.\n # Arguments\n\n* `hours` - Number of hours to get the step count history for.\n * `stepValue` - Pointer to output the step count history to. (The buffer size must be at least `hours` in length)"]
    pub fn PTMU_GetStepHistory(hours: u32_, stepValue: *mut u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the pedometer's total step count.\n # Arguments\n\n* `steps` - Pointer to write the total step count to."]
    pub fn PTMU_GetTotalStepCount(steps: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether the adapter is plugged in or not\n # Arguments\n\n* `out` - Pointer to write the adapter state to."]
    pub fn PTMU_GetAdapterState(out: *mut bool) -> Result;
}
#[doc = "PDN wake events and MCU interrupts to select, combined with those of other processes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PtmWakeEvents {
    #[doc = "< Written to PDN_WAKE_EVENTS. Don't select bit26 (MCU), PTM will do it automatically."]
    pub pdn_wake_events: u32_,
    #[doc = "< MCU interrupts to check when a MCU wake event happens."]
    pub mcu_interupt_mask: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PtmWakeEvents"][::core::mem::size_of::<PtmWakeEvents>() - 8usize];
    ["Alignment of PtmWakeEvents"][::core::mem::align_of::<PtmWakeEvents>() - 4usize];
    ["Offset of field: PtmWakeEvents::pdn_wake_events"]
        [::core::mem::offset_of!(PtmWakeEvents, pdn_wake_events) - 0usize];
    ["Offset of field: PtmWakeEvents::mcu_interupt_mask"]
        [::core::mem::offset_of!(PtmWakeEvents, mcu_interupt_mask) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PtmSleepConfig {
    #[doc = "< Wake events for which the system should fully wake up."]
    pub exit_sleep_events: PtmWakeEvents,
    #[doc = "< Wake events for which the system should return to sleep."]
    pub continue_sleep_events: PtmWakeEvents,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PtmSleepConfig"][::core::mem::size_of::<PtmSleepConfig>() - 16usize];
    ["Alignment of PtmSleepConfig"][::core::mem::align_of::<PtmSleepConfig>() - 4usize];
    ["Offset of field: PtmSleepConfig::exit_sleep_events"]
        [::core::mem::offset_of!(PtmSleepConfig, exit_sleep_events) - 0usize];
    ["Offset of field: PtmSleepConfig::continue_sleep_events"]
        [::core::mem::offset_of!(PtmSleepConfig, continue_sleep_events) - 8usize];
};
#[doc = "< PTMSYSM_RequestSleep has been called (ack = 3)"]
pub const PTMNOTIFID_SLEEP_REQUESTED: _bindgen_ty_28 = 257;
#[doc = "< The sleep request has been denied by PTMSYSM_ReplyToSleepQuery(true) (no ack required)."]
pub const PTMNOTIFID_SLEEP_DENIED: _bindgen_ty_28 = 258;
#[doc = "< The sleep request has been allowed by PTMSYSM_ReplyToSleepQuery(false) (ack = 1)."]
pub const PTMNOTIFID_SLEEP_ALLOWED: _bindgen_ty_28 = 259;
#[doc = "< All processes not having \"RunnableOnSleep\" have been paused & the system is about to go to sleep (ack = 0)."]
pub const PTMNOTIFID_GOING_TO_SLEEP: _bindgen_ty_28 = 260;
#[doc = "< The system has been woken up, and the paused processes are about to be unpaused (ack = 1)."]
pub const PTMNOTIFID_FULLY_WAKING_UP: _bindgen_ty_28 = 261;
#[doc = "< The system is fully awake (no ack required)."]
pub const PTMNOTIFID_FULLY_AWAKE: _bindgen_ty_28 = 262;
#[doc = "< The system has been woken up but is about to go to sleep again (ack = 2)."]
pub const PTMNOTIFID_HALF_AWAKE: _bindgen_ty_28 = 263;
#[doc = "< The system is about to power off or reboot."]
pub const PTMNOTIFID_SHUTDOWN: _bindgen_ty_28 = 264;
#[doc = "< The battery level has reached 5% or below."]
pub const PTMNOTIFID_BATTERY_VERY_LOW: _bindgen_ty_28 = 529;
#[doc = "< The battery level has reached 10% or below."]
pub const PTMNOTIFID_BATTERY_LOW: _bindgen_ty_28 = 530;
pub type _bindgen_ty_28 = ::libc::c_ushort;
unsafe extern "C" {
    #[doc = "See PTMSYSM_NotifySleepPreparationComplete. Corresponds to the number of potentially remaning notifs. until sleep/wakeup."]
    #[link_name = "ptmSysmGetNotificationAckValue__extern"]
    pub fn ptmSysmGetNotificationAckValue(id: u32_) -> s32;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes ptm:sysm."]
    pub fn ptmSysmInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits ptm:sysm."]
    pub fn ptmSysmExit();
}
unsafe extern "C" {
    #[doc = "Gets a pointer to the current ptm:sysm session handle.\n # Returns\n\nA pointer to the current ptm:sysm session handle."]
    pub fn ptmSysmGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Requests to enter sleep mode."]
    pub fn PTMSYSM_RequestSleep() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Accepts or denies the incoming sleep mode request.\n # Arguments\n\n* `deny` - Whether or not to deny the sleep request.\n > **Note:** If deny = false, this is equivalent to calling PTMSYSM_NotifySleepPreparationComplete(3)"]
    pub fn PTMSYSM_ReplyToSleepQuery(deny: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Acknowledges the current sleep notification and advance the internal sleep mode FSM. All subscribers must reply.\n # Arguments\n\n* `ackValue` - Use ptmSysmGetNotificationAckValue\n > **Note:** PTMNOTIFID_SLEEP_DENIED and PTMNOTIFID_FULLY_AWAKE don't require this."]
    pub fn PTMSYSM_NotifySleepPreparationComplete(ackValue: s32) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the wake events (two sets: when to fully wake up and when to return to sleep).\n # Arguments\n\n* `sleepConfig` - Pointer to the two sets of wake events.\n > **Note:** Can only be called just before acknowledging PTMNOTIFID_GOING_TO_SLEEP or PTMNOTIFID_HALF_AWAKE."]
    pub fn PTMSYSM_SetWakeEvents(sleepConfig: *const PtmSleepConfig) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the wake reason (only the first applicable wake event is taken into account).\n # Arguments\n\n* `sleepConfig` - Pointer to the two sets of wake events. Only the relevant set will be filled."]
    pub fn PTMSYSM_GetWakeReason(outSleepConfig: *mut PtmSleepConfig) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Cancels the \"half-awake\" state and fully wakes up the 3DS after some delay."]
    pub fn PTMSYSM_Awaken() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Clear the \"step history\"."]
    pub fn PTMSYSM_ClearStepHistory() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the system's step count history.\n # Arguments\n\n* `hours` - Number of hours to set the step count history for.\n * `stepValue` - Pointer to read the step count history from. (The buffer size must be at least `hours` in length)"]
    pub fn PTMSYSM_SetStepHistory(hours: u32_, stepValue: *const u16_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Clear the \"play history\"."]
    pub fn PTMSYSM_ClearPlayHistory() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the user time by updating the user time offset.\n # Arguments\n\n* `msY2k` - The number of milliseconds since 01/01/2000."]
    pub fn PTMSYSM_SetUserTime(msY2k: s64) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Invalidates the \"system time\" (cfg block 0x30002)"]
    pub fn PTMSYSM_InvalidateSystemTime() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads the time and date coming from the RTC and converts the result.\n # Arguments\n\n* `outMsY2k` (direction out) - The pointer to write the number of milliseconds since 01/01/2000 to."]
    pub fn PTMSYSM_GetRtcTime(outMsY2k: *mut s64) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes the time and date coming to the RTC, after conversion.\n # Arguments\n\n* `msY2k` - The number of milliseconds since 01/01/2000."]
    pub fn PTMSYSM_SetRtcTime(msY2k: s64) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks whether the system is a New 3DS.\n # Arguments\n\n* `out` (direction out) - Pointer to write the New 3DS flag to."]
    pub fn PTMSYSM_CheckNew3DS(out: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures the New 3DS' CPU clock speed and L2 cache.\n # Arguments\n\n* `value` - Bit0: enable higher clock, Bit1: enable L2 cache."]
    pub fn PTMSYSM_ConfigureNew3DSCPU(value: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Trigger a hardware system shutdown via the MCU.\n # Arguments\n\n* `timeout:` - timeout passed to PMApp:ShutdownAsync (PrepareForReboot)."]
    pub fn PTMSYSM_ShutdownAsync(timeout: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Trigger a hardware system reboot via the MCU.\n # Arguments\n\n* `timeout:` - timeout passed to PMApp:ShutdownAsync (PrepareForReboot)."]
    pub fn PTMSYSM_RebootAsync(timeout: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes PTMGETS."]
    pub fn ptmGetsInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits PTMGETS."]
    pub fn ptmGetsExit();
}
unsafe extern "C" {
    #[doc = "Gets a pointer to the current ptm:gets session handle.\n # Returns\n\nA pointer to the current ptm:gets session handle."]
    pub fn ptmGetsGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the system time.\n # Arguments\n\n* `outMsY2k` (direction out) - The pointer to write the number of milliseconds since 01/01/2000 to."]
    pub fn PTMGETS_GetSystemTime(outMsY2k: *mut s64) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes PTMSETS."]
    pub fn ptmSetsInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits PTMSETS."]
    pub fn ptmSetsExit();
}
unsafe extern "C" {
    #[doc = "Gets a pointer to the current ptm:sets session handle.\n # Returns\n\nA pointer to the current ptm:sets session handle."]
    pub fn ptmSetsGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the system time.\n # Arguments\n\n* `msY2k` - The number of milliseconds since 01/01/2000."]
    pub fn PTMSETS_SetSystemTime(msY2k: s64) -> Result;
}
#[doc = "< Do not wait."]
pub const WAIT_NONE: PXIDEV_WaitType = 0;
#[doc = "< Sleep for the specified number of nanoseconds."]
pub const WAIT_SLEEP: PXIDEV_WaitType = 1;
#[doc = "< Wait for IREQ, return if timeout."]
pub const WAIT_IREQ_RETURN: PXIDEV_WaitType = 2;
#[doc = "< Wait for IREQ, continue if timeout."]
pub const WAIT_IREQ_CONTINUE: PXIDEV_WaitType = 3;
#[doc = "Card SPI wait operation type."]
pub type PXIDEV_WaitType = ::libc::c_uchar;
#[doc = "< Do not deassert."]
pub const DEASSERT_NONE: PXIDEV_DeassertType = 0;
#[doc = "< Deassert before waiting."]
pub const DEASSERT_BEFORE_WAIT: PXIDEV_DeassertType = 1;
#[doc = "< Deassert after waiting."]
pub const DEASSERT_AFTER_WAIT: PXIDEV_DeassertType = 2;
#[doc = "Card SPI register deassertion type."]
pub type PXIDEV_DeassertType = ::libc::c_uchar;
#[doc = "Card SPI transfer buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PXIDEV_SPIBuffer {
    #[doc = "< Data pointer."]
    pub ptr: *mut ::libc::c_void,
    #[doc = "< Data size."]
    pub size: u32_,
    #[doc = "< Transfer options. See pxiDevMakeTransferOption"]
    pub transferOption: u8_,
    #[doc = "< Wait operation. See pxiDevMakeWaitOperation"]
    pub waitOperation: u64_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PXIDEV_SPIBuffer"][::core::mem::size_of::<PXIDEV_SPIBuffer>() - 24usize];
    ["Alignment of PXIDEV_SPIBuffer"][::core::mem::align_of::<PXIDEV_SPIBuffer>() - 8usize];
    ["Offset of field: PXIDEV_SPIBuffer::ptr"]
        [::core::mem::offset_of!(PXIDEV_SPIBuffer, ptr) - 0usize];
    ["Offset of field: PXIDEV_SPIBuffer::size"]
        [::core::mem::offset_of!(PXIDEV_SPIBuffer, size) - 4usize];
    ["Offset of field: PXIDEV_SPIBuffer::transferOption"]
        [::core::mem::offset_of!(PXIDEV_SPIBuffer, transferOption) - 8usize];
    ["Offset of field: PXIDEV_SPIBuffer::waitOperation"]
        [::core::mem::offset_of!(PXIDEV_SPIBuffer, waitOperation) - 16usize];
};
impl Default for PXIDEV_SPIBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes pxi:dev."]
    pub fn pxiDevInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Shuts down pxi:dev."]
    pub fn pxiDevExit();
}
unsafe extern "C" {
    #[doc = "Creates a packed card SPI transfer option value.\n # Arguments\n\n* `baudRate` - Baud rate to use when transferring.\n * `busMode` - Bus mode to use when transferring.\n # Returns\n\nA packed card SPI transfer option value."]
    #[link_name = "pxiDevMakeTransferOption__extern"]
    pub fn pxiDevMakeTransferOption(
        baudRate: FS_CardSpiBaudRate,
        busMode: FS_CardSpiBusMode,
    ) -> u8_;
}
unsafe extern "C" {
    #[doc = "Creates a packed card SPI wait operation value.\n # Arguments\n\n* `waitType` - Type of wait to perform.\n * `deassertType` - Type of register deassertion to perform.\n * `timeout` - Timeout, in nanoseconds, to wait, if applicable.\n # Returns\n\nA packed card SPI wait operation value."]
    #[link_name = "pxiDevMakeWaitOperation__extern"]
    pub fn pxiDevMakeWaitOperation(
        waitType: PXIDEV_WaitType,
        deassertType: PXIDEV_DeassertType,
        timeout: u64_,
    ) -> u64_;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Performs multiple card SPI writes and reads.\n # Arguments\n\n* `header` - Header to lead the transfers with. Must be, at most, 8 bytes in size.\n * `writeBuffer1` - Buffer to make first transfer from.\n * `readBuffer1` - Buffer to receive first response to.\n * `writeBuffer2` - Buffer to make second transfer from.\n * `readBuffer2` - Buffer to receive second response to.\n * `footer` - Footer to follow the transfers with. Must be, at most, 8 bytes in size. Wait operation is unused."]
    pub fn PXIDEV_SPIMultiWriteRead(
        header: *mut PXIDEV_SPIBuffer,
        writeBuffer1: *mut PXIDEV_SPIBuffer,
        readBuffer1: *mut PXIDEV_SPIBuffer,
        writeBuffer2: *mut PXIDEV_SPIBuffer,
        readBuffer2: *mut PXIDEV_SPIBuffer,
        footer: *mut PXIDEV_SPIBuffer,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Performs a single card SPI write and read.\n # Arguments\n\n* `bytesRead` - Pointer to output the number of bytes received to.\n * `initialWaitOperation` - Wait operation to perform before transferring data.\n * `writeBuffer` - Buffer to transfer data from.\n * `readBuffer` - Buffer to receive data to."]
    pub fn PXIDEV_SPIWriteRead(
        bytesRead: *mut u32_,
        initialWaitOperation: u64_,
        writeBuffer: *mut PXIDEV_SPIBuffer,
        readBuffer: *mut PXIDEV_SPIBuffer,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes PxiPM."]
    pub fn pxiPmInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits PxiPM."]
    pub fn pxiPmExit();
}
unsafe extern "C" {
    #[doc = "Gets the current PxiPM session handle.\n # Returns\n\nThe current PxiPM session handle."]
    pub fn pxiPmGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrives the exheader information set(s) (SCI+ACI) about a program.\n # Arguments\n\n* `exheaderInfos[out]` - Pointer to the output exheader information set.\n * `programHandle` - The program handle."]
    pub fn PXIPM_GetProgramInfo(exheaderInfo: *mut ExHeader_Info, programHandle: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Loads a program and registers it to Process9.\n # Arguments\n\n* `programHandle[out]` - Pointer to the output the program handle to.\n * `programInfo` - Information about the program to load.\n * `updateInfo` - Information about the program update to load."]
    pub fn PXIPM_RegisterProgram(
        programHandle: *mut u64_,
        programInfo: *const FS_ProgramInfo,
        updateInfo: *const FS_ProgramInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unloads a program and unregisters it from Process9.\n # Arguments\n\n* `programHandle` - The program handle."]
    pub fn PXIPM_UnregisterProgram(programHandle: u64_) -> Result;
}
#[doc = "< The mac address of the interface (u32 mac[6])"]
pub const NETOPT_MAC_ADDRESS: NetworkOpt = 4100;
#[doc = "< The ARP table [`SOCU_ARPTableEntry`]"]
pub const NETOPT_ARP_TABLE: NetworkOpt = 12290;
#[doc = "< The current IP setup [`SOCU_IPInfo`]"]
pub const NETOPT_IP_INFO: NetworkOpt = 16387;
#[doc = "< The value of the IP MTU (u32)"]
pub const NETOPT_IP_MTU: NetworkOpt = 16388;
#[doc = "< The routing table [`SOCU_RoutingTableEntry`]"]
pub const NETOPT_ROUTING_TABLE: NetworkOpt = 16390;
#[doc = "< The number of sockets in the UDP table (u32)"]
pub const NETOPT_UDP_NUMBER: NetworkOpt = 32770;
#[doc = "< The table of opened UDP sockets [`SOCU_UDPTableEntry`]"]
pub const NETOPT_UDP_TABLE: NetworkOpt = 32771;
#[doc = "< The number of sockets in the TCP table (u32)"]
pub const NETOPT_TCP_NUMBER: NetworkOpt = 36866;
#[doc = "< The table of opened TCP sockets [`SOCU_TCPTableEntry`]"]
pub const NETOPT_TCP_TABLE: NetworkOpt = 36867;
#[doc = "< The table of the DNS servers [`SOCU_DNSTableEntry`] -- Returns a buffer of size 336 but only 2 entries are set ?"]
pub const NETOPT_DNS_TABLE: NetworkOpt = 45059;
#[doc = "< The DHCP lease time remaining, in seconds"]
pub const NETOPT_DHCP_LEASE_TIME: NetworkOpt = 49153;
#[doc = "Options to be used with SOCU_GetNetworkOpt"]
pub type NetworkOpt = ::libc::c_ushort;
#[doc = "One entry of the ARP table retrieved by using SOCU_GetNetworkOpt and NETOPT_ARP_TABLE"]
#[repr(C)]
pub struct SOCU_ARPTableEntry {
    pub unk0: u32_,
    #[doc = "< The IPv4 address associated to the entry"]
    pub ip: in_addr,
    #[doc = "< The MAC address of associated to the entry"]
    pub mac: [u8_; 6usize],
    pub padding: [u8_; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SOCU_ARPTableEntry"][::core::mem::size_of::<SOCU_ARPTableEntry>() - 16usize];
    ["Alignment of SOCU_ARPTableEntry"][::core::mem::align_of::<SOCU_ARPTableEntry>() - 4usize];
    ["Offset of field: SOCU_ARPTableEntry::unk0"]
        [::core::mem::offset_of!(SOCU_ARPTableEntry, unk0) - 0usize];
    ["Offset of field: SOCU_ARPTableEntry::ip"]
        [::core::mem::offset_of!(SOCU_ARPTableEntry, ip) - 4usize];
    ["Offset of field: SOCU_ARPTableEntry::mac"]
        [::core::mem::offset_of!(SOCU_ARPTableEntry, mac) - 8usize];
    ["Offset of field: SOCU_ARPTableEntry::padding"]
        [::core::mem::offset_of!(SOCU_ARPTableEntry, padding) - 14usize];
};
impl Default for SOCU_ARPTableEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Structure returned by SOCU_GetNetworkOpt when using NETOPT_IP_INFO"]
#[repr(C)]
pub struct SOCU_IPInfo {
    #[doc = "< Current IPv4 address"]
    pub ip: in_addr,
    #[doc = "< Current network mask"]
    pub netmask: in_addr,
    #[doc = "< Current network broadcast address"]
    pub broadcast: in_addr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SOCU_IPInfo"][::core::mem::size_of::<SOCU_IPInfo>() - 12usize];
    ["Alignment of SOCU_IPInfo"][::core::mem::align_of::<SOCU_IPInfo>() - 4usize];
    ["Offset of field: SOCU_IPInfo::ip"][::core::mem::offset_of!(SOCU_IPInfo, ip) - 0usize];
    ["Offset of field: SOCU_IPInfo::netmask"]
        [::core::mem::offset_of!(SOCU_IPInfo, netmask) - 4usize];
    ["Offset of field: SOCU_IPInfo::broadcast"]
        [::core::mem::offset_of!(SOCU_IPInfo, broadcast) - 8usize];
};
impl Default for SOCU_IPInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "One entry of the routing table retrieved by using SOCU_GetNetworkOpt and NETOPT_ROUTING_TABLE"]
#[repr(C)]
pub struct SOCU_RoutingTableEntry {
    #[doc = "< Destination IP address of the route"]
    pub dest_ip: in_addr,
    #[doc = "< Mask used for this route"]
    pub netmask: in_addr,
    #[doc = "< Gateway address to reach the network"]
    pub gateway: in_addr,
    #[doc = "< Linux netstat flags [`ROUTING_FLAG_G`]"]
    pub flags: u32_,
    #[doc = "< number of milliseconds since 1st Jan 1900 00:00."]
    pub time: u64_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SOCU_RoutingTableEntry"][::core::mem::size_of::<SOCU_RoutingTableEntry>() - 24usize];
    ["Alignment of SOCU_RoutingTableEntry"]
        [::core::mem::align_of::<SOCU_RoutingTableEntry>() - 8usize];
    ["Offset of field: SOCU_RoutingTableEntry::dest_ip"]
        [::core::mem::offset_of!(SOCU_RoutingTableEntry, dest_ip) - 0usize];
    ["Offset of field: SOCU_RoutingTableEntry::netmask"]
        [::core::mem::offset_of!(SOCU_RoutingTableEntry, netmask) - 4usize];
    ["Offset of field: SOCU_RoutingTableEntry::gateway"]
        [::core::mem::offset_of!(SOCU_RoutingTableEntry, gateway) - 8usize];
    ["Offset of field: SOCU_RoutingTableEntry::flags"]
        [::core::mem::offset_of!(SOCU_RoutingTableEntry, flags) - 12usize];
    ["Offset of field: SOCU_RoutingTableEntry::time"]
        [::core::mem::offset_of!(SOCU_RoutingTableEntry, time) - 16usize];
};
impl Default for SOCU_RoutingTableEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "One entry of the UDP sockets table retrieved by using SOCU_GetNetworkOpt and NETOPT_UDP_TABLE"]
#[repr(C)]
pub struct SOCU_UDPTableEntry {
    #[doc = "< Local address information"]
    pub local: sockaddr_storage,
    #[doc = "< Remote address information"]
    pub remote: sockaddr_storage,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SOCU_UDPTableEntry"][::core::mem::size_of::<SOCU_UDPTableEntry>() - 56usize];
    ["Alignment of SOCU_UDPTableEntry"][::core::mem::align_of::<SOCU_UDPTableEntry>() - 2usize];
    ["Offset of field: SOCU_UDPTableEntry::local"]
        [::core::mem::offset_of!(SOCU_UDPTableEntry, local) - 0usize];
    ["Offset of field: SOCU_UDPTableEntry::remote"]
        [::core::mem::offset_of!(SOCU_UDPTableEntry, remote) - 28usize];
};
impl Default for SOCU_UDPTableEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "One entry of the TCP sockets table retrieved by using SOCU_GetNetworkOpt and NETOPT_TCP_TABLE"]
#[repr(C)]
pub struct SOCU_TCPTableEntry {
    #[doc = "< [`TCP`] states defines"]
    pub state: u32_,
    #[doc = "< Local address information"]
    pub local: sockaddr_storage,
    #[doc = "< Remote address information"]
    pub remote: sockaddr_storage,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SOCU_TCPTableEntry"][::core::mem::size_of::<SOCU_TCPTableEntry>() - 60usize];
    ["Alignment of SOCU_TCPTableEntry"][::core::mem::align_of::<SOCU_TCPTableEntry>() - 4usize];
    ["Offset of field: SOCU_TCPTableEntry::state"]
        [::core::mem::offset_of!(SOCU_TCPTableEntry, state) - 0usize];
    ["Offset of field: SOCU_TCPTableEntry::local"]
        [::core::mem::offset_of!(SOCU_TCPTableEntry, local) - 4usize];
    ["Offset of field: SOCU_TCPTableEntry::remote"]
        [::core::mem::offset_of!(SOCU_TCPTableEntry, remote) - 32usize];
};
impl Default for SOCU_TCPTableEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "One entry of the DNS servers table retrieved by using SOCU_GetNetworkOpt and NETOPT_DNS_TABLE"]
#[repr(C)]
pub struct SOCU_DNSTableEntry {
    pub family: u32_,
    #[doc = "Family of the address of the DNS server"]
    pub ip: in_addr,
    #[doc = "IP of the DNS server"]
    pub padding: [u8_; 12usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SOCU_DNSTableEntry"][::core::mem::size_of::<SOCU_DNSTableEntry>() - 20usize];
    ["Alignment of SOCU_DNSTableEntry"][::core::mem::align_of::<SOCU_DNSTableEntry>() - 4usize];
    ["Offset of field: SOCU_DNSTableEntry::family"]
        [::core::mem::offset_of!(SOCU_DNSTableEntry, family) - 0usize];
    ["Offset of field: SOCU_DNSTableEntry::ip"]
        [::core::mem::offset_of!(SOCU_DNSTableEntry, ip) - 4usize];
    ["Offset of field: SOCU_DNSTableEntry::padding"]
        [::core::mem::offset_of!(SOCU_DNSTableEntry, padding) - 8usize];
};
impl Default for SOCU_DNSTableEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes the SOC service.\n # Arguments\n\n* `context_addr` - Address of a page-aligned (0x1000) buffer to be used.\n * `context_size` - Size of the buffer, a multiple of 0x1000.\n > **Note:** The specified context buffer can no longer be accessed by the process which called this function, since the userland permissions for this block are set to no-access."]
    pub fn socInit(context_addr: *mut u32_, context_size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Closes the soc service.\n > **Note:** You need to call this in order to be able to use the buffer again."]
    pub fn socExit() -> Result;
}
unsafe extern "C" {
    pub fn SOCU_ShutdownSockets() -> ::libc::c_int;
}
unsafe extern "C" {
    pub fn SOCU_CloseSockets() -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Retrieves information from the network configuration. Similar to getsockopt().\n # Arguments\n\n* `level` - Only value allowed seems to be SOL_CONFIG\n * `optname` - The option to be retrieved\n * `optval` - Will contain the output of the command\n * `optlen` - Size of the optval buffer, will be updated to hold the size of the output\n # Returns\n\n0 if successful. -1 if failed, and errno will be set accordingly. Can also return a system error code."]
    pub fn SOCU_GetNetworkOpt(
        level: ::libc::c_int,
        optname: NetworkOpt,
        optval: *mut ::libc::c_void,
        optlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Gets the system's IP address, netmask, and subnet broadcast\n # Returns\n\nerror"]
    pub fn SOCU_GetIPInfo(
        ip: *mut in_addr,
        netmask: *mut in_addr,
        broadcast: *mut in_addr,
    ) -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Adds a global socket.\n # Arguments\n\n* `sockfd` - The socket fd.\n # Returns\n\nerror"]
    pub fn SOCU_AddGlobalSocket(sockfd: ::libc::c_int) -> ::libc::c_int;
}
#[doc = "< Unsigned 8-bit PCM."]
pub const MICU_ENCODING_PCM8: MICU_Encoding = 0;
#[doc = "< Unsigned 16-bit PCM."]
pub const MICU_ENCODING_PCM16: MICU_Encoding = 1;
#[doc = "< Signed 8-bit PCM."]
pub const MICU_ENCODING_PCM8_SIGNED: MICU_Encoding = 2;
#[doc = "< Signed 16-bit PCM."]
pub const MICU_ENCODING_PCM16_SIGNED: MICU_Encoding = 3;
#[doc = "Microphone audio encodings."]
pub type MICU_Encoding = ::libc::c_uchar;
#[doc = "< 32728.498 Hz"]
pub const MICU_SAMPLE_RATE_32730: MICU_SampleRate = 0;
#[doc = "< 16364.479 Hz"]
pub const MICU_SAMPLE_RATE_16360: MICU_SampleRate = 1;
#[doc = "< 10909.499 Hz"]
pub const MICU_SAMPLE_RATE_10910: MICU_SampleRate = 2;
#[doc = "< 8182.1245 Hz"]
pub const MICU_SAMPLE_RATE_8180: MICU_SampleRate = 3;
#[doc = "Microphone audio sampling rates."]
pub type MICU_SampleRate = ::libc::c_uchar;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes MIC.\n # Arguments\n\n* `size` - Shared memory buffer to write audio data to. Must be aligned to 0x1000 bytes.\n * `handle` - Size of the shared memory buffer."]
    pub fn micInit(buffer: *mut u8_, bufferSize: u32_) -> Result;
}
unsafe extern "C" {
    #[doc = "Exits MIC."]
    pub fn micExit();
}
unsafe extern "C" {
    #[doc = "Gets the size of the sample data area within the shared memory buffer.\n # Returns\n\nThe sample data's size."]
    pub fn micGetSampleDataSize() -> u32_;
}
unsafe extern "C" {
    #[doc = "Gets the offset within the shared memory buffer of the last sample written.\n # Returns\n\nThe last sample's offset."]
    pub fn micGetLastSampleOffset() -> u32_;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Maps MIC shared memory.\n # Arguments\n\n* `size` - Size of the shared memory.\n * `handle` - Handle of the shared memory."]
    pub fn MICU_MapSharedMem(size: u32_, handle: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unmaps MIC shared memory."]
    pub fn MICU_UnmapSharedMem() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Begins sampling microphone input.\n # Arguments\n\n* `encoding` - Encoding of outputted audio.\n * `sampleRate` - Sample rate of outputted audio.\n * `sharedMemAudioOffset` - Offset to write audio data to in the shared memory buffer.\n * `sharedMemAudioSize` - Size of audio data to write to the shared memory buffer. This should be at most \"bufferSize - 4\".\n * `loop` - Whether to loop back to the beginning of the buffer when the end is reached."]
    pub fn MICU_StartSampling(
        encoding: MICU_Encoding,
        sampleRate: MICU_SampleRate,
        offset: u32_,
        size: u32_,
        loop_: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adjusts the configuration of the current sampling session.\n # Arguments\n\n* `sampleRate` - Sample rate of outputted audio."]
    pub fn MICU_AdjustSampling(sampleRate: MICU_SampleRate) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Stops sampling microphone input."]
    pub fn MICU_StopSampling() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether microphone input is currently being sampled.\n # Arguments\n\n* `sampling` - Pointer to output the sampling state to."]
    pub fn MICU_IsSampling(sampling: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets an event handle triggered when the shared memory buffer is full.\n # Arguments\n\n* `handle` - Pointer to output the event handle to."]
    pub fn MICU_GetEventHandle(handle: *mut Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the microphone's gain.\n # Arguments\n\n* `gain` - Gain to set."]
    pub fn MICU_SetGain(gain: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the microphone's gain.\n # Arguments\n\n* `gain` - Pointer to output the current gain to."]
    pub fn MICU_GetGain(gain: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets whether the microphone is powered on.\n # Arguments\n\n* `power` - Whether the microphone is powered on."]
    pub fn MICU_SetPower(power: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether the microphone is powered on.\n # Arguments\n\n* `power` - Pointer to output the power state to."]
    pub fn MICU_GetPower(power: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets whether to clamp microphone input.\n # Arguments\n\n* `clamp` - Whether to clamp microphone input."]
    pub fn MICU_SetClamp(clamp: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets whether to clamp microphone input.\n # Arguments\n\n* `clamp` - Pointer to output the clamp state to."]
    pub fn MICU_GetClamp(clamp: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets whether to allow sampling when the shell is closed.\n # Arguments\n\n* `allowShellClosed` - Whether to allow sampling when the shell is closed."]
    pub fn MICU_SetAllowShellClosed(allowShellClosed: bool) -> Result;
}
#[doc = "< Converting color formats."]
pub const MVDMODE_COLORFORMATCONV: MVDSTD_Mode = 0;
#[doc = "< Processing video."]
pub const MVDMODE_VIDEOPROCESSING: MVDSTD_Mode = 1;
#[doc = "Processing mode."]
pub type MVDSTD_Mode = ::libc::c_uchar;
#[doc = "< YUYV422"]
pub const MVD_INPUT_YUYV422: MVDSTD_InputFormat = 65537;
#[doc = "< H264"]
pub const MVD_INPUT_H264: MVDSTD_InputFormat = 131073;
#[doc = "Input format."]
pub type MVDSTD_InputFormat = ::libc::c_uint;
#[doc = "< YUYV422"]
pub const MVD_OUTPUT_YUYV422: MVDSTD_OutputFormat = 65537;
#[doc = "< BGR565"]
pub const MVD_OUTPUT_BGR565: MVDSTD_OutputFormat = 262146;
#[doc = "< RGB565"]
pub const MVD_OUTPUT_RGB565: MVDSTD_OutputFormat = 262148;
#[doc = "Output format."]
pub type MVDSTD_OutputFormat = ::libc::c_uint;
#[doc = "Processing configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_Config {
    #[doc = "< Input type."]
    pub input_type: MVDSTD_InputFormat,
    #[doc = "< Unknown."]
    pub unk_x04: u32_,
    #[doc = "< Unknown. Referred to as \"H264 range\" in SKATER."]
    pub unk_x08: u32_,
    #[doc = "< Input width."]
    pub inwidth: u32_,
    #[doc = "< Input height."]
    pub inheight: u32_,
    #[doc = "< Physical address of color conversion input data."]
    pub physaddr_colorconv_indata: u32_,
    #[doc = "< Physical address used with color conversion."]
    pub physaddr_colorconv_unk0: u32_,
    #[doc = "< Physical address used with color conversion."]
    pub physaddr_colorconv_unk1: u32_,
    #[doc = "< Physical address used with color conversion."]
    pub physaddr_colorconv_unk2: u32_,
    #[doc = "< Physical address used with color conversion."]
    pub physaddr_colorconv_unk3: u32_,
    #[doc = "< Unknown."]
    pub unk_x28: [u32_; 6usize],
    #[doc = "< Enables cropping with the input image when non-zero via the following 4 words."]
    pub enable_cropping: u32_,
    pub input_crop_x_pos: u32_,
    pub input_crop_y_pos: u32_,
    pub input_crop_height: u32_,
    pub input_crop_width: u32_,
    #[doc = "< Unknown."]
    pub unk_x54: u32_,
    #[doc = "< Output type."]
    pub output_type: MVDSTD_OutputFormat,
    #[doc = "< Output width."]
    pub outwidth: u32_,
    #[doc = "< Output height."]
    pub outheight: u32_,
    #[doc = "< Physical address of output data."]
    pub physaddr_outdata0: u32_,
    #[doc = "< Additional physical address for output data, only used when the output format type is value 0x00020001."]
    pub physaddr_outdata1: u32_,
    #[doc = "< Unknown."]
    pub unk_x6c: [u32_; 38usize],
    #[doc = "< This enables using the following 4 words when non-zero."]
    pub flag_x104: u32_,
    #[doc = "< Output X position in the output buffer."]
    pub output_x_pos: u32_,
    #[doc = "< Same as above except for the Y pos."]
    pub output_y_pos: u32_,
    #[doc = "< Used for aligning the output width when larger than the output width. Overrides the output width when smaller than the output width."]
    pub output_width_override: u32_,
    #[doc = "< Same as output_width_override except for the output height."]
    pub output_height_override: u32_,
    pub unk_x118: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MVDSTD_Config"][::core::mem::size_of::<MVDSTD_Config>() - 284usize];
    ["Alignment of MVDSTD_Config"][::core::mem::align_of::<MVDSTD_Config>() - 4usize];
    ["Offset of field: MVDSTD_Config::input_type"]
        [::core::mem::offset_of!(MVDSTD_Config, input_type) - 0usize];
    ["Offset of field: MVDSTD_Config::unk_x04"]
        [::core::mem::offset_of!(MVDSTD_Config, unk_x04) - 4usize];
    ["Offset of field: MVDSTD_Config::unk_x08"]
        [::core::mem::offset_of!(MVDSTD_Config, unk_x08) - 8usize];
    ["Offset of field: MVDSTD_Config::inwidth"]
        [::core::mem::offset_of!(MVDSTD_Config, inwidth) - 12usize];
    ["Offset of field: MVDSTD_Config::inheight"]
        [::core::mem::offset_of!(MVDSTD_Config, inheight) - 16usize];
    ["Offset of field: MVDSTD_Config::physaddr_colorconv_indata"]
        [::core::mem::offset_of!(MVDSTD_Config, physaddr_colorconv_indata) - 20usize];
    ["Offset of field: MVDSTD_Config::physaddr_colorconv_unk0"]
        [::core::mem::offset_of!(MVDSTD_Config, physaddr_colorconv_unk0) - 24usize];
    ["Offset of field: MVDSTD_Config::physaddr_colorconv_unk1"]
        [::core::mem::offset_of!(MVDSTD_Config, physaddr_colorconv_unk1) - 28usize];
    ["Offset of field: MVDSTD_Config::physaddr_colorconv_unk2"]
        [::core::mem::offset_of!(MVDSTD_Config, physaddr_colorconv_unk2) - 32usize];
    ["Offset of field: MVDSTD_Config::physaddr_colorconv_unk3"]
        [::core::mem::offset_of!(MVDSTD_Config, physaddr_colorconv_unk3) - 36usize];
    ["Offset of field: MVDSTD_Config::unk_x28"]
        [::core::mem::offset_of!(MVDSTD_Config, unk_x28) - 40usize];
    ["Offset of field: MVDSTD_Config::enable_cropping"]
        [::core::mem::offset_of!(MVDSTD_Config, enable_cropping) - 64usize];
    ["Offset of field: MVDSTD_Config::input_crop_x_pos"]
        [::core::mem::offset_of!(MVDSTD_Config, input_crop_x_pos) - 68usize];
    ["Offset of field: MVDSTD_Config::input_crop_y_pos"]
        [::core::mem::offset_of!(MVDSTD_Config, input_crop_y_pos) - 72usize];
    ["Offset of field: MVDSTD_Config::input_crop_height"]
        [::core::mem::offset_of!(MVDSTD_Config, input_crop_height) - 76usize];
    ["Offset of field: MVDSTD_Config::input_crop_width"]
        [::core::mem::offset_of!(MVDSTD_Config, input_crop_width) - 80usize];
    ["Offset of field: MVDSTD_Config::unk_x54"]
        [::core::mem::offset_of!(MVDSTD_Config, unk_x54) - 84usize];
    ["Offset of field: MVDSTD_Config::output_type"]
        [::core::mem::offset_of!(MVDSTD_Config, output_type) - 88usize];
    ["Offset of field: MVDSTD_Config::outwidth"]
        [::core::mem::offset_of!(MVDSTD_Config, outwidth) - 92usize];
    ["Offset of field: MVDSTD_Config::outheight"]
        [::core::mem::offset_of!(MVDSTD_Config, outheight) - 96usize];
    ["Offset of field: MVDSTD_Config::physaddr_outdata0"]
        [::core::mem::offset_of!(MVDSTD_Config, physaddr_outdata0) - 100usize];
    ["Offset of field: MVDSTD_Config::physaddr_outdata1"]
        [::core::mem::offset_of!(MVDSTD_Config, physaddr_outdata1) - 104usize];
    ["Offset of field: MVDSTD_Config::unk_x6c"]
        [::core::mem::offset_of!(MVDSTD_Config, unk_x6c) - 108usize];
    ["Offset of field: MVDSTD_Config::flag_x104"]
        [::core::mem::offset_of!(MVDSTD_Config, flag_x104) - 260usize];
    ["Offset of field: MVDSTD_Config::output_x_pos"]
        [::core::mem::offset_of!(MVDSTD_Config, output_x_pos) - 264usize];
    ["Offset of field: MVDSTD_Config::output_y_pos"]
        [::core::mem::offset_of!(MVDSTD_Config, output_y_pos) - 268usize];
    ["Offset of field: MVDSTD_Config::output_width_override"]
        [::core::mem::offset_of!(MVDSTD_Config, output_width_override) - 272usize];
    ["Offset of field: MVDSTD_Config::output_height_override"]
        [::core::mem::offset_of!(MVDSTD_Config, output_height_override) - 276usize];
    ["Offset of field: MVDSTD_Config::unk_x118"]
        [::core::mem::offset_of!(MVDSTD_Config, unk_x118) - 280usize];
};
impl Default for MVDSTD_Config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MVDSTD_ProcessNALUnitOut {
    pub end_vaddr: u32_,
    pub end_physaddr: u32_,
    pub remaining_size: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MVDSTD_ProcessNALUnitOut"]
        [::core::mem::size_of::<MVDSTD_ProcessNALUnitOut>() - 12usize];
    ["Alignment of MVDSTD_ProcessNALUnitOut"]
        [::core::mem::align_of::<MVDSTD_ProcessNALUnitOut>() - 4usize];
    ["Offset of field: MVDSTD_ProcessNALUnitOut::end_vaddr"]
        [::core::mem::offset_of!(MVDSTD_ProcessNALUnitOut, end_vaddr) - 0usize];
    ["Offset of field: MVDSTD_ProcessNALUnitOut::end_physaddr"]
        [::core::mem::offset_of!(MVDSTD_ProcessNALUnitOut, end_physaddr) - 4usize];
    ["Offset of field: MVDSTD_ProcessNALUnitOut::remaining_size"]
        [::core::mem::offset_of!(MVDSTD_ProcessNALUnitOut, remaining_size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_OutputBuffersEntry {
    pub outdata0: *mut ::libc::c_void,
    pub outdata1: *mut ::libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MVDSTD_OutputBuffersEntry"]
        [::core::mem::size_of::<MVDSTD_OutputBuffersEntry>() - 8usize];
    ["Alignment of MVDSTD_OutputBuffersEntry"]
        [::core::mem::align_of::<MVDSTD_OutputBuffersEntry>() - 4usize];
    ["Offset of field: MVDSTD_OutputBuffersEntry::outdata0"]
        [::core::mem::offset_of!(MVDSTD_OutputBuffersEntry, outdata0) - 0usize];
    ["Offset of field: MVDSTD_OutputBuffersEntry::outdata1"]
        [::core::mem::offset_of!(MVDSTD_OutputBuffersEntry, outdata1) - 4usize];
};
impl Default for MVDSTD_OutputBuffersEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_OutputBuffersEntryList {
    pub total_entries: u32_,
    pub entries: [MVDSTD_OutputBuffersEntry; 17usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MVDSTD_OutputBuffersEntryList"]
        [::core::mem::size_of::<MVDSTD_OutputBuffersEntryList>() - 140usize];
    ["Alignment of MVDSTD_OutputBuffersEntryList"]
        [::core::mem::align_of::<MVDSTD_OutputBuffersEntryList>() - 4usize];
    ["Offset of field: MVDSTD_OutputBuffersEntryList::total_entries"]
        [::core::mem::offset_of!(MVDSTD_OutputBuffersEntryList, total_entries) - 0usize];
    ["Offset of field: MVDSTD_OutputBuffersEntryList::entries"]
        [::core::mem::offset_of!(MVDSTD_OutputBuffersEntryList, entries) - 4usize];
};
impl Default for MVDSTD_OutputBuffersEntryList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "This can be used to override the default input values for MVDSTD commands during initialization with video-processing. The default for these fields are all-zero, except for cmd1b_inval which is 1. See also here: https://www.3dbrew.org/wiki/MVD_Services"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MVDSTD_InitStruct {
    pub cmd5_inval0: s8,
    pub cmd5_inval1: s8,
    pub cmd5_inval2: s8,
    pub cmd5_inval3: u32_,
    pub cmd1b_inval: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MVDSTD_InitStruct"][::core::mem::size_of::<MVDSTD_InitStruct>() - 12usize];
    ["Alignment of MVDSTD_InitStruct"][::core::mem::align_of::<MVDSTD_InitStruct>() - 4usize];
    ["Offset of field: MVDSTD_InitStruct::cmd5_inval0"]
        [::core::mem::offset_of!(MVDSTD_InitStruct, cmd5_inval0) - 0usize];
    ["Offset of field: MVDSTD_InitStruct::cmd5_inval1"]
        [::core::mem::offset_of!(MVDSTD_InitStruct, cmd5_inval1) - 1usize];
    ["Offset of field: MVDSTD_InitStruct::cmd5_inval2"]
        [::core::mem::offset_of!(MVDSTD_InitStruct, cmd5_inval2) - 2usize];
    ["Offset of field: MVDSTD_InitStruct::cmd5_inval3"]
        [::core::mem::offset_of!(MVDSTD_InitStruct, cmd5_inval3) - 4usize];
    ["Offset of field: MVDSTD_InitStruct::cmd1b_inval"]
        [::core::mem::offset_of!(MVDSTD_InitStruct, cmd1b_inval) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MVDSTD_WithLevel {
    pub enable: u8_,
    pub flag: u8_,
    pub double_size: u8_,
    pub level: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MVDSTD_WithLevel"][::core::mem::size_of::<MVDSTD_WithLevel>() - 4usize];
    ["Alignment of MVDSTD_WithLevel"][::core::mem::align_of::<MVDSTD_WithLevel>() - 1usize];
    ["Offset of field: MVDSTD_WithLevel::enable"]
        [::core::mem::offset_of!(MVDSTD_WithLevel, enable) - 0usize];
    ["Offset of field: MVDSTD_WithLevel::flag"]
        [::core::mem::offset_of!(MVDSTD_WithLevel, flag) - 1usize];
    ["Offset of field: MVDSTD_WithLevel::double_size"]
        [::core::mem::offset_of!(MVDSTD_WithLevel, double_size) - 2usize];
    ["Offset of field: MVDSTD_WithLevel::level"]
        [::core::mem::offset_of!(MVDSTD_WithLevel, level) - 3usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MVDSTD_WithNumOfRefFrames {
    pub enable: u8_,
    pub ref_frames: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MVDSTD_WithNumOfRefFrames"]
        [::core::mem::size_of::<MVDSTD_WithNumOfRefFrames>() - 2usize];
    ["Alignment of MVDSTD_WithNumOfRefFrames"]
        [::core::mem::align_of::<MVDSTD_WithNumOfRefFrames>() - 1usize];
    ["Offset of field: MVDSTD_WithNumOfRefFrames::enable"]
        [::core::mem::offset_of!(MVDSTD_WithNumOfRefFrames, enable) - 0usize];
    ["Offset of field: MVDSTD_WithNumOfRefFrames::ref_frames"]
        [::core::mem::offset_of!(MVDSTD_WithNumOfRefFrames, ref_frames) - 1usize];
};
#[doc = "H.264 buffer calculation configuration.\n See here for detailed explanations : https://www.3dbrew.org/wiki/MVDSTD:CalculateWorkBufSize."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MVDSTD_CalculateWorkBufSizeConfig {
    pub unused_0x00: u8_,
    pub level: MVDSTD_WithLevel,
    pub ref_frames_a: MVDSTD_WithNumOfRefFrames,
    pub ref_frames_b: MVDSTD_WithNumOfRefFrames,
    pub unused_0x09: [u8_; 3usize],
    pub unk_0x0c: u32_,
    pub unk_0x10: u32_,
    pub unk_0x14: u32_,
    pub unk_0x18: u32_,
    pub unk_0x1c: u32_,
    pub unk_0x20: u32_,
    pub unk_0x24: u32_,
    pub width: u32_,
    pub height: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MVDSTD_CalculateWorkBufSizeConfig"]
        [::core::mem::size_of::<MVDSTD_CalculateWorkBufSizeConfig>() - 48usize];
    ["Alignment of MVDSTD_CalculateWorkBufSizeConfig"]
        [::core::mem::align_of::<MVDSTD_CalculateWorkBufSizeConfig>() - 4usize];
    ["Offset of field: MVDSTD_CalculateWorkBufSizeConfig::unused_0x00"]
        [::core::mem::offset_of!(MVDSTD_CalculateWorkBufSizeConfig, unused_0x00) - 0usize];
    ["Offset of field: MVDSTD_CalculateWorkBufSizeConfig::level"]
        [::core::mem::offset_of!(MVDSTD_CalculateWorkBufSizeConfig, level) - 1usize];
    ["Offset of field: MVDSTD_CalculateWorkBufSizeConfig::ref_frames_a"]
        [::core::mem::offset_of!(MVDSTD_CalculateWorkBufSizeConfig, ref_frames_a) - 5usize];
    ["Offset of field: MVDSTD_CalculateWorkBufSizeConfig::ref_frames_b"]
        [::core::mem::offset_of!(MVDSTD_CalculateWorkBufSizeConfig, ref_frames_b) - 7usize];
    ["Offset of field: MVDSTD_CalculateWorkBufSizeConfig::unused_0x09"]
        [::core::mem::offset_of!(MVDSTD_CalculateWorkBufSizeConfig, unused_0x09) - 9usize];
    ["Offset of field: MVDSTD_CalculateWorkBufSizeConfig::unk_0x0c"]
        [::core::mem::offset_of!(MVDSTD_CalculateWorkBufSizeConfig, unk_0x0c) - 12usize];
    ["Offset of field: MVDSTD_CalculateWorkBufSizeConfig::unk_0x10"]
        [::core::mem::offset_of!(MVDSTD_CalculateWorkBufSizeConfig, unk_0x10) - 16usize];
    ["Offset of field: MVDSTD_CalculateWorkBufSizeConfig::unk_0x14"]
        [::core::mem::offset_of!(MVDSTD_CalculateWorkBufSizeConfig, unk_0x14) - 20usize];
    ["Offset of field: MVDSTD_CalculateWorkBufSizeConfig::unk_0x18"]
        [::core::mem::offset_of!(MVDSTD_CalculateWorkBufSizeConfig, unk_0x18) - 24usize];
    ["Offset of field: MVDSTD_CalculateWorkBufSizeConfig::unk_0x1c"]
        [::core::mem::offset_of!(MVDSTD_CalculateWorkBufSizeConfig, unk_0x1c) - 28usize];
    ["Offset of field: MVDSTD_CalculateWorkBufSizeConfig::unk_0x20"]
        [::core::mem::offset_of!(MVDSTD_CalculateWorkBufSizeConfig, unk_0x20) - 32usize];
    ["Offset of field: MVDSTD_CalculateWorkBufSizeConfig::unk_0x24"]
        [::core::mem::offset_of!(MVDSTD_CalculateWorkBufSizeConfig, unk_0x24) - 36usize];
    ["Offset of field: MVDSTD_CalculateWorkBufSizeConfig::width"]
        [::core::mem::offset_of!(MVDSTD_CalculateWorkBufSizeConfig, width) - 40usize];
    ["Offset of field: MVDSTD_CalculateWorkBufSizeConfig::height"]
        [::core::mem::offset_of!(MVDSTD_CalculateWorkBufSizeConfig, height) - 44usize];
};
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes MVDSTD.\n # Arguments\n\n* `mode` - Mode to initialize MVDSTD to.\n * `input_type` - Type of input to process.\n * `output_type` - Type of output to produce.\n * `size` - Size of the work buffer, MVD_DEFAULT_WORKBUF_SIZE can be used for this. Only used when type == MVDMODE_VIDEOPROCESSING.\n * `initstruct` - Optional MVDSTD_InitStruct, this should be NULL normally."]
    pub fn mvdstdInit(
        mode: MVDSTD_Mode,
        input_type: MVDSTD_InputFormat,
        output_type: MVDSTD_OutputFormat,
        size: u32_,
        initstruct: *mut MVDSTD_InitStruct,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Shuts down MVDSTD."]
    pub fn mvdstdExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Calculate working buffer size for H.264 decoding.\n # Arguments\n\n* `config` - Calculation config, config->level.level must NOT exceed MVD_H264_LEVEL_5_2. See here for more explanations : https://www.3dbrew.org/wiki/MVDSTD:CalculateWorkBufSize.\n * `size_out` - Calculated buffer size in bytes."]
    pub fn mvdstdCalculateBufferSize(
        config: *const MVDSTD_CalculateWorkBufSizeConfig,
        size_out: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Generates a default MVDSTD configuration.\n # Arguments\n\n* `config` - Pointer to output the generated config to.\n * `input_width` - Input width.\n * `input_height` - Input height.\n * `output_width` - Output width.\n * `output_height` - Output height.\n * `vaddr_colorconv_indata` - Virtual address of the color conversion input data.\n * `vaddr_outdata0` - Virtual address of the output data.\n * `vaddr_outdata1` - Additional virtual address for output data, only used when the output format type is value 0x00020001."]
    pub fn mvdstdGenerateDefaultConfig(
        config: *mut MVDSTD_Config,
        input_width: u32_,
        input_height: u32_,
        output_width: u32_,
        output_height: u32_,
        vaddr_colorconv_indata: *mut u32_,
        vaddr_outdata0: *mut u32_,
        vaddr_outdata1: *mut u32_,
    );
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Run color-format-conversion.\n # Arguments\n\n* `config` - Pointer to the configuration to use."]
    pub fn mvdstdConvertImage(config: *mut MVDSTD_Config) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Processes a video frame(specifically a NAL-unit).\n # Arguments\n\n* `inbuf_vaddr` - Input NAL-unit starting with the 3-byte \"00 00 01\" prefix. Must be located in linearmem.\n * `size` - Size of the input buffer.\n * `flag` - See here regarding this input flag: https://www.3dbrew.org/wiki/MVDSTD:ProcessNALUnit\n * `out` - Optional output MVDSTD_ProcessNALUnitOut structure."]
    pub fn mvdstdProcessVideoFrame(
        inbuf_vaddr: *mut ::libc::c_void,
        size: usize,
        flag: u32_,
        out: *mut MVDSTD_ProcessNALUnitOut,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Renders the video frame.\n # Arguments\n\n* `config` - Optional pointer to the configuration to use. When NULL, MVDSTD_SetConfig() should have been used previously for this video.\n * `wait` - When true, wait for rendering to finish. When false, you can manually call this function repeatedly until it stops returning MVD_STATUS_BUSY."]
    pub fn mvdstdRenderVideoFrame(config: *mut MVDSTD_Config, wait: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the current configuration of MVDSTD.\n # Arguments\n\n* `config` - Pointer to the configuration to set."]
    pub fn MVDSTD_SetConfig(config: *mut MVDSTD_Config) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "New3DS Internet Browser doesn't use this. Once done, rendered frames will be written to the output buffers specified by the entrylist instead of the output specified by configuration. See here: https://www.3dbrew.org/wiki/MVDSTD:SetupOutputBuffers\n # Arguments\n\n* `entrylist` - Input entrylist.\n * `bufsize` - Size of each buffer from the entrylist."]
    pub fn mvdstdSetupOutputBuffers(
        entrylist: *mut MVDSTD_OutputBuffersEntryList,
        bufsize: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "New3DS Internet Browser doesn't use this. This overrides the entry0 output buffers originally setup by mvdstdSetupOutputBuffers(). See also here: https://www.3dbrew.org/wiki/MVDSTD:OverrideOutputBuffers\n # Arguments\n\n* `cur_outdata0` - Linearmem vaddr. The current outdata0 for this entry must match this value.\n * `cur_outdata1` - Linearmem vaddr. The current outdata1 for this entry must match this value.\n * `new_outdata0` - Linearmem vaddr. This is the new address to use for outaddr0.\n * `new_outdata1` - Linearmem vaddr. This is the new address to use for outaddr1."]
    pub fn mvdstdOverrideOutputBuffers(
        cur_outdata0: *mut ::libc::c_void,
        cur_outdata1: *mut ::libc::c_void,
        new_outdata0: *mut ::libc::c_void,
        new_outdata1: *mut ::libc::c_void,
    ) -> Result;
}
pub const NFC_OpType_1: NFC_OpType = 1;
#[doc = "Unknown."]
pub const NFC_OpType_NFCTag: NFC_OpType = 2;
#[doc = "This is the default."]
pub const NFC_OpType_RawNFC: NFC_OpType = 3;
#[doc = "NFC operation type."]
pub type NFC_OpType = ::libc::c_uchar;
pub const NFC_TagState_Uninitialized: NFC_TagState = 0;
#[doc = "nfcInit() was not used yet."]
pub const NFC_TagState_ScanningStopped: NFC_TagState = 1;
#[doc = "Not currently scanning for NFC tags. Set by nfcStopScanning() and nfcInit(), when successful."]
pub const NFC_TagState_Scanning: NFC_TagState = 2;
#[doc = "Currently scanning for NFC tags. Set by nfcStartScanning() when successful."]
pub const NFC_TagState_InRange: NFC_TagState = 3;
#[doc = "NFC tag is in range. The state automatically changes to this when the state was previously value 2, without using any NFC service commands."]
pub const NFC_TagState_OutOfRange: NFC_TagState = 4;
#[doc = "NFC tag is now out of range, where the NFC tag was previously in range. This occurs automatically without using any NFC service commands. Once this state is entered, it won't automatically change to anything else when the tag is moved in range again. Hence, if you want to keep doing tag scanning after this, you must stop+start scanning."]
pub const NFC_TagState_DataReady: NFC_TagState = 5;
pub type NFC_TagState = ::libc::c_uchar;
pub const NFC_amiiboFlag_Setup: _bindgen_ty_29 = 16;
#[doc = "This indicates that the amiibo was setup with amiibo Settings. nfcGetAmiiboSettings() will return an all-zero struct when this is not set."]
pub const NFC_amiiboFlag_AppDataSetup: _bindgen_ty_29 = 32;
#[doc = "Bit4-7 are always clear with nfcGetAmiiboSettings() due to \"& 0xF\"."]
pub type _bindgen_ty_29 = ::libc::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_TagInfo {
    pub id_offset_size: u16_,
    #[doc = "\"u16 size/offset of the below ID data. Normally this is 0x7. When this is <=10, this field is the size of the below ID data. When this is >10, this is the offset of the 10-byte ID data, relative to structstart+4+<offsetfield-10>. It's unknown in what cases this 10-byte ID data is used.\""]
    pub unk_x2: u8_,
    pub unk_x3: u8_,
    pub id: [u8_; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NFC_TagInfo"][::core::mem::size_of::<NFC_TagInfo>() - 44usize];
    ["Alignment of NFC_TagInfo"][::core::mem::align_of::<NFC_TagInfo>() - 2usize];
    ["Offset of field: NFC_TagInfo::id_offset_size"]
        [::core::mem::offset_of!(NFC_TagInfo, id_offset_size) - 0usize];
    ["Offset of field: NFC_TagInfo::unk_x2"][::core::mem::offset_of!(NFC_TagInfo, unk_x2) - 2usize];
    ["Offset of field: NFC_TagInfo::unk_x3"][::core::mem::offset_of!(NFC_TagInfo, unk_x3) - 3usize];
    ["Offset of field: NFC_TagInfo::id"][::core::mem::offset_of!(NFC_TagInfo, id) - 4usize];
};
impl Default for NFC_TagInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "AmiiboSettings structure, see also here: https://3dbrew.org/wiki/NFC:GetAmiiboSettings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_AmiiboSettings {
    pub mii: [u8_; 96usize],
    #[doc = "\"Owner Mii.\""]
    pub nickname: [u16_; 11usize],
    #[doc = "\"UTF-16BE Amiibo nickname.\""]
    pub flags: u8_,
    #[doc = "\"This is plaintext_amiibosettingsdata[0] & 0xF.\" See also the NFC_amiiboFlag enums."]
    pub countrycodeid: u8_,
    #[doc = "\"This is plaintext_amiibosettingsdata[1].\" \"Country Code ID, from the system which setup this amiibo.\""]
    pub setupdate_year: u16_,
    pub setupdate_month: u8_,
    pub setupdate_day: u8_,
    pub unk_x7c: [u8_; 44usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NFC_AmiiboSettings"][::core::mem::size_of::<NFC_AmiiboSettings>() - 168usize];
    ["Alignment of NFC_AmiiboSettings"][::core::mem::align_of::<NFC_AmiiboSettings>() - 2usize];
    ["Offset of field: NFC_AmiiboSettings::mii"]
        [::core::mem::offset_of!(NFC_AmiiboSettings, mii) - 0usize];
    ["Offset of field: NFC_AmiiboSettings::nickname"]
        [::core::mem::offset_of!(NFC_AmiiboSettings, nickname) - 96usize];
    ["Offset of field: NFC_AmiiboSettings::flags"]
        [::core::mem::offset_of!(NFC_AmiiboSettings, flags) - 118usize];
    ["Offset of field: NFC_AmiiboSettings::countrycodeid"]
        [::core::mem::offset_of!(NFC_AmiiboSettings, countrycodeid) - 119usize];
    ["Offset of field: NFC_AmiiboSettings::setupdate_year"]
        [::core::mem::offset_of!(NFC_AmiiboSettings, setupdate_year) - 120usize];
    ["Offset of field: NFC_AmiiboSettings::setupdate_month"]
        [::core::mem::offset_of!(NFC_AmiiboSettings, setupdate_month) - 122usize];
    ["Offset of field: NFC_AmiiboSettings::setupdate_day"]
        [::core::mem::offset_of!(NFC_AmiiboSettings, setupdate_day) - 123usize];
    ["Offset of field: NFC_AmiiboSettings::unk_x7c"]
        [::core::mem::offset_of!(NFC_AmiiboSettings, unk_x7c) - 124usize];
};
impl Default for NFC_AmiiboSettings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "AmiiboConfig structure, see also here: https://3dbrew.org/wiki/NFC:GetAmiiboConfig"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_AmiiboConfig {
    pub lastwritedate_year: u16_,
    pub lastwritedate_month: u8_,
    pub lastwritedate_day: u8_,
    pub write_counter: u16_,
    pub characterID: [u8_; 3usize],
    #[doc = "the first element is the collection ID, the second the character in this collection, the third the variant"]
    pub series: u8_,
    #[doc = "ID of the series"]
    pub amiiboID: u16_,
    #[doc = "ID shared by all exact same amiibo. Some amiibo are only distinguished by this one like regular SMB Series Mario and the gold one"]
    pub type_: u8_,
    #[doc = "Type of amiibo 0 = figure, 1 = card, 2 = plush"]
    pub pagex4_byte3: u8_,
    pub appdata_size: u16_,
    #[doc = "\"NFC module writes hard-coded u8 value 0xD8 here. This is the size of the Amiibo AppData, apps can use this with the AppData R/W commands. ...\""]
    pub zeros: [u8_; 48usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NFC_AmiiboConfig"][::core::mem::size_of::<NFC_AmiiboConfig>() - 64usize];
    ["Alignment of NFC_AmiiboConfig"][::core::mem::align_of::<NFC_AmiiboConfig>() - 2usize];
    ["Offset of field: NFC_AmiiboConfig::lastwritedate_year"]
        [::core::mem::offset_of!(NFC_AmiiboConfig, lastwritedate_year) - 0usize];
    ["Offset of field: NFC_AmiiboConfig::lastwritedate_month"]
        [::core::mem::offset_of!(NFC_AmiiboConfig, lastwritedate_month) - 2usize];
    ["Offset of field: NFC_AmiiboConfig::lastwritedate_day"]
        [::core::mem::offset_of!(NFC_AmiiboConfig, lastwritedate_day) - 3usize];
    ["Offset of field: NFC_AmiiboConfig::write_counter"]
        [::core::mem::offset_of!(NFC_AmiiboConfig, write_counter) - 4usize];
    ["Offset of field: NFC_AmiiboConfig::characterID"]
        [::core::mem::offset_of!(NFC_AmiiboConfig, characterID) - 6usize];
    ["Offset of field: NFC_AmiiboConfig::series"]
        [::core::mem::offset_of!(NFC_AmiiboConfig, series) - 9usize];
    ["Offset of field: NFC_AmiiboConfig::amiiboID"]
        [::core::mem::offset_of!(NFC_AmiiboConfig, amiiboID) - 10usize];
    ["Offset of field: NFC_AmiiboConfig::type_"]
        [::core::mem::offset_of!(NFC_AmiiboConfig, type_) - 12usize];
    ["Offset of field: NFC_AmiiboConfig::pagex4_byte3"]
        [::core::mem::offset_of!(NFC_AmiiboConfig, pagex4_byte3) - 13usize];
    ["Offset of field: NFC_AmiiboConfig::appdata_size"]
        [::core::mem::offset_of!(NFC_AmiiboConfig, appdata_size) - 14usize];
    ["Offset of field: NFC_AmiiboConfig::zeros"]
        [::core::mem::offset_of!(NFC_AmiiboConfig, zeros) - 16usize];
};
impl Default for NFC_AmiiboConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Used by nfcInitializeWriteAppData() internally, see also here: https://3dbrew.org/wiki/NFC:GetAppDataInitStruct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_AppDataInitStruct {
    pub data_x0: [u8_; 12usize],
    pub data_xc: [u8_; 48usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NFC_AppDataInitStruct"][::core::mem::size_of::<NFC_AppDataInitStruct>() - 60usize];
    ["Alignment of NFC_AppDataInitStruct"]
        [::core::mem::align_of::<NFC_AppDataInitStruct>() - 1usize];
    ["Offset of field: NFC_AppDataInitStruct::data_x0"]
        [::core::mem::offset_of!(NFC_AppDataInitStruct, data_x0) - 0usize];
    ["Offset of field: NFC_AppDataInitStruct::data_xc"]
        [::core::mem::offset_of!(NFC_AppDataInitStruct, data_xc) - 12usize];
};
impl Default for NFC_AppDataInitStruct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Used by nfcWriteAppData() internally, see also: https://3dbrew.org/wiki/NFC:WriteAppData"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NFC_AppDataWriteStruct {
    pub id: [u8_; 10usize],
    pub id_size: u8_,
    pub unused_xb: [u8_; 21usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NFC_AppDataWriteStruct"][::core::mem::size_of::<NFC_AppDataWriteStruct>() - 32usize];
    ["Alignment of NFC_AppDataWriteStruct"]
        [::core::mem::align_of::<NFC_AppDataWriteStruct>() - 1usize];
    ["Offset of field: NFC_AppDataWriteStruct::id"]
        [::core::mem::offset_of!(NFC_AppDataWriteStruct, id) - 0usize];
    ["Offset of field: NFC_AppDataWriteStruct::id_size"]
        [::core::mem::offset_of!(NFC_AppDataWriteStruct, id_size) - 10usize];
    ["Offset of field: NFC_AppDataWriteStruct::unused_xb"]
        [::core::mem::offset_of!(NFC_AppDataWriteStruct, unused_xb) - 11usize];
};
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes NFC.\n # Arguments\n\n* `type` - See the NFC_OpType enum."]
    pub fn nfcInit(type_: NFC_OpType) -> Result;
}
unsafe extern "C" {
    #[doc = "Shuts down NFC."]
    pub fn nfcExit();
}
unsafe extern "C" {
    #[doc = "Gets the NFC service handle.\n # Returns\n\nThe NFC service handle."]
    pub fn nfcGetSessionHandle() -> Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Starts scanning for NFC tags.\n # Arguments\n\n* `inval` - Unknown. See NFC_STARTSCAN_DEFAULTINPUT."]
    pub fn nfcStartScanning(inval: u16_) -> Result;
}
unsafe extern "C" {
    #[doc = "Stops scanning for NFC tags."]
    pub fn nfcStopScanning();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Read amiibo NFC data and load in memory."]
    pub fn nfcLoadAmiiboData() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "If the tagstate is valid(NFC_TagState_DataReady or 6), it then sets the current tagstate to NFC_TagState_InRange."]
    pub fn nfcResetTagScanState() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This writes the amiibo data stored in memory to the actual amiibo data storage(which is normally the NFC data pages). This can only be used if NFC_LoadAmiiboData() was used previously."]
    pub fn nfcUpdateStoredAmiiboData() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns the current NFC tag state.\n # Arguments\n\n* `state` - Pointer to write NFC tag state."]
    pub fn nfcGetTagState(state: *mut NFC_TagState) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns the current TagInfo.\n # Arguments\n\n* `out` - Pointer to write the output TagInfo."]
    pub fn nfcGetTagInfo(out: *mut NFC_TagInfo) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Opens the appdata, when the amiibo appdata was previously initialized. This must be used before reading/writing the appdata. See also: https://3dbrew.org/wiki/NFC:OpenAppData\n # Arguments\n\n* `amiibo_appid` - Amiibo AppID. See here: https://www.3dbrew.org/wiki/Amiibo"]
    pub fn nfcOpenAppData(amiibo_appid: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This initializes the appdata using the specified input, when the appdata previously wasn't initialized. If the appdata is already initialized, you must first use the amiibo Settings applet menu option labeled \"Delete amiibo Game Data\". This automatically writes the amiibo data into the actual data storage(normally NFC data pages). See also nfcWriteAppData().\n # Arguments\n\n* `amiibo_appid` - amiibo AppID. See also nfcOpenAppData().\n * `buf` - Input buffer.\n * `size` - Buffer size."]
    pub fn nfcInitializeWriteAppData(
        amiibo_appid: u32_,
        buf: *const ::libc::c_void,
        size: usize,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads the appdata. The size must be >=0xD8-bytes, but the actual used size is hard-coded to 0xD8. Note that areas of appdata which were never written to by applications are uninitialized in this output buffer.\n # Arguments\n\n* `buf` - Output buffer.\n * `size` - Buffer size."]
    pub fn nfcReadAppData(buf: *mut ::libc::c_void, size: usize) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes the appdata, after nfcOpenAppData() was used successfully. The size should be <=0xD8-bytes. See also: https://3dbrew.org/wiki/NFC:WriteAppData\n # Arguments\n\n* `buf` - Input buffer.\n * `size` - Buffer size.\n * `taginfo` - TagInfo from nfcGetTagInfo()."]
    pub fn nfcWriteAppData(
        buf: *const ::libc::c_void,
        size: usize,
        taginfo: *mut NFC_TagInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns the current AmiiboSettings.\n # Arguments\n\n* `out` - Pointer to write the output AmiiboSettings."]
    pub fn nfcGetAmiiboSettings(out: *mut NFC_AmiiboSettings) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Returns the current AmiiboConfig.\n # Arguments\n\n* `out` - Pointer to write the output AmiiboConfig."]
    pub fn nfcGetAmiiboConfig(out: *mut NFC_AmiiboConfig) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Starts scanning for NFC tags when initialized with NFC_OpType_RawNFC. See also: https://www.3dbrew.org/wiki/NFC:StartOtherTagScanning\n # Arguments\n\n* `unk0` - Same as nfcStartScanning() input.\n * `unk1` - Unknown."]
    pub fn nfcStartOtherTagScanning(unk0: u16_, unk1: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "This sends a raw NFC command to the tag. This can only be used when initialized with NFC_OpType_RawNFC, and when the TagState is NFC_TagState_InRange. See also: https://www.3dbrew.org/wiki/NFC:SendTagCommand\n # Arguments\n\n* `inbuf` - Input buffer.\n * `insize` - Size of the input buffer.\n * `outbuf` - Output buffer.\n * `outsize` - Size of the output buffer.\n * `actual_transfer_size` - Optional output ptr to write the actual output-size to, can be NULL.\n * `microseconds` - Timing-related field in microseconds."]
    pub fn nfcSendTagCommand(
        inbuf: *const ::libc::c_void,
        insize: usize,
        outbuf: *mut ::libc::c_void,
        outsize: usize,
        actual_transfer_size: *mut usize,
        microseconds: u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unknown. This can only be used when initialized with NFC_OpType_RawNFC, and when the TagState is NFC_TagState_InRange."]
    pub fn nfcCmd21() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unknown. This can only be used when initialized with NFC_OpType_RawNFC, and when the TagState is NFC_TagState_InRange."]
    pub fn nfcCmd22() -> Result;
}
#[doc = "Notification header data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NotificationHeader {
    pub dataSet: bool,
    pub unread: bool,
    pub enableJPEG: bool,
    pub isSpotPass: bool,
    pub isOptedOut: bool,
    pub unkData: [u8_; 3usize],
    pub processID: u64_,
    pub unkData2: [u8_; 8usize],
    pub jumpParam: u64_,
    pub unkData3: [u8_; 8usize],
    pub time: u64_,
    pub title: [u16_; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotificationHeader"][::core::mem::size_of::<NotificationHeader>() - 112usize];
    ["Alignment of NotificationHeader"][::core::mem::align_of::<NotificationHeader>() - 8usize];
    ["Offset of field: NotificationHeader::dataSet"]
        [::core::mem::offset_of!(NotificationHeader, dataSet) - 0usize];
    ["Offset of field: NotificationHeader::unread"]
        [::core::mem::offset_of!(NotificationHeader, unread) - 1usize];
    ["Offset of field: NotificationHeader::enableJPEG"]
        [::core::mem::offset_of!(NotificationHeader, enableJPEG) - 2usize];
    ["Offset of field: NotificationHeader::isSpotPass"]
        [::core::mem::offset_of!(NotificationHeader, isSpotPass) - 3usize];
    ["Offset of field: NotificationHeader::isOptedOut"]
        [::core::mem::offset_of!(NotificationHeader, isOptedOut) - 4usize];
    ["Offset of field: NotificationHeader::unkData"]
        [::core::mem::offset_of!(NotificationHeader, unkData) - 5usize];
    ["Offset of field: NotificationHeader::processID"]
        [::core::mem::offset_of!(NotificationHeader, processID) - 8usize];
    ["Offset of field: NotificationHeader::unkData2"]
        [::core::mem::offset_of!(NotificationHeader, unkData2) - 16usize];
    ["Offset of field: NotificationHeader::jumpParam"]
        [::core::mem::offset_of!(NotificationHeader, jumpParam) - 24usize];
    ["Offset of field: NotificationHeader::unkData3"]
        [::core::mem::offset_of!(NotificationHeader, unkData3) - 32usize];
    ["Offset of field: NotificationHeader::time"]
        [::core::mem::offset_of!(NotificationHeader, time) - 40usize];
    ["Offset of field: NotificationHeader::title"]
        [::core::mem::offset_of!(NotificationHeader, title) - 48usize];
};
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes NEWS."]
    pub fn newsInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits NEWS."]
    pub fn newsExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Adds a notification to the home menu Notifications applet.\n # Arguments\n\n* `title` - UTF-16 title of the notification.\n * `titleLength` - Number of characters in the title, not including the null-terminator.\n * `message` - UTF-16 message of the notification, or NULL for no message.\n * `messageLength` - Number of characters in the message, not including the null-terminator.\n * `image` - Data of the image to show in the notification, or NULL for no image.\n * `imageSize` - Size of the image data in bytes.\n * `jpeg` - Whether the image is a JPEG or not."]
    pub fn NEWS_AddNotification(
        title: *const u16_,
        titleLength: u32_,
        message: *const u16_,
        messageLength: u32_,
        imageData: *const ::libc::c_void,
        imageSize: u32_,
        jpeg: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets current total notifications number.\n # Arguments\n\n* `num` - Pointer where total number will be saved."]
    pub fn NEWS_GetTotalNotifications(num: *mut u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets a custom header for a specific notification.\n # Arguments\n\n* `news_id` - Identification number of the notification.\n * `header` - Pointer to notification header to set."]
    pub fn NEWS_SetNotificationHeader(news_id: u32_, header: *const NotificationHeader) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the header of a specific notification.\n # Arguments\n\n* `news_id` - Identification number of the notification.\n * `header` - Pointer where header of the notification will be saved."]
    pub fn NEWS_GetNotificationHeader(news_id: u32_, header: *mut NotificationHeader) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets a custom message for a specific notification.\n # Arguments\n\n* `news_id` - Identification number of the notification.\n * `message` - Pointer to UTF-16 message to set.\n * `size` - Size of message to set."]
    pub fn NEWS_SetNotificationMessage(news_id: u32_, message: *const u16_, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the message of a specific notification.\n # Arguments\n\n* `news_id` - Identification number of the notification.\n * `message` - Pointer where UTF-16 message of the notification will be saved.\n * `size` - Pointer where size of the message data will be saved in bytes."]
    pub fn NEWS_GetNotificationMessage(
        news_id: u32_,
        message: *mut u16_,
        size: *mut u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets a custom image for a specific notification.\n # Arguments\n\n* `news_id` - Identification number of the notification.\n * `buffer` - Pointer to MPO image to set.\n * `size` - Size of the MPO image to set."]
    pub fn NEWS_SetNotificationImage(
        news_id: u32_,
        buffer: *const ::libc::c_void,
        size: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the image of a specific notification.\n # Arguments\n\n* `news_id` - Identification number of the notification.\n * `buffer` - Pointer where MPO image of the notification will be saved.\n * `size` - Pointer where size of the image data will be saved in bytes."]
    pub fn NEWS_GetNotificationImage(
        news_id: u32_,
        buffer: *mut ::libc::c_void,
        size: *mut u32_,
    ) -> Result;
}
#[doc = "< QTM is fully enabled."]
pub const QTM_STATUS_ENABLED: QtmStatus = 0;
#[doc = "< QTM \"super stable 3D\" feature is disabled. Parallax barrier hardware state is configured to match O3DS."]
pub const QTM_STATUS_SS3D_DISABLED: QtmStatus = 1;
#[doc = "QTM is unavailable: either \"blacklisted\" (usually by NS) for the current title, **or console is a N2DSXL**.\n\n In this state, all QTM functionality is disabled. This includes \"super-stable 3D\"\n (ie. auto barrier adjustment) including `qtm:s` manual barrier position setting functions,\n head tracking, IR LED control and camera luminance reporting (400.0 is returned instead).\n\n > **Note:** `qtm:c` barrier hardware state setting function (blah) bypasses this state.\n > **Note:** Due to an oversight, QTMS_SetQtmStatus allows changing QTM state on N2DSXL. This is not intended\n to be done, and is in fact never done by official software."]
pub const QTM_STATUS_UNAVAILABLE: QtmStatus = 2;
#[doc = "QTM enablement status (when cameras not in use by user), set by `qtm:s`.\n > **Note:** Manual IR LED control, camera lux, and `qtm:c` commands remain available\n for use on N3DS and N3DSXL regardless."]
pub type QtmStatus = ::libc::c_uchar;
#[doc = "QTM status data (fully enabled/SS3D disabled) in `cfg`. Usually all-zero on N2DSXL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QtmStatusCfgData {
    #[doc = "< QTM status at boot (fully enabled or SS3D disabled)."]
    pub defaultStats: QtmStatus,
    #[doc = "\"Global variable\" (.data) section load mode? Unused.\n From CTRAging:\n - 0: \"normal\"\n - 1: \"single reacq\"\n - 2: \"double reacq\"\n- 3/4/5: \"w2w copy 1/10/100\""]
    pub gvLoadMode: u8_,
    #[doc = "< Padding."]
    pub _padding: [u8_; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QtmStatusCfgData"][::core::mem::size_of::<QtmStatusCfgData>() - 4usize];
    ["Alignment of QtmStatusCfgData"][::core::mem::align_of::<QtmStatusCfgData>() - 1usize];
    ["Offset of field: QtmStatusCfgData::defaultStats"]
        [::core::mem::offset_of!(QtmStatusCfgData, defaultStats) - 0usize];
    ["Offset of field: QtmStatusCfgData::gvLoadMode"]
        [::core::mem::offset_of!(QtmStatusCfgData, gvLoadMode) - 1usize];
    ["Offset of field: QtmStatusCfgData::_padding"]
        [::core::mem::offset_of!(QtmStatusCfgData, _padding) - 2usize];
};
impl Default for QtmStatusCfgData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "QTM calibration data (fully enabled/SS3D disabled) in `cfg`. Usually all-zero on N2DSXL."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QtmCalibrationData {
    #[doc = "Neutral (center) barrier position/offset (with slit width of 6 units), when the user is\n facing directly facing the camera, that is to say, their eye midpoint normalized X coord\n in the camera's plane is 0, assuming the user's head is located at the expected viewing distance\n and at the expected eye-to-camera angle (as per the rest of this structure).\n This is expressed in terms of iod/12 units modulo iod/12 (thus, range is 0 to 11 included),\n with IOD (interocular distance) assumed to be 62mm.\n > **Note:** This field is floating-point for QTM auto-adjustment purposes, however the actual barrier\n position in hardware is an integer.\n > **Note:** This is the field that System Settings lets you add -1.0 to +1.0 to.\n > **Note:** Moreover, this field can be directly changed through QTMS_SetCenterBarrierPosition."]
    pub centerBarrierPosition: f32,
    #[doc = "< Lens X coord in inner camera space? Very low value and seems to be unused."]
    pub translationX: f32,
    #[doc = "< Lens Y coord in inner camera space? Very low value and seems to be unused."]
    pub translationY: f32,
    #[doc = "< Optimal eye-to-camera angle, in radians, without accounting for lens distortion."]
    pub rotationZ: f32,
    #[doc = "< Camera's horizontal FoV in degrees, without accounting for lens distortion."]
    pub fovX: f32,
    #[doc = "< Optimal viewing distance between user and top screen, assuming iod to be 62mm."]
    pub viewingDistance: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QtmCalibrationData"][::core::mem::size_of::<QtmCalibrationData>() - 24usize];
    ["Alignment of QtmCalibrationData"][::core::mem::align_of::<QtmCalibrationData>() - 4usize];
    ["Offset of field: QtmCalibrationData::centerBarrierPosition"]
        [::core::mem::offset_of!(QtmCalibrationData, centerBarrierPosition) - 0usize];
    ["Offset of field: QtmCalibrationData::translationX"]
        [::core::mem::offset_of!(QtmCalibrationData, translationX) - 4usize];
    ["Offset of field: QtmCalibrationData::translationY"]
        [::core::mem::offset_of!(QtmCalibrationData, translationY) - 8usize];
    ["Offset of field: QtmCalibrationData::rotationZ"]
        [::core::mem::offset_of!(QtmCalibrationData, rotationZ) - 12usize];
    ["Offset of field: QtmCalibrationData::fovX"]
        [::core::mem::offset_of!(QtmCalibrationData, fovX) - 16usize];
    ["Offset of field: QtmCalibrationData::viewingDistance"]
        [::core::mem::offset_of!(QtmCalibrationData, viewingDistance) - 20usize];
};
#[doc = "< Left eye."]
pub const QTM_EYE_LEFT: QtmEyeSide = 0;
#[doc = "< Right eye."]
pub const QTM_EYE_RIGHT: QtmEyeSide = 1;
#[doc = "< Number of eyes."]
pub const QTM_EYE_NUM: QtmEyeSide = 2;
#[doc = "Left eye or right eye, for QtmTrackingData and QtmRawTrackingData"]
pub type QtmEyeSide = ::libc::c_uchar;
#[doc = "QTM raw eye tracking data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QtmRawTrackingData {
    #[doc = "< Eye position detected or predicted, equals (confidenceLevel > 0)."]
    pub eyesTracked: bool,
    #[doc = "< Padding."]
    pub _padding: [u8_; 3usize],
    #[doc = "< Pointer to eye-tracking singleton pointer, in QTM's .bss, located in N3DS extra memory."]
    pub singletonQtmPtr: u32_,
    #[doc = "< Eye tracking confidence level (0 to 1)."]
    pub confidenceLevel: f32,
    #[doc = "Raw predicted or detected eye coordinates. Each eye is represented as one point.\n Fractional part is *not* necessarily zero.\n > **Note:** X coord is within 0 to 320.\n > **Note:** Y coord is within 0 to 240."]
    pub rawEyeCameraCoordinates: [[f32; 2usize]; 2usize],
    #[doc = "< Difference in gyro pitch from position at console boot."]
    pub dPitch: f32,
    #[doc = "< Difference in gyro yaw from position at console boot."]
    pub dYaw: f32,
    #[doc = "< Difference in gyro roll from position at console boot."]
    pub dRoll: f32,
    #[doc = "< Time point the current measurements were made."]
    pub samplingTick: s64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QtmRawTrackingData"][::core::mem::size_of::<QtmRawTrackingData>() - 48usize];
    ["Alignment of QtmRawTrackingData"][::core::mem::align_of::<QtmRawTrackingData>() - 8usize];
    ["Offset of field: QtmRawTrackingData::eyesTracked"]
        [::core::mem::offset_of!(QtmRawTrackingData, eyesTracked) - 0usize];
    ["Offset of field: QtmRawTrackingData::_padding"]
        [::core::mem::offset_of!(QtmRawTrackingData, _padding) - 1usize];
    ["Offset of field: QtmRawTrackingData::singletonQtmPtr"]
        [::core::mem::offset_of!(QtmRawTrackingData, singletonQtmPtr) - 4usize];
    ["Offset of field: QtmRawTrackingData::confidenceLevel"]
        [::core::mem::offset_of!(QtmRawTrackingData, confidenceLevel) - 8usize];
    ["Offset of field: QtmRawTrackingData::rawEyeCameraCoordinates"]
        [::core::mem::offset_of!(QtmRawTrackingData, rawEyeCameraCoordinates) - 12usize];
    ["Offset of field: QtmRawTrackingData::dPitch"]
        [::core::mem::offset_of!(QtmRawTrackingData, dPitch) - 28usize];
    ["Offset of field: QtmRawTrackingData::dYaw"]
        [::core::mem::offset_of!(QtmRawTrackingData, dYaw) - 32usize];
    ["Offset of field: QtmRawTrackingData::dRoll"]
        [::core::mem::offset_of!(QtmRawTrackingData, dRoll) - 36usize];
    ["Offset of field: QtmRawTrackingData::samplingTick"]
        [::core::mem::offset_of!(QtmRawTrackingData, samplingTick) - 40usize];
};
#[doc = "QTM processed eye tracking data, suitable for 3D programming"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QtmTrackingData {
    #[doc = "< Eye position detected or tracked with some confidence, equals (confidenceLevel > 0). Even if false, QTM may make a guess"]
    pub eyesTracked: bool,
    #[doc = "< Whether or not the entirety of the user's face has been detected with good confidence."]
    pub faceDetected: bool,
    #[doc = "< Whether or not the user's eyes have actually been detected with full confidence."]
    pub eyesDetected: bool,
    #[doc = "< Unused."]
    pub _unused: u8_,
    #[doc = "< Whether or not the normalized eye coordinates have been clamped after accounting for lens distortion."]
    pub clamped: bool,
    #[doc = "< Padding."]
    pub _padding: [u8_; 3usize],
    #[doc = "< Eye tracking confidence level (0 to 1)."]
    pub confidenceLevel: f32,
    #[doc = "Normalized eye coordinates, for each eye, after accounting for lens distortion, centered around camera.\n X coord is in the -1 to 1 range, and Y coord range depends on inverse aspect ratio (-0.75 to 0.75 on real hardware).\n > **Note:** On real hardware, X coord equals `((rawX / 160.0) - 1.00) * 1.0639` before clamping.\n > **Note:** On real hardware, Y coord equals `((rawY / 160.0) - 0.75) * 1.0637` before clamping."]
    pub eyeCameraCoordinates: [[f32; 2usize]; 2usize],
    #[doc = "Normalized eye coordinates, for each eye, in world space.\n Corresponds to eyeCameraCoordinates multiplied by tangent of field of view.\n > **Note:** On real hardware, X coord equals `eyeCameraCoordinates.x * tan(64.9 deg / 2)`.\n > **Note:** On real hardware, Y coord equals `eyeCameraCoordinates.x * tan(51.0 deg / 2)`."]
    pub eyeWorldCoordinates: [[f32; 2usize]; 2usize],
    #[doc = "< Difference in gyro pitch from position at console boot."]
    pub dPitch: f32,
    #[doc = "< Difference in gyro yaw from position at console boot."]
    pub dYaw: f32,
    #[doc = "< Difference in gyro roll from position at console boot."]
    pub dRoll: f32,
    #[doc = "< Time point the current measurements were made."]
    pub samplingTick: s64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QtmTrackingData"][::core::mem::size_of::<QtmTrackingData>() - 64usize];
    ["Alignment of QtmTrackingData"][::core::mem::align_of::<QtmTrackingData>() - 8usize];
    ["Offset of field: QtmTrackingData::eyesTracked"]
        [::core::mem::offset_of!(QtmTrackingData, eyesTracked) - 0usize];
    ["Offset of field: QtmTrackingData::faceDetected"]
        [::core::mem::offset_of!(QtmTrackingData, faceDetected) - 1usize];
    ["Offset of field: QtmTrackingData::eyesDetected"]
        [::core::mem::offset_of!(QtmTrackingData, eyesDetected) - 2usize];
    ["Offset of field: QtmTrackingData::_unused"]
        [::core::mem::offset_of!(QtmTrackingData, _unused) - 3usize];
    ["Offset of field: QtmTrackingData::clamped"]
        [::core::mem::offset_of!(QtmTrackingData, clamped) - 4usize];
    ["Offset of field: QtmTrackingData::_padding"]
        [::core::mem::offset_of!(QtmTrackingData, _padding) - 5usize];
    ["Offset of field: QtmTrackingData::confidenceLevel"]
        [::core::mem::offset_of!(QtmTrackingData, confidenceLevel) - 8usize];
    ["Offset of field: QtmTrackingData::eyeCameraCoordinates"]
        [::core::mem::offset_of!(QtmTrackingData, eyeCameraCoordinates) - 12usize];
    ["Offset of field: QtmTrackingData::eyeWorldCoordinates"]
        [::core::mem::offset_of!(QtmTrackingData, eyeWorldCoordinates) - 28usize];
    ["Offset of field: QtmTrackingData::dPitch"]
        [::core::mem::offset_of!(QtmTrackingData, dPitch) - 44usize];
    ["Offset of field: QtmTrackingData::dYaw"]
        [::core::mem::offset_of!(QtmTrackingData, dYaw) - 48usize];
    ["Offset of field: QtmTrackingData::dRoll"]
        [::core::mem::offset_of!(QtmTrackingData, dRoll) - 52usize];
    ["Offset of field: QtmTrackingData::samplingTick"]
        [::core::mem::offset_of!(QtmTrackingData, samplingTick) - 56usize];
};
#[doc = "`qtm:u`: has eye-tracking commands and IR LED control commands, but for some\n reason cannot fetch ambiant lux data from the camera's luminosity sensor."]
pub const QTM_SERVICE_USER: QtmServiceName = 0;
#[doc = "`qtm:s`: has access to all `qtm:u` commands, plus luminosity sensor, plus\n manual barrier position setting and calibration adjustment commands.\n Automatic barrier control is reenabled on session exit."]
pub const QTM_SERVICE_SYSTEM: QtmServiceName = 1;
#[doc = "`qtm:sp`: has access to all `qtm:s` (and `qtm:u`) commands, and merely has a\n few more commands that GSP uses to notify QTM of 2D<>3D mode switches and\n power events. Automatic barrier control is reenabled on session exit.\n GSP always keeps a `qtm:sp` sessions open (at least on latest system version),\n whereas NS opens then immediately closes a `qtm:sp` sessions only when dealing\n with a \"blacklisted\" application (that is, almost never)."]
pub const QTM_SERVICE_SYSTEM_PROCESS: QtmServiceName = 2;
#[doc = "QTM service name enum, excluding `qtm:c`"]
pub type QtmServiceName = ::libc::c_uchar;
unsafe extern "C" {
    #[doc = "Check whether or not QTM services are registered.\n # Returns\n\nTrue on O3DS systems, false on N3DS systems."]
    pub fn qtmCheckServicesRegistered() -> bool;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes QTM (except `qtm:c`).\n Excluding `qtm:c`, QTM has three main services.\n Only 3 sessions (2 until 9.3.0 sysupdate) for ALL services COMBINED, including `qtm:c`,\n can be open at a time.\n Refer to QtmServiceName enum value descriptions to see which service to choose.\n\n # Arguments\n\n* `serviceName` - QTM service name enum value (corresponding to `qtm:u`, `qtm:s` and `qtm:sp`\n respectively).\n > **Note:** Result of qtmCheckServicesRegistered should be checked before calling this function."]
    pub fn qtmInit(serviceName: QtmServiceName) -> Result;
}
unsafe extern "C" {
    #[doc = "Exits QTM."]
    pub fn qtmExit();
}
unsafe extern "C" {
    #[doc = "Checks whether or not a `qtm:u`, `qtm:s` or `qtm:sp` session is active."]
    pub fn qtmIsInitialized() -> bool;
}
unsafe extern "C" {
    #[doc = "Returns a pointer to the current `qtm:u` / `qtm:s` / `qtm:sp` session handle."]
    pub fn qtmGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current raw eye tracking data, with an optional prediction made for predictionTimePointOrZero = t+dt,\n or for the current time point (QTM makes predictions based on gyro data since inner camera runs at 30 FPS).\n\n # Arguments\n\n* `outData` (direction out) - Where to write the raw tracking data to. Cleared to all-zero on failure (instead of being left uninitialized).\n * `predictionTimePointOrZero` - Either zero, or the time point (in system ticks) for which to make a prediction for.\n Maximum 1 frame (at 30 FPS) in the past, and up to 5 frames in the future.\n # Returns\n\n`0xC8A18008` if camera is in use by user, or `0xC8A183EF` if QTM is unavailable (in particular, QTM is always\n unavailable on N2DSXL), Otherwise, 0 (success). Return value should be checked by caller.\n > **Note:** Consider using QTMU_GetTrackingDataEx instead."]
    pub fn QTMU_GetRawTrackingDataEx(
        outData: *mut QtmRawTrackingData,
        predictionTimePointOrZero: s64,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current raw eye tracking data.\n\n # Arguments\n\n* `outData` (direction out) - Where to write the raw tracking data to. Cleared to all-zero on failure (instead of being left uninitialized).\n # Returns\n\n`0xC8A18008` if camera is in use by user, or `0xC8A183EF` if QTM is unavailable (in particular, QTM is always\n unavailable on N2DSXL), Otherwise, 0 (success). Return value should be checked by caller.\n > **Note:** Consider using QTMU_GetTrackingData instead."]
    #[link_name = "QTMU_GetRawTrackingData__extern"]
    pub fn QTMU_GetRawTrackingData(outData: *mut QtmRawTrackingData) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current normalized eye tracking data, made suitable for 3D programming with an optional prediction made\n for predictionTimePointOrZero = t+dt, or for the current time point (QTM makes predictions based on gyro data since\n inner camera runs at 30 FPS).\n\n # Arguments\n\n* `outData` (direction out) - Where to write the raw tracking data to. Cleared to all-zero on failure (instead of being left uninitialized).\n * `predictionTimePointOrZero` - Either zero, or the time point (in system ticks) for which to make a prediction for.\n Maximum 1 frame (at 30 FPS) in the past, and up to 5 frames in the future.\n # Returns\n\n`0xC8A18008` if camera is in use by user, or `0xC8A183EF` if QTM is unavailable (in particular, QTM is always\n unavailable on N2DSXL). Otherwise, 0 (success). Return value should be checked by caller.\n > **Note:** This can, for example, be used in games to allow the user to control the scene's camera with their own face."]
    pub fn QTMU_GetTrackingDataEx(
        outData: *mut QtmTrackingData,
        predictionTimePointOrZero: s64,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current normalized eye tracking data, made suitable for 3D programming.\n\n # Arguments\n\n* `outData` (direction out) - Where to write the raw tracking data to. Cleared to all-zero on failure (instead of being left uninitialized).\n # Returns\n\n`0xC8A18008` if camera is in use by user, or `0xC8A183EF` if QTM is unavailable (in particular, QTM is always\n unavailable on N2DSXL). Otherwise, 0 (success). Return value should be checked by caller.\n > **Note:** This can, for example, be used in games to allow the user to control the scene's camera with their own face."]
    #[link_name = "QTMU_GetTrackingData__extern"]
    pub fn QTMU_GetTrackingData(outData: *mut QtmTrackingData) -> Result;
}
unsafe extern "C" {
    #[doc = "Computes an approximation of the horizontal angular field of view of the camera based on eye tracking data.\n\n # Arguments\n\n* `data` - Eye tracking data, obtained from QTMU_GetTrackingData or QTMU_GetTrackingDataEx.\n # Returns\n\nHorizontal angular field of view in radians. Corresponds to 64.9 degrees on real hardware."]
    pub fn qtmComputeFovX(data: *const QtmTrackingData) -> f32;
}
unsafe extern "C" {
    #[doc = "Computes an approximation of the vertical angular field of view of the camera based on eye tracking data.\n\n # Arguments\n\n* `data` - Eye tracking data, obtained from QTMU_GetTrackingData or QTMU_GetTrackingDataEx.\n # Returns\n\nVertical angular field of view in radians. Corresponds to 51.0 degrees on real hardware."]
    pub fn qtmComputeFovY(data: *const QtmTrackingData) -> f32;
}
unsafe extern "C" {
    #[doc = "Computes a rough approximation of the inverse of the aspect ration of the camera based on eye tracking data.\n\n # Arguments\n\n* `data` - Eye tracking data, obtained from QTMU_GetTrackingData or QTMU_GetTrackingDataEx.\n # Returns\n\nRough approximation of the inverse of the aspect ratio of the camera. Aspect ratio is exactly 0.75 on real hardware."]
    pub fn qtmComputeInverseAspectRatio(data: *const QtmTrackingData) -> f32;
}
unsafe extern "C" {
    #[doc = "Computes the user's head tilt angle, that is, the angle between the line through both eyes and the camera's\n horizontal axis in camera space.\n\n # Arguments\n\n* `data` - Eye tracking data, obtained from QTMU_GetTrackingData or QTMU_GetTrackingDataEx.\n # Returns\n\nHorizontal head angle relative to camera, in radians."]
    pub fn qtmComputeHeadTiltAngle(data: *const QtmTrackingData) -> f32;
}
unsafe extern "C" {
    #[doc = "Estimates the distance between the user's eyes and the camera, based on\n eye tracking data. This may be a little bit inaccurate, as this assumes\n interocular distance of 62mm (like all 3DS software does), and that both\n eyes are at the same distance from the screen.\n\n # Arguments\n\n* `data` - Eye tracking data, obtained from QTMU_GetTrackingData or QTMU_GetTrackingDataEx.\n # Returns\n\nEye-to-camera distance in millimeters."]
    pub fn qtmEstimateEyeToCameraDistance(data: *const QtmTrackingData) -> f32;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Temporarily enables manual control of the IR LED by user, disabling its automatic control.\n If not already done, this also turns off the IR LED. This setting is cleared when user closes the console's shell.\n # Returns\n\nAlways 0 (success)."]
    pub fn QTMU_EnableManualIrLedControl() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Temporarily disables manual control of the IR LED by user, re-enabling its automatic control.\n If not already done, this also turns off the IR LED.\n # Returns\n\nAlways 0 (success)."]
    pub fn QTMU_DisableManualIrLedControl() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Turns the IR LED on or off during manual control. QTMU_EnableManualIrLedControl must have been called.\n\n # Arguments\n\n* `on` - Whether to turn the IR LED on or off.\n # Returns\n\n`0xC8A18005` if manual control was not enabled or if the operation failed, `0xC8A18008` if camera is in use\n by user, or `0xC8A18009` if QTM is unavailable (in particular, QTM is always unavailable on N2DSXL).\n Otherwise, 0 (success)."]
    pub fn QTMU_SetIrLedStatus(on: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Attempts to clear IR LED overrides from any of the relevant commands in `qtm:u`, `qtm:s` (and `qtm:c`) commands\n by calling QTMU_EnableManualIrLedControl followed by QTMU_DisableManualIrLedControl, so that auto IR LED\n management takes place again.\n # Returns\n\nThe value returned by QTMU_DisableManualIrLedControl."]
    pub fn qtmClearIrLedOverrides() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Checks whether or not QTM has been blacklisted, ie. that it has been made unavailable.\n In detail, this means that the last call to QTMS_SetQtmStatus was made with argument QTM_STATUS_UNAVAILABLE,\n usually by NS. This feature seems to only be used for some internal test titles.\n\n # Arguments\n\n* `outBlacklisted` (direction out) - Whether or not QTM is unavailable. Always true on N2DSXL.\n # Returns\n\nAlways 0 (success).\n > **Note:** On N2DSXL, even though status is always supposed to be QTM_STATUS_UNAVAILABLE, this function often returns true\n (because NS doesn't change QTM's status if title isn't blacklisted). Do not rely on this for N2DSXL detection.\n > **Note:** Refer to https://www.3dbrew.org/wiki/NS_CFA for a list of title UIDs this is used for."]
    pub fn QTMU_IsCurrentAppBlacklisted(outBlacklisted: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the neutral (center) barrier position/offset in calibration, _without_ saving it to `cfg`.\n Takes effect immediately. SS3D works by calculating the position of the eye midpoint, rotated\n by the ideal eye-to-camera angle, expressed in (iod/12 units, iod assumed to be 62mm).\n\n # Arguments\n\n* `position` - Center barrier position, in terms of iod/12 units modulo iod/12.\n > **Note:** This field is floating-point for QTM auto-adjustment purposes, however the actual barrier position\n in hardware is an integer.\n > **Note:** This is the field that System Settings lets you add -1.0 to +1.0 to.\n > **Note:** There is no \"get\" counterpart for this.\n # Returns\n\n`0xC8A18009` if QTM is unavailable (in particular, QTM is always unavailable on N2DSXL), otherwise\n0 (success)."]
    pub fn QTMS_SetCenterBarrierPosition(position: f32) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the average ambient luminance as perceived by the inner camera (in lux).\n If QTM is unavailable (in particular, QTM is always unavailable on N2DSXL), returns 400.0 instead\n of the actual luminance.\n\n # Arguments\n\n* `outLuminanceLux` (direction out) - Where to write the luminance to. Always 400.0 on N2DSXL.\n > **Note:** Camera exposure, and in particular auto-exposure affects the returned luminance value. This must be\n taken into consideration, because this value can thus surge when user covers the inner camera.\n # Returns\n\nAlways 0 (success)."]
    pub fn QTMS_GetCameraLuminance(outLuminanceLux: *mut f32) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Enables automatic barrier control when in 3D mode with \"super stable 3D\" enabled.\n\n > **Note:** This is automatically called upon `qtm:s` and `qtm:sp` session exit.\n # Returns\n\n`0xC8A18009` if QTM is unavailable (in particular, QTM is always unavailable on N2DSXL), otherwise\n0 (success).\n > **Note:** Due to an oversight, QTMS_SetQtmStatus allows changing QTM state on N2DSXL. This is not intended\n to be done, and is in fact never done by official software. If that is regardless the case,\n this function here does nothing."]
    pub fn QTMS_EnableAutoBarrierControl() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Temporarily disables automatic barrier control (when in 3D mode with \"super stable 3D\" enabled).\n\n > **Note:** This is automatically called upon `qtm:s` and `qtm:sp` session exit.\n # Returns\n\n`0xC8A18009` if QTM is unavailable (in particular, QTM is always unavailable on N2DSXL), otherwise\n0 (success).\n > **Note:** Due to an oversight, QTMS_SetQtmStatus allows changing QTM state on N2DSXL. This is not intended\n to be done, and is in fact never done by official software. If that is regardless the case,\n this function here does nothing."]
    pub fn QTMS_DisableAutoBarrierControl() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Temporarily sets the parallax barrier's position (offset in iod/12 units, assuming slit width of 6 units).\n Does nothing in 2D mode and/or if \"super stable 3D\" is disabled.\n\n # Arguments\n\n* `position` - Parallax barrier position (offset in units), must be between 0 and 11 (both included)\n # Returns\n\n`0xC8A18009` if QTM is unavailable (in particular, QTM is always unavailable on N2DSXL), 0xE0E18002\n if `position` is not in range, otherwise 0 (success).\n > **Note:** Due to an oversight, QTMS_SetQtmStatus allows changing QTM state on N2DSXL. This is not intended\n to be done, and is in fact never done by official software. If that is regardless the case,\n this function here does nothing.\n > **Note:** No effect when the screen is in 2D mode.\n [`QTMC_SetBarrierPattern`]"]
    pub fn QTMS_SetBarrierPosition(position: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current position of the parallax barrier (offset in iod/12 units, slit width of 6 units).\n When \"super stable 3D\" is disabled, returns 13 instead.\n\n # Arguments\n\n* `outPosition` (direction out) - Where to write the barrier's position to.\n # Returns\n\n`0xC8A18009` if QTM is unavailable (in particular, QTM is always unavailable on N2DSXL), otherwise\n0 (success).\n > **Note:** When SS3D is disabled, this returns 13 to `outPosition` . When in 2D mode, the returned position is not\nupdated.\n > **Note:** Due to an oversight, QTMS_SetQtmStatus allows changing QTM state on N2DSXL. This is not intended\n to be done, and is in fact never done by official software. If that is regardless the case,\n this function here returns 13 to `outPosition` .\n [`QTMC_SetBarrierPattern`]"]
    pub fn QTMS_GetCurrentBarrierPosition(outPosition: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Temporarily overrides IR LED state. Requires \"manual control\" from `qtm:u` to be disabled, and has\n lower priority than it.\n\n # Arguments\n\n* `on` - Whether to turn the IR LED on or off.\n # Returns\n\n`0xC8A18005` if manual control was enabled or if the operation failed, `0xC8A18008` if camera is in use\n by user (unless \"hardware check\" API enabled), or `0xC8A18009` if QTM is unavailable (in particular,\n QTM is always unavailable on N2DSXL). Otherwise, 0 (success)."]
    pub fn QTMS_SetIrLedStatusOverride(on: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets calibration data, taking effect immediately, and optionally saves it to `cfg`.\n\n # Arguments\n\n* `cal` - Pointer to calibration data.\n * `saveCalToCfg` - Whether or not to persist the calibration data in `cfg`.\n # Returns\n\n`0xC8A18009` if QTM is unavailable (in particular, QTM is always unavailable on N2DSXL), otherwise\nwhatever `cfg:s` commands return (if used), or 0 (success).\n > **Note:** There is no \"get\" counterpart for this function, and there is no way to see the current calibration data\nin use unless it has been saved to `cfg`.\n > **Note:** Due to an oversight, QTMS_SetQtmStatus allows changing QTM state on N2DSXL. This is not intended\n to be done, and is in fact never done by official software. If that is regardless the case,\n this function here doesn't apply calibrations parameters (they may still be saved, however,\n even though QTM calibration blocks are always normally 0 on N2DSXL)."]
    pub fn QTMS_SetCalibrationData(cal: *const QtmCalibrationData, saveCalToCfg: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current QTM status (enabled/ss3d disabled/unavailable).\n\n # Arguments\n\n* `outQtmStatus` (direction out) - Where to write the QTM status to.\n # Returns\n\nAlways 0."]
    pub fn QTMS_GetQtmStatus(outQtmStatus: *mut QtmStatus) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the current QTM status (enabled/ss3d disabled/unavailable). Also sets or clear the\n \"blacklisted\" flag returned by QTMU_IsCurrentAppBlacklisted.\n\n # Arguments\n\n* `qtmStatus` - QTM status to set. If equal to QTM_STATUS_UNAVAILABLE, sets the \"blacklisted\" flag,\n otherwise clears it.\n # Returns\n\n`0xE0E18002` if enum value is invalid, otherwise 0 (success).\n > **Note:** System settings uses this to disable super-stable 3D, and NS to \"blacklist\" (make QTM unavailable)\n specific applications."]
    pub fn QTMS_SetQtmStatus(qtmStatus: QtmStatus) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Called by GSP's LCD driver to signal 2D<>3D mode change\n # Arguments\n\n* `newMode` - 0 for 2D, 1 for 800px 2D (unused for this function, same as 0), 2 for 3D\n # Returns\n\nAlways 0 (success)."]
    pub fn QTMSP_NotifyTopLcdModeChange(newMode: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Called by GSP's LCD driver during top LCD power-on to signal to QTM that it may power on\n and/or reconfigure then use the TI TCA6416A expander. In the process, QTM re-creates its\n expander thread.\n # Returns\n\nAlways 0 (success)."]
    pub fn QTMSP_NotifyTopLcdPowerOn() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Called by GSP's LCD driver to know whether or not QTM's expander thread is using\n the TI TCA6416A expander; it is waiting for this to become true/false during LCD\n power on/power off to proceed. Always false on N2DSXL.\n # Arguments\n\n* `outActive` (direction out) - Where to write the \"in use\" status to.\n # Returns\n\nAlways 0 (success)."]
    pub fn QTMSP_IsExpanderInUse(outActive: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Called by GSP's LCD driver during top LCD power-on to signal to QTM that it needs to\n switch the parallax barrier state to a 2D state (all-transparent mask). Causes QTM's\n expander thread to exit, relinquishing its `i2c::QTM` session with it.\n # Returns\n\nAlways 0 (success)."]
    pub fn QTMSP_NotifyTopLcdPowerOff() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes `qtm:c`.\n Only 3 sessions (2 until 9.3.0 sysupdate) for ALL services COMBINED, including the main\n services, can be open at a time."]
    pub fn qtmcInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits `qtm:c`."]
    pub fn qtmcExit();
}
unsafe extern "C" {
    #[doc = "Returns a pointer to the current `qtm:c` session handle."]
    pub fn qtmcGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Starts the QTM Hardware Check API. This must be called before using any other `qtm:c` command,\n and causes barrier pattern to be overriden by what was last set in QTMC_SetBarrierPattern,\n **even in 2D mode**. Also allows IR LED state to be overridden even if user uses the inner camera.\n # Returns\n\n`0xD82183F9` if already started, otherwise 0 (success)."]
    pub fn QTMC_StartHardwareCheck() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Stops the QTM Hardware Check API. Restore normal barrier and IR LED management behavior.\n # Returns\n\n`0xD82183F8` if API not started, otherwise 0 (success)."]
    pub fn QTMC_StopHardwareCheck() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the parallax barrier's mask pattern and polarity phase (12+1 bits).\n\n Bit11 to 0 correspond to a repeating barrier mask pattern, 0 meaning the corresponding mask unit is\n transparent and 1 that it is opaque. The direction is: left->right corresponds to MSB->LSB.\n\n Bit12 is the polarity bit.\n\n QTM's expander management thread repeatedly writes (on every loop iteration) the current mask pattern\n plus polarity bit, whether it is normally set or overridden by `qtm:c`, then on the following set,\n negates both (it writes pattern ^ 0x1FFF). This is done at all times, even it 2D mode.\n\n The register being written to are regId 0x02 and 0x03 (output ports).\n TI TCA6416A I2C->Parallel expander is located on bus I2C1 (PA 0x10161000) device ID 0x40.\n\n This function has no effect on N2DSXL.\n\n # Arguments\n\n* `pattern` - Barrier mask pattern (bit12: polarity, bit11-0: 12-bit mask pattern)\n # Returns\n\n`0xD82183F8` if API not started, otherwise 0 (success).\n [`Patent`] US20030234980A1 for a description of parallax barriers.\n  mask pattern used for super-stable 3D are as follows (position 0 to 11):\n\n 000011111100\n 000001111110\n 000000111111\n 100000011111\n 110000001111\n 111000000111\n 111100000011\n 111110000001\n 111111000000\n 011111100000\n 001111110000\n 000111111000\n\n When SS3D is disabled (ie. it tries to match O3DS behavior), then pattern becomes:\n 111100000111\n Notice that the slit width is reduced from 6 to 5 units there.\n\n For 2D it is all-zero:\n 000000000000\n\n 2D pattern is automatically set on QTM process init and exit."]
    pub fn QTMC_SetBarrierPattern(pattern: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Waits for the expander management thread to (re)initalize the TI TCA6416A I2C->Parallel expander,\n then checks if that expander is behaving as expected (responds with the port direction config\n it has been configured with): it checks whether all ports have been configured as outputs.\n\n On N2DSXL, this function waits forever and never returns.\n\n In detail, the hardware init procedure for the expander is as follows (as done by the expander mgmt. thread):\n - configure enable expander pin on SoC: set GPIO3.bit11 to OUTPUT, then set to 1\n - on the expander (I2C1 deviceId 0x40), set all ports to OUTPUT (regId 0x06, 0x07)\n - on the expander, write 0 (all-transparent mask/2D) to the data registers (regId 0x02, 0x03)\n\n # Arguments\n\n* `outWorking` (direction out) - Where to write the working status to. If true, expander is present working.\n If false, the expander is present but is misbehaving. If the function does not\n return, then expander is missing (e.g. on N2DSXL).\n # Returns\n\n`0xD82183F8` if API not started, otherwise 0 (success)."]
    pub fn QTMC_WaitAndCheckExpanderWorking(outWorking: *mut bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Temporarily overrides IR LED state. Requires \"manual control\" from `qtm:u` to be disabled, and has\n lower priority than it. Same implementation as QTMS_SetIrLedStatusOverride.\n\n # Arguments\n\n* `on` - Whether to turn the IR LED on or off.\n # Returns\n\n`0xD82183F8` if API not started, `0xC8A18005` if manual control was enabled or if the operation failed,\n or `0xC8A18009` if QTM is unavailable (in particular, QTM is always unavailable on N2DSXL). Otherwise, 0 (success)."]
    pub fn QTMC_SetIrLedStatusOverride(on: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes srv:pm and the service API."]
    pub fn srvPmInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits srv:pm and the service API."]
    pub fn srvPmExit();
}
unsafe extern "C" {
    #[doc = "Gets the current srv:pm session handle.\n # Returns\n\nThe current srv:pm session handle."]
    pub fn srvPmGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Publishes a notification to a process.\n # Arguments\n\n* `notificationId` - ID of the notification.\n * `process` - Process to publish to."]
    pub fn SRVPM_PublishToProcess(notificationId: u32_, process: Handle) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Publishes a notification to all processes.\n # Arguments\n\n* `notificationId` - ID of the notification."]
    pub fn SRVPM_PublishToAll(notificationId: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Registers a process with SRV.\n # Arguments\n\n* `pid` - ID of the process.\n * `count` - Number of services within the service access control data.\n * `serviceAccessControlList` - Service Access Control list."]
    pub fn SRVPM_RegisterProcess(
        pid: u32_,
        count: u32_,
        serviceAccessControlList: *const [::libc::c_char; 8usize],
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unregisters a process with SRV.\n # Arguments\n\n* `pid` - ID of the process."]
    pub fn SRVPM_UnregisterProcess(pid: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes LOADER."]
    pub fn loaderInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits LOADER."]
    pub fn loaderExit();
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Loads a program and returns a process handle to the newly created process.\n # Arguments\n\n* `process` (direction out) - Pointer to output the process handle to.\n * `programHandle` - The handle of the program to load."]
    pub fn LOADER_LoadProcess(process: *mut Handle, programHandle: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Registers a program (along with its update).\n # Arguments\n\n* `programHandle` (direction out) - Pointer to output the program handle to.\n * `programInfo` - The program info.\n * `programInfo` - The program update info."]
    pub fn LOADER_RegisterProgram(
        programHandle: *mut u64_,
        programInfo: *const FS_ProgramInfo,
        programInfoUpdate: *const FS_ProgramInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unregisters a program (along with its update).\n # Arguments\n\n* `programHandle` - The handle of the program to unregister."]
    pub fn LOADER_UnregisterProgram(programHandle: u64_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Retrives a program's main NCCH extended header info (SCI + ACI, see ExHeader_Info).\n # Arguments\n\n* `exheaderInfo` (direction out) - Pointer to output the main NCCH extended header info.\n * `programHandle` - The handle of the program to unregister"]
    pub fn LOADER_GetProgramInfo(exheaderInfo: *mut ExHeader_Info, programHandle: u64_) -> Result;
}
#[doc = "< The normal mode of the led"]
pub const LED_NORMAL: powerLedState = 1;
#[doc = "< The led pulses slowly as it does in the sleep mode"]
pub const LED_SLEEP_MODE: powerLedState = 2;
#[doc = "< Switch off power led"]
pub const LED_OFF: powerLedState = 3;
#[doc = "< Red state of the led"]
pub const LED_RED: powerLedState = 4;
#[doc = "< Blue state of the led"]
pub const LED_BLUE: powerLedState = 5;
#[doc = "< Blinking red state of power led and notification led"]
pub const LED_BLINK_RED: powerLedState = 6;
pub type powerLedState = ::libc::c_uchar;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct InfoLedPattern {
    #[doc = "< Delay between pattern values, 1/16th of a second (1 second = 0x10)"]
    pub delay: u8_,
    #[doc = "< Smoothing between pattern values (higher = smoother)"]
    pub smoothing: u8_,
    #[doc = "< Delay between pattern loops, 1/16th of a second (1 second = 0x10, 0xFF = pattern is played only once)"]
    pub loopDelay: u8_,
    #[doc = "< Blink speed, when smoothing == 0x00"]
    pub blinkSpeed: u8_,
    #[doc = "< Pattern for red component"]
    pub redPattern: [u8_; 32usize],
    #[doc = "< Pattern for green component"]
    pub greenPattern: [u8_; 32usize],
    #[doc = "< Pattern for blue component"]
    pub bluePattern: [u8_; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of InfoLedPattern"][::core::mem::size_of::<InfoLedPattern>() - 100usize];
    ["Alignment of InfoLedPattern"][::core::mem::align_of::<InfoLedPattern>() - 1usize];
    ["Offset of field: InfoLedPattern::delay"]
        [::core::mem::offset_of!(InfoLedPattern, delay) - 0usize];
    ["Offset of field: InfoLedPattern::smoothing"]
        [::core::mem::offset_of!(InfoLedPattern, smoothing) - 1usize];
    ["Offset of field: InfoLedPattern::loopDelay"]
        [::core::mem::offset_of!(InfoLedPattern, loopDelay) - 2usize];
    ["Offset of field: InfoLedPattern::blinkSpeed"]
        [::core::mem::offset_of!(InfoLedPattern, blinkSpeed) - 3usize];
    ["Offset of field: InfoLedPattern::redPattern"]
        [::core::mem::offset_of!(InfoLedPattern, redPattern) - 4usize];
    ["Offset of field: InfoLedPattern::greenPattern"]
        [::core::mem::offset_of!(InfoLedPattern, greenPattern) - 36usize];
    ["Offset of field: InfoLedPattern::bluePattern"]
        [::core::mem::offset_of!(InfoLedPattern, bluePattern) - 68usize];
};
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes mcuHwc."]
    pub fn mcuHwcInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits mcuHwc."]
    pub fn mcuHwcExit();
}
unsafe extern "C" {
    #[doc = "Gets the current mcuHwc session handle.\n # Returns\n\nA pointer to the current mcuHwc session handle."]
    pub fn mcuHwcGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads data from an i2c device3 register\n # Arguments\n\n* `reg` - Register number. See https://www.3dbrew.org/wiki/I2C_Registers#Device_3 for more info\n * `data` - Pointer to write the data to.\n * `size` - Size of data to be read"]
    pub fn MCUHWC_ReadRegister(reg: u8_, data: *mut ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes data to a i2c device3 register\n # Arguments\n\n* `reg` - Register number. See https://www.3dbrew.org/wiki/I2C_Registers#Device_3 for more info\n * `data` - Pointer to write the data to.\n * `size` - Size of data to be written"]
    pub fn MCUHWC_WriteRegister(reg: u8_, data: *const ::libc::c_void, size: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the battery voltage\n # Arguments\n\n* `voltage` - Pointer to write the battery voltage to."]
    pub fn MCUHWC_GetBatteryVoltage(voltage: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the battery level\n # Arguments\n\n* `level` - Pointer to write the current battery level to."]
    pub fn MCUHWC_GetBatteryLevel(level: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the sound slider level\n # Arguments\n\n* `level` - Pointer to write the slider level to."]
    pub fn MCUHWC_GetSoundSliderLevel(level: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets Wifi LED state\n # Arguments\n\n* `state` - State of Wifi LED. (True/False)"]
    pub fn MCUHWC_SetWifiLedState(state: bool) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the notification LED pattern\n # Arguments\n\n* `pattern` - Pattern for the notification LED."]
    pub fn MCUHWC_SetInfoLedPattern(pattern: *const InfoLedPattern) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets Power LED state\n # Arguments\n\n* `state` - powerLedState State of power LED."]
    pub fn MCUHWC_SetPowerLedState(state: powerLedState) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets 3d slider level\n # Arguments\n\n* `level` - Pointer to write 3D slider level to."]
    pub fn MCUHWC_Get3dSliderLevel(level: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the major MCU firmware version\n # Arguments\n\n* `out` - Pointer to write the major firmware version to."]
    pub fn MCUHWC_GetFwVerHigh(out: *mut u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets the minor MCU firmware version\n # Arguments\n\n* `out` - Pointer to write the minor firmware version to."]
    pub fn MCUHWC_GetFwVerLow(out: *mut u8_) -> Result;
}
#[doc = "< Primary I2S line, used by DSP/Mic (configurable)/GBA sound controller."]
pub const CODEC_I2S_LINE_1: CodecI2sLine = 0;
#[doc = "< Secondary I2S line, used by CSND hardware."]
pub const CODEC_I2S_LINE_2: CodecI2sLine = 1;
#[doc = "I2S line enumeration"]
pub type CodecI2sLine = ::libc::c_uchar;
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes CDCCHK."]
    pub fn cdcChkInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits CDCCHK."]
    pub fn cdcChkExit();
}
unsafe extern "C" {
    #[doc = "Gets a pointer to the current cdc:CHK session handle.\n # Returns\n\nA pointer to the current cdc:CHK session handle."]
    pub fn cdcChkGetSessionHandle() -> *mut Handle;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads multiple registers from the CODEC, using the old\n SPI hardware interface and a 4MHz baudrate.\n # Arguments\n\n* `pageId` - CODEC Page ID.\n * `initialRegAddr` - Address of the CODEC register to start with.\n * `outData` (direction out) - Where to write the read data to.\n * `size` - Number of registers to read (bytes to read, max. 64)."]
    pub fn CDCCHK_ReadRegisters1(
        pageId: u8_,
        initialRegAddr: u8_,
        outData: *mut ::libc::c_void,
        size: usize,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads multiple registers from the CODEC, using the new\n SPI hardware interface and a 16MHz baudrate.\n # Arguments\n\n* `pageId` - CODEC Page ID.\n * `initialRegAddr` - Address of the CODEC register to start with.\n * `outData` (direction out) - Where to read the data to.\n * `size` - Number of registers to read (bytes to read, max. 64)."]
    pub fn CDCCHK_ReadRegisters2(
        pageId: u8_,
        initialRegAddr: u8_,
        outData: *mut ::libc::c_void,
        size: usize,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes multiple registers to the CODEC, using the old\n SPI hardware interface and a 4MHz baudrate.\n # Arguments\n\n* `pageId` - CODEC Page ID.\n * `initialRegAddr` - Address of the CODEC register to start with.\n * `data` - Where to read the data to write from.\n * `size` - Number of registers to write (bytes to read, max. 64)."]
    pub fn CDCCHK_WriteRegisters1(
        pageId: u8_,
        initialRegAddr: u8_,
        data: *const ::libc::c_void,
        size: usize,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes multiple registers to the CODEC, using the new\n SPI hardware interface and a 16MHz baudrate.\n # Arguments\n\n* `pageId` - CODEC Page ID.\n * `initialRegAddr` - Address of the CODEC register to start with.\n * `data` - Where to read the data to write from.\n * `size` - Number of registers to write (bytes to read, max. 64)."]
    pub fn CDCCHK_WriteRegisters2(
        pageId: u8_,
        initialRegAddr: u8_,
        data: *const ::libc::c_void,
        size: usize,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Reads a single register from the NTR PMIC.\n # Arguments\n\n* `outData` (direction out) - Where to read the data to (1 byte).\n * `regAddr` - Register address.\n > **Note:** The NTR PMIC is emulated by the CODEC hardware and sends\n IRQs to the MCU when relevant."]
    pub fn CDCCHK_ReadNtrPmicRegister(outData: *mut u8_, regAddr: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Writes a single register from the NTR PMIC.\n # Arguments\n\n* `regAddr` - Register address.\n * `data` - Data to write (1 byte).\n > **Note:** The NTR PMIC is emulated by the CODEC hardware and sends\n IRQs to the MCU when relevant."]
    pub fn CDCCHK_WriteNtrPmicRegister(regAddr: u8_, data: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the DAC volume level for the specified I2S line.\n # Arguments\n\n* `i2sLine` - I2S line to set the volume for.\n * `volume` - Volume level (-128 to 0)."]
    pub fn CDCCHK_SetI2sVolume(i2sLine: CodecI2sLine, volume: s8) -> Result;
}
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
pub const GX_TRANSFER_FMT_RGBA8: GX_TRANSFER_FORMAT = 0;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue"]
pub const GX_TRANSFER_FMT_RGB8: GX_TRANSFER_FORMAT = 1;
#[doc = "< 5-bit Red + 6-bit Green + 5-bit Blue"]
pub const GX_TRANSFER_FMT_RGB565: GX_TRANSFER_FORMAT = 2;
#[doc = "< 5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
pub const GX_TRANSFER_FMT_RGB5A1: GX_TRANSFER_FORMAT = 3;
#[doc = "< 4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
pub const GX_TRANSFER_FMT_RGBA4: GX_TRANSFER_FORMAT = 4;
#[doc = "Supported transfer pixel formats.\n [`GSPGPU_FramebufferFormat`]"]
pub type GX_TRANSFER_FORMAT = ::libc::c_uchar;
#[doc = "< No anti-aliasing"]
pub const GX_TRANSFER_SCALE_NO: GX_TRANSFER_SCALE = 0;
#[doc = "< 2x1 anti-aliasing"]
pub const GX_TRANSFER_SCALE_X: GX_TRANSFER_SCALE = 1;
#[doc = "< 2x2 anti-aliasing"]
pub const GX_TRANSFER_SCALE_XY: GX_TRANSFER_SCALE = 2;
#[doc = "Anti-aliasing modes\n\n Please remember that the framebuffer is sideways.\n Hence if you activate 2x1 anti-aliasing the destination dimensions are w = 240*2 and h = 400"]
pub type GX_TRANSFER_SCALE = ::libc::c_uchar;
#[doc = "< Trigger the PPF event"]
pub const GX_FILL_TRIGGER: GX_FILL_CONTROL = 1;
#[doc = "< Indicates if the memory fill is complete. You should not use it when requesting a transfer."]
pub const GX_FILL_FINISHED: GX_FILL_CONTROL = 2;
#[doc = "< The buffer has a 16 bit per pixel depth"]
pub const GX_FILL_16BIT_DEPTH: GX_FILL_CONTROL = 0;
#[doc = "< The buffer has a 24 bit per pixel depth"]
pub const GX_FILL_24BIT_DEPTH: GX_FILL_CONTROL = 256;
#[doc = "< The buffer has a 32 bit per pixel depth"]
pub const GX_FILL_32BIT_DEPTH: GX_FILL_CONTROL = 512;
#[doc = "GX transfer control flags"]
pub type GX_FILL_CONTROL = ::libc::c_ushort;
#[doc = "GX command entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union gxCmdEntry_s {
    #[doc = "< Raw command data"]
    pub data: [u32_; 8usize],
    pub __bindgen_anon_1: gxCmdEntry_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gxCmdEntry_s__bindgen_ty_1 {
    #[doc = "< Command type"]
    pub type_: u8_,
    pub unk1: u8_,
    pub unk2: u8_,
    pub unk3: u8_,
    #[doc = "< Command arguments"]
    pub args: [u32_; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gxCmdEntry_s__bindgen_ty_1"]
        [::core::mem::size_of::<gxCmdEntry_s__bindgen_ty_1>() - 32usize];
    ["Alignment of gxCmdEntry_s__bindgen_ty_1"]
        [::core::mem::align_of::<gxCmdEntry_s__bindgen_ty_1>() - 4usize];
    ["Offset of field: gxCmdEntry_s__bindgen_ty_1::type_"]
        [::core::mem::offset_of!(gxCmdEntry_s__bindgen_ty_1, type_) - 0usize];
    ["Offset of field: gxCmdEntry_s__bindgen_ty_1::unk1"]
        [::core::mem::offset_of!(gxCmdEntry_s__bindgen_ty_1, unk1) - 1usize];
    ["Offset of field: gxCmdEntry_s__bindgen_ty_1::unk2"]
        [::core::mem::offset_of!(gxCmdEntry_s__bindgen_ty_1, unk2) - 2usize];
    ["Offset of field: gxCmdEntry_s__bindgen_ty_1::unk3"]
        [::core::mem::offset_of!(gxCmdEntry_s__bindgen_ty_1, unk3) - 3usize];
    ["Offset of field: gxCmdEntry_s__bindgen_ty_1::args"]
        [::core::mem::offset_of!(gxCmdEntry_s__bindgen_ty_1, args) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gxCmdEntry_s"][::core::mem::size_of::<gxCmdEntry_s>() - 32usize];
    ["Alignment of gxCmdEntry_s"][::core::mem::align_of::<gxCmdEntry_s>() - 4usize];
    ["Offset of field: gxCmdEntry_s::data"][::core::mem::offset_of!(gxCmdEntry_s, data) - 0usize];
};
impl Default for gxCmdEntry_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "GX command queue structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_gxCmdQueue_s {
    #[doc = "< Pointer to array of GX command entries"]
    pub entries: *mut gxCmdEntry_s,
    #[doc = "< Capacity of the command array"]
    pub maxEntries: u16_,
    #[doc = "< Number of commands in the queue"]
    pub numEntries: u16_,
    #[doc = "< Index of the first pending command to be submitted to GX"]
    pub curEntry: u16_,
    #[doc = "< Number of commands completed by GX"]
    pub lastEntry: u16_,
    #[doc = "< User callback"]
    pub callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tag_gxCmdQueue_s)>,
    #[doc = "< Data for user callback"]
    pub user: *mut ::libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tag_gxCmdQueue_s"][::core::mem::size_of::<tag_gxCmdQueue_s>() - 20usize];
    ["Alignment of tag_gxCmdQueue_s"][::core::mem::align_of::<tag_gxCmdQueue_s>() - 4usize];
    ["Offset of field: tag_gxCmdQueue_s::entries"]
        [::core::mem::offset_of!(tag_gxCmdQueue_s, entries) - 0usize];
    ["Offset of field: tag_gxCmdQueue_s::maxEntries"]
        [::core::mem::offset_of!(tag_gxCmdQueue_s, maxEntries) - 4usize];
    ["Offset of field: tag_gxCmdQueue_s::numEntries"]
        [::core::mem::offset_of!(tag_gxCmdQueue_s, numEntries) - 6usize];
    ["Offset of field: tag_gxCmdQueue_s::curEntry"]
        [::core::mem::offset_of!(tag_gxCmdQueue_s, curEntry) - 8usize];
    ["Offset of field: tag_gxCmdQueue_s::lastEntry"]
        [::core::mem::offset_of!(tag_gxCmdQueue_s, lastEntry) - 10usize];
    ["Offset of field: tag_gxCmdQueue_s::callback"]
        [::core::mem::offset_of!(tag_gxCmdQueue_s, callback) - 12usize];
    ["Offset of field: tag_gxCmdQueue_s::user"]
        [::core::mem::offset_of!(tag_gxCmdQueue_s, user) - 16usize];
};
impl Default for tag_gxCmdQueue_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "GX command queue structure"]
pub type gxCmdQueue_s = tag_gxCmdQueue_s;
unsafe extern "C" {
    #[doc = "Clears a GX command queue.\n # Arguments\n\n* `queue` - The GX command queue."]
    pub fn gxCmdQueueClear(queue: *mut gxCmdQueue_s);
}
unsafe extern "C" {
    #[doc = "Adds a command to a GX command queue.\n # Arguments\n\n* `queue` - The GX command queue.\n * `entry` - The GX command to add."]
    pub fn gxCmdQueueAdd(queue: *mut gxCmdQueue_s, entry: *const gxCmdEntry_s);
}
unsafe extern "C" {
    #[doc = "Runs a GX command queue, causing it to begin processing incoming commands as they arrive.\n # Arguments\n\n* `queue` - The GX command queue."]
    pub fn gxCmdQueueRun(queue: *mut gxCmdQueue_s);
}
unsafe extern "C" {
    #[doc = "Stops a GX command queue from processing incoming commands.\n # Arguments\n\n* `queue` - The GX command queue."]
    pub fn gxCmdQueueStop(queue: *mut gxCmdQueue_s);
}
unsafe extern "C" {
    #[doc = "Waits for a GX command queue to finish executing pending commands.\n # Arguments\n\n* `queue` - The GX command queue.\n * `timeout` - Optional timeout (in nanoseconds) to wait (specify -1 for no timeout).\n # Returns\n\nfalse if timeout expired, true otherwise."]
    pub fn gxCmdQueueWait(queue: *mut gxCmdQueue_s, timeout: s64) -> bool;
}
unsafe extern "C" {
    #[doc = "Sets the completion callback for a GX command queue.\n # Arguments\n\n* `queue` - The GX command queue.\n * `callback` - The completion callback.\n * `user` - User data."]
    #[link_name = "gxCmdQueueSetCallback__extern"]
    pub fn gxCmdQueueSetCallback(
        queue: *mut gxCmdQueue_s,
        callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut gxCmdQueue_s)>,
        user: *mut ::libc::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Selects a command queue to which GX_* functions will add commands instead of immediately submitting them to GX.\n # Arguments\n\n* `queue` - The GX command queue. (Pass NULL to remove the bound command queue)"]
    pub fn GX_BindQueue(queue: *mut gxCmdQueue_s);
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Requests a DMA.\n # Arguments\n\n* `src` - Source to DMA from.\n * `dst` - Destination to DMA to.\n * `length` - Length of data to transfer."]
    pub fn GX_RequestDma(src: *mut u32_, dst: *mut u32_, length: u32_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Processes a GPU command list.\n # Arguments\n\n* `buf0a` - Command list address.\n * `buf0s` - Command list size.\n * `flags` - Flags to process with."]
    pub fn GX_ProcessCommandList(buf0a: *mut u32_, buf0s: u32_, flags: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Fills the memory of two buffers with the given values.\n # Arguments\n\n* `buf0a` - Start address of the first buffer.\n * `buf0v` - Dimensions of the first buffer.\n * `buf0e` - End address of the first buffer.\n * `control0` - Value to fill the first buffer with.\n * `buf1a` - Start address of the second buffer.\n * `buf1v` - Dimensions of the second buffer.\n * `buf1e` - End address of the second buffer.\n * `control1` - Value to fill the second buffer with."]
    pub fn GX_MemoryFill(
        buf0a: *mut u32_,
        buf0v: u32_,
        buf0e: *mut u32_,
        control0: u16_,
        buf1a: *mut u32_,
        buf1v: u32_,
        buf1e: *mut u32_,
        control1: u16_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initiates a display transfer.\n > **Note:** The PPF event will be signaled on completion.\n # Arguments\n\n* `inadr` - Address of the input.\n * `indim` - Dimensions of the input.\n * `outadr` - Address of the output.\n * `outdim` - Dimensions of the output.\n * `flags` - Flags to transfer with."]
    pub fn GX_DisplayTransfer(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        flags: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initiates a texture copy.\n > **Note:** The PPF event will be signaled on completion.\n # Arguments\n\n* `inadr` - Address of the input.\n * `indim` - Dimensions of the input.\n * `outadr` - Address of the output.\n * `outdim` - Dimensions of the output.\n * `size` - Size of the data to transfer.\n * `flags` - Flags to transfer with."]
    pub fn GX_TextureCopy(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        size: u32_,
        flags: u32_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Flushes the cache regions of three buffers. (This command cannot be queued in a GX command queue)\n # Arguments\n\n* `buf0a` - Address of the first buffer.\n * `buf0s` - Size of the first buffer.\n * `buf1a` - Address of the second buffer.\n * `buf1s` - Size of the second buffer.\n * `buf2a` - Address of the third buffer.\n * `buf2s` - Size of the third buffer."]
    pub fn GX_FlushCacheRegions(
        buf0a: *mut u32_,
        buf0s: u32_,
        buf1a: *mut u32_,
        buf1s: u32_,
        buf2a: *mut u32_,
        buf2s: u32_,
    ) -> Result;
}
#[doc = "< Nearest-neighbor interpolation."]
pub const GPU_NEAREST: GPU_TEXTURE_FILTER_PARAM = 0;
#[doc = "< Linear interpolation."]
pub const GPU_LINEAR: GPU_TEXTURE_FILTER_PARAM = 1;
#[doc = "Texture filters."]
pub type GPU_TEXTURE_FILTER_PARAM = ::libc::c_uchar;
#[doc = "< Clamps to edge."]
pub const GPU_CLAMP_TO_EDGE: GPU_TEXTURE_WRAP_PARAM = 0;
#[doc = "< Clamps to border."]
pub const GPU_CLAMP_TO_BORDER: GPU_TEXTURE_WRAP_PARAM = 1;
#[doc = "< Repeats texture."]
pub const GPU_REPEAT: GPU_TEXTURE_WRAP_PARAM = 2;
#[doc = "< Repeats with mirrored texture."]
pub const GPU_MIRRORED_REPEAT: GPU_TEXTURE_WRAP_PARAM = 3;
#[doc = "Texture wrap modes."]
pub type GPU_TEXTURE_WRAP_PARAM = ::libc::c_uchar;
#[doc = "< 2D texture"]
pub const GPU_TEX_2D: GPU_TEXTURE_MODE_PARAM = 0;
#[doc = "< Cube map"]
pub const GPU_TEX_CUBE_MAP: GPU_TEXTURE_MODE_PARAM = 1;
#[doc = "< 2D Shadow texture"]
pub const GPU_TEX_SHADOW_2D: GPU_TEXTURE_MODE_PARAM = 2;
#[doc = "< Projection texture"]
pub const GPU_TEX_PROJECTION: GPU_TEXTURE_MODE_PARAM = 3;
#[doc = "< Shadow cube map"]
pub const GPU_TEX_SHADOW_CUBE: GPU_TEXTURE_MODE_PARAM = 4;
#[doc = "< Disabled"]
pub const GPU_TEX_DISABLED: GPU_TEXTURE_MODE_PARAM = 5;
#[doc = "Texture modes."]
pub type GPU_TEXTURE_MODE_PARAM = ::libc::c_uchar;
#[doc = "< Texture unit 0."]
pub const GPU_TEXUNIT0: GPU_TEXUNIT = 1;
#[doc = "< Texture unit 1."]
pub const GPU_TEXUNIT1: GPU_TEXUNIT = 2;
#[doc = "< Texture unit 2."]
pub const GPU_TEXUNIT2: GPU_TEXUNIT = 4;
#[doc = "Supported texture units."]
pub type GPU_TEXUNIT = ::libc::c_uchar;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
pub const GPU_RGBA8: GPU_TEXCOLOR = 0;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue"]
pub const GPU_RGB8: GPU_TEXCOLOR = 1;
#[doc = "< 5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
pub const GPU_RGBA5551: GPU_TEXCOLOR = 2;
#[doc = "< 5-bit Red + 6-bit Green + 5-bit Blue"]
pub const GPU_RGB565: GPU_TEXCOLOR = 3;
#[doc = "< 4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
pub const GPU_RGBA4: GPU_TEXCOLOR = 4;
#[doc = "< 8-bit Luminance + 8-bit Alpha"]
pub const GPU_LA8: GPU_TEXCOLOR = 5;
#[doc = "< 8-bit Hi + 8-bit Lo"]
pub const GPU_HILO8: GPU_TEXCOLOR = 6;
#[doc = "< 8-bit Luminance"]
pub const GPU_L8: GPU_TEXCOLOR = 7;
#[doc = "< 8-bit Alpha"]
pub const GPU_A8: GPU_TEXCOLOR = 8;
#[doc = "< 4-bit Luminance + 4-bit Alpha"]
pub const GPU_LA4: GPU_TEXCOLOR = 9;
#[doc = "< 4-bit Luminance"]
pub const GPU_L4: GPU_TEXCOLOR = 10;
#[doc = "< 4-bit Alpha"]
pub const GPU_A4: GPU_TEXCOLOR = 11;
#[doc = "< ETC1 texture compression"]
pub const GPU_ETC1: GPU_TEXCOLOR = 12;
#[doc = "< ETC1 texture compression + 4-bit Alpha"]
pub const GPU_ETC1A4: GPU_TEXCOLOR = 13;
#[doc = "Supported texture formats."]
pub type GPU_TEXCOLOR = ::libc::c_uchar;
#[doc = "< 2D face"]
pub const GPU_TEXFACE_2D: GPU_TEXFACE = 0;
#[doc = "< +X face"]
pub const GPU_POSITIVE_X: GPU_TEXFACE = 0;
#[doc = "< -X face"]
pub const GPU_NEGATIVE_X: GPU_TEXFACE = 1;
#[doc = "< +Y face"]
pub const GPU_POSITIVE_Y: GPU_TEXFACE = 2;
#[doc = "< -Y face"]
pub const GPU_NEGATIVE_Y: GPU_TEXFACE = 3;
#[doc = "< +Z face"]
pub const GPU_POSITIVE_Z: GPU_TEXFACE = 4;
#[doc = "< -Z face"]
pub const GPU_NEGATIVE_Z: GPU_TEXFACE = 5;
#[doc = "Texture faces."]
pub type GPU_TEXFACE = ::libc::c_uchar;
#[doc = "< Clamp to zero."]
pub const GPU_PT_CLAMP_TO_ZERO: GPU_PROCTEX_CLAMP = 0;
#[doc = "< Clamp to edge."]
pub const GPU_PT_CLAMP_TO_EDGE: GPU_PROCTEX_CLAMP = 1;
#[doc = "< Symmetrical repeat."]
pub const GPU_PT_REPEAT: GPU_PROCTEX_CLAMP = 2;
#[doc = "< Mirrored repeat."]
pub const GPU_PT_MIRRORED_REPEAT: GPU_PROCTEX_CLAMP = 3;
#[doc = "< Pulse."]
pub const GPU_PT_PULSE: GPU_PROCTEX_CLAMP = 4;
#[doc = "Procedural texture clamp modes."]
pub type GPU_PROCTEX_CLAMP = ::libc::c_uchar;
#[doc = "< U"]
pub const GPU_PT_U: GPU_PROCTEX_MAPFUNC = 0;
#[doc = "< U2"]
pub const GPU_PT_U2: GPU_PROCTEX_MAPFUNC = 1;
#[doc = "< V"]
pub const GPU_PT_V: GPU_PROCTEX_MAPFUNC = 2;
#[doc = "< V2"]
pub const GPU_PT_V2: GPU_PROCTEX_MAPFUNC = 3;
#[doc = "< U+V"]
pub const GPU_PT_ADD: GPU_PROCTEX_MAPFUNC = 4;
#[doc = "< U2+V2"]
pub const GPU_PT_ADD2: GPU_PROCTEX_MAPFUNC = 5;
#[doc = "< sqrt(U2+V2)"]
pub const GPU_PT_SQRT2: GPU_PROCTEX_MAPFUNC = 6;
#[doc = "< min"]
pub const GPU_PT_MIN: GPU_PROCTEX_MAPFUNC = 7;
#[doc = "< max"]
pub const GPU_PT_MAX: GPU_PROCTEX_MAPFUNC = 8;
#[doc = "< rmax"]
pub const GPU_PT_RMAX: GPU_PROCTEX_MAPFUNC = 9;
#[doc = "Procedural texture mapping functions."]
pub type GPU_PROCTEX_MAPFUNC = ::libc::c_uchar;
#[doc = "< No shift."]
pub const GPU_PT_NONE: GPU_PROCTEX_SHIFT = 0;
#[doc = "< Odd shift."]
pub const GPU_PT_ODD: GPU_PROCTEX_SHIFT = 1;
#[doc = "< Even shift."]
pub const GPU_PT_EVEN: GPU_PROCTEX_SHIFT = 2;
#[doc = "Procedural texture shift values."]
pub type GPU_PROCTEX_SHIFT = ::libc::c_uchar;
#[doc = "< Nearest-neighbor"]
pub const GPU_PT_NEAREST: GPU_PROCTEX_FILTER = 0;
#[doc = "< Linear interpolation"]
pub const GPU_PT_LINEAR: GPU_PROCTEX_FILTER = 1;
#[doc = "< Nearest-neighbor with mipmap using nearest-neighbor"]
pub const GPU_PT_NEAREST_MIP_NEAREST: GPU_PROCTEX_FILTER = 2;
#[doc = "< Linear interpolation with mipmap using nearest-neighbor"]
pub const GPU_PT_LINEAR_MIP_NEAREST: GPU_PROCTEX_FILTER = 3;
#[doc = "< Nearest-neighbor with mipmap using linear interpolation"]
pub const GPU_PT_NEAREST_MIP_LINEAR: GPU_PROCTEX_FILTER = 4;
#[doc = "< Linear interpolation with mipmap using linear interpolation"]
pub const GPU_PT_LINEAR_MIP_LINEAR: GPU_PROCTEX_FILTER = 5;
#[doc = "Procedural texture filter values."]
pub type GPU_PROCTEX_FILTER = ::libc::c_uchar;
#[doc = "< Noise table"]
pub const GPU_LUT_NOISE: GPU_PROCTEX_LUTID = 0;
#[doc = "< RGB mapping function table"]
pub const GPU_LUT_RGBMAP: GPU_PROCTEX_LUTID = 2;
#[doc = "< Alpha mapping function table"]
pub const GPU_LUT_ALPHAMAP: GPU_PROCTEX_LUTID = 3;
#[doc = "< Color table"]
pub const GPU_LUT_COLOR: GPU_PROCTEX_LUTID = 4;
#[doc = "< Color difference table"]
pub const GPU_LUT_COLORDIF: GPU_PROCTEX_LUTID = 5;
#[doc = "Procedural texture LUT IDs."]
pub type GPU_PROCTEX_LUTID = ::libc::c_uchar;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
pub const GPU_RB_RGBA8: GPU_COLORBUF = 0;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue"]
pub const GPU_RB_RGB8: GPU_COLORBUF = 1;
#[doc = "< 5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
pub const GPU_RB_RGBA5551: GPU_COLORBUF = 2;
#[doc = "< 5-bit Red + 6-bit Green + 5-bit Blue"]
pub const GPU_RB_RGB565: GPU_COLORBUF = 3;
#[doc = "< 4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
pub const GPU_RB_RGBA4: GPU_COLORBUF = 4;
#[doc = "Supported color buffer formats."]
pub type GPU_COLORBUF = ::libc::c_uchar;
#[doc = "< 16-bit Depth"]
pub const GPU_RB_DEPTH16: GPU_DEPTHBUF = 0;
#[doc = "< 24-bit Depth"]
pub const GPU_RB_DEPTH24: GPU_DEPTHBUF = 2;
#[doc = "< 24-bit Depth + 8-bit Stencil"]
pub const GPU_RB_DEPTH24_STENCIL8: GPU_DEPTHBUF = 3;
#[doc = "Supported depth buffer formats."]
pub type GPU_DEPTHBUF = ::libc::c_uchar;
#[doc = "< Never pass."]
pub const GPU_NEVER: GPU_TESTFUNC = 0;
#[doc = "< Always pass."]
pub const GPU_ALWAYS: GPU_TESTFUNC = 1;
#[doc = "< Pass if equal."]
pub const GPU_EQUAL: GPU_TESTFUNC = 2;
#[doc = "< Pass if not equal."]
pub const GPU_NOTEQUAL: GPU_TESTFUNC = 3;
#[doc = "< Pass if less than."]
pub const GPU_LESS: GPU_TESTFUNC = 4;
#[doc = "< Pass if less than or equal."]
pub const GPU_LEQUAL: GPU_TESTFUNC = 5;
#[doc = "< Pass if greater than."]
pub const GPU_GREATER: GPU_TESTFUNC = 6;
#[doc = "< Pass if greater than or equal."]
pub const GPU_GEQUAL: GPU_TESTFUNC = 7;
#[doc = "Test functions."]
pub type GPU_TESTFUNC = ::libc::c_uchar;
#[doc = "< Pass if greater than or equal."]
pub const GPU_EARLYDEPTH_GEQUAL: GPU_EARLYDEPTHFUNC = 0;
#[doc = "< Pass if greater than."]
pub const GPU_EARLYDEPTH_GREATER: GPU_EARLYDEPTHFUNC = 1;
#[doc = "< Pass if less than or equal."]
pub const GPU_EARLYDEPTH_LEQUAL: GPU_EARLYDEPTHFUNC = 2;
#[doc = "< Pass if less than."]
pub const GPU_EARLYDEPTH_LESS: GPU_EARLYDEPTHFUNC = 3;
#[doc = "Early depth test functions."]
pub type GPU_EARLYDEPTHFUNC = ::libc::c_uchar;
#[doc = "< Never pass (0)."]
pub const GPU_GAS_NEVER: GPU_GASDEPTHFUNC = 0;
#[doc = "< Always pass (1)."]
pub const GPU_GAS_ALWAYS: GPU_GASDEPTHFUNC = 1;
#[doc = "< Pass if greater than (1-X)."]
pub const GPU_GAS_GREATER: GPU_GASDEPTHFUNC = 2;
#[doc = "< Pass if less than (X)."]
pub const GPU_GAS_LESS: GPU_GASDEPTHFUNC = 3;
#[doc = "Gas depth functions."]
pub type GPU_GASDEPTHFUNC = ::libc::c_uchar;
#[doc = "< Disable."]
pub const GPU_SCISSOR_DISABLE: GPU_SCISSORMODE = 0;
#[doc = "< Exclude pixels inside the scissor box."]
pub const GPU_SCISSOR_INVERT: GPU_SCISSORMODE = 1;
#[doc = "< Exclude pixels outside of the scissor box."]
pub const GPU_SCISSOR_NORMAL: GPU_SCISSORMODE = 3;
#[doc = "Scissor test modes."]
pub type GPU_SCISSORMODE = ::libc::c_uchar;
#[doc = "< Keep old value. (old_stencil)"]
pub const GPU_STENCIL_KEEP: GPU_STENCILOP = 0;
#[doc = "< Zero. (0)"]
pub const GPU_STENCIL_ZERO: GPU_STENCILOP = 1;
#[doc = "< Replace value. (ref)"]
pub const GPU_STENCIL_REPLACE: GPU_STENCILOP = 2;
#[doc = "< Increment value. (old_stencil + 1 saturated to [0, 255])"]
pub const GPU_STENCIL_INCR: GPU_STENCILOP = 3;
#[doc = "< Decrement value. (old_stencil - 1 saturated to [0, 255])"]
pub const GPU_STENCIL_DECR: GPU_STENCILOP = 4;
#[doc = "< Invert value. (~old_stencil)"]
pub const GPU_STENCIL_INVERT: GPU_STENCILOP = 5;
#[doc = "< Increment value. (old_stencil + 1)"]
pub const GPU_STENCIL_INCR_WRAP: GPU_STENCILOP = 6;
#[doc = "< Decrement value. (old_stencil - 1)"]
pub const GPU_STENCIL_DECR_WRAP: GPU_STENCILOP = 7;
#[doc = "Stencil operations."]
pub type GPU_STENCILOP = ::libc::c_uchar;
#[doc = "< Write red."]
pub const GPU_WRITE_RED: GPU_WRITEMASK = 1;
#[doc = "< Write green."]
pub const GPU_WRITE_GREEN: GPU_WRITEMASK = 2;
#[doc = "< Write blue."]
pub const GPU_WRITE_BLUE: GPU_WRITEMASK = 4;
#[doc = "< Write alpha."]
pub const GPU_WRITE_ALPHA: GPU_WRITEMASK = 8;
#[doc = "< Write depth."]
pub const GPU_WRITE_DEPTH: GPU_WRITEMASK = 16;
#[doc = "< Write all color components."]
pub const GPU_WRITE_COLOR: GPU_WRITEMASK = 15;
#[doc = "< Write all components."]
pub const GPU_WRITE_ALL: GPU_WRITEMASK = 31;
#[doc = "Pixel write mask."]
pub type GPU_WRITEMASK = ::libc::c_uchar;
#[doc = "< Add colors."]
pub const GPU_BLEND_ADD: GPU_BLENDEQUATION = 0;
#[doc = "< Subtract colors."]
pub const GPU_BLEND_SUBTRACT: GPU_BLENDEQUATION = 1;
#[doc = "< Reverse-subtract colors."]
pub const GPU_BLEND_REVERSE_SUBTRACT: GPU_BLENDEQUATION = 2;
#[doc = "< Use the minimum color."]
pub const GPU_BLEND_MIN: GPU_BLENDEQUATION = 3;
#[doc = "< Use the maximum color."]
pub const GPU_BLEND_MAX: GPU_BLENDEQUATION = 4;
#[doc = "Blend modes."]
pub type GPU_BLENDEQUATION = ::libc::c_uchar;
#[doc = "< Zero."]
pub const GPU_ZERO: GPU_BLENDFACTOR = 0;
#[doc = "< One."]
pub const GPU_ONE: GPU_BLENDFACTOR = 1;
#[doc = "< Source color."]
pub const GPU_SRC_COLOR: GPU_BLENDFACTOR = 2;
#[doc = "< Source color - 1."]
pub const GPU_ONE_MINUS_SRC_COLOR: GPU_BLENDFACTOR = 3;
#[doc = "< Destination color."]
pub const GPU_DST_COLOR: GPU_BLENDFACTOR = 4;
#[doc = "< Destination color - 1."]
pub const GPU_ONE_MINUS_DST_COLOR: GPU_BLENDFACTOR = 5;
#[doc = "< Source alpha."]
pub const GPU_SRC_ALPHA: GPU_BLENDFACTOR = 6;
#[doc = "< Source alpha - 1."]
pub const GPU_ONE_MINUS_SRC_ALPHA: GPU_BLENDFACTOR = 7;
#[doc = "< Destination alpha."]
pub const GPU_DST_ALPHA: GPU_BLENDFACTOR = 8;
#[doc = "< Destination alpha - 1."]
pub const GPU_ONE_MINUS_DST_ALPHA: GPU_BLENDFACTOR = 9;
#[doc = "< Constant color."]
pub const GPU_CONSTANT_COLOR: GPU_BLENDFACTOR = 10;
#[doc = "< Constant color - 1."]
pub const GPU_ONE_MINUS_CONSTANT_COLOR: GPU_BLENDFACTOR = 11;
#[doc = "< Constant alpha."]
pub const GPU_CONSTANT_ALPHA: GPU_BLENDFACTOR = 12;
#[doc = "< Constant alpha - 1."]
pub const GPU_ONE_MINUS_CONSTANT_ALPHA: GPU_BLENDFACTOR = 13;
#[doc = "< Saturated alpha."]
pub const GPU_SRC_ALPHA_SATURATE: GPU_BLENDFACTOR = 14;
#[doc = "Blend factors."]
pub type GPU_BLENDFACTOR = ::libc::c_uchar;
#[doc = "< Clear."]
pub const GPU_LOGICOP_CLEAR: GPU_LOGICOP = 0;
#[doc = "< Bitwise AND."]
pub const GPU_LOGICOP_AND: GPU_LOGICOP = 1;
#[doc = "< Reverse bitwise AND."]
pub const GPU_LOGICOP_AND_REVERSE: GPU_LOGICOP = 2;
#[doc = "< Copy."]
pub const GPU_LOGICOP_COPY: GPU_LOGICOP = 3;
#[doc = "< Set."]
pub const GPU_LOGICOP_SET: GPU_LOGICOP = 4;
#[doc = "< Inverted copy."]
pub const GPU_LOGICOP_COPY_INVERTED: GPU_LOGICOP = 5;
#[doc = "< No operation."]
pub const GPU_LOGICOP_NOOP: GPU_LOGICOP = 6;
#[doc = "< Invert."]
pub const GPU_LOGICOP_INVERT: GPU_LOGICOP = 7;
#[doc = "< Bitwise NAND."]
pub const GPU_LOGICOP_NAND: GPU_LOGICOP = 8;
#[doc = "< Bitwise OR."]
pub const GPU_LOGICOP_OR: GPU_LOGICOP = 9;
#[doc = "< Bitwise NOR."]
pub const GPU_LOGICOP_NOR: GPU_LOGICOP = 10;
#[doc = "< Bitwise XOR."]
pub const GPU_LOGICOP_XOR: GPU_LOGICOP = 11;
#[doc = "< Equivalent."]
pub const GPU_LOGICOP_EQUIV: GPU_LOGICOP = 12;
#[doc = "< Inverted bitwise AND."]
pub const GPU_LOGICOP_AND_INVERTED: GPU_LOGICOP = 13;
#[doc = "< Reverse bitwise OR."]
pub const GPU_LOGICOP_OR_REVERSE: GPU_LOGICOP = 14;
#[doc = "< Inverted bitwize OR."]
pub const GPU_LOGICOP_OR_INVERTED: GPU_LOGICOP = 15;
#[doc = "Logical operations."]
pub type GPU_LOGICOP = ::libc::c_uchar;
#[doc = "< OpenGL mode."]
pub const GPU_FRAGOPMODE_GL: GPU_FRAGOPMODE = 0;
#[doc = "< Gas mode (?)."]
pub const GPU_FRAGOPMODE_GAS_ACC: GPU_FRAGOPMODE = 1;
#[doc = "< Shadow mode (?)."]
pub const GPU_FRAGOPMODE_SHADOW: GPU_FRAGOPMODE = 3;
#[doc = "Fragment operation modes."]
pub type GPU_FRAGOPMODE = ::libc::c_uchar;
#[doc = "< 8-bit byte."]
pub const GPU_BYTE: GPU_FORMATS = 0;
#[doc = "< 8-bit unsigned byte."]
pub const GPU_UNSIGNED_BYTE: GPU_FORMATS = 1;
#[doc = "< 16-bit short."]
pub const GPU_SHORT: GPU_FORMATS = 2;
#[doc = "< 32-bit float."]
pub const GPU_FLOAT: GPU_FORMATS = 3;
#[doc = "Supported component formats."]
pub type GPU_FORMATS = ::libc::c_uchar;
#[doc = "< Disabled."]
pub const GPU_CULL_NONE: GPU_CULLMODE = 0;
#[doc = "< Front, counter-clockwise."]
pub const GPU_CULL_FRONT_CCW: GPU_CULLMODE = 1;
#[doc = "< Back, counter-clockwise."]
pub const GPU_CULL_BACK_CCW: GPU_CULLMODE = 2;
#[doc = "Cull modes."]
pub type GPU_CULLMODE = ::libc::c_uchar;
#[doc = "< Primary color."]
pub const GPU_PRIMARY_COLOR: GPU_TEVSRC = 0;
#[doc = "< Primary fragment color."]
pub const GPU_FRAGMENT_PRIMARY_COLOR: GPU_TEVSRC = 1;
#[doc = "< Secondary fragment color."]
pub const GPU_FRAGMENT_SECONDARY_COLOR: GPU_TEVSRC = 2;
#[doc = "< Texture unit 0."]
pub const GPU_TEXTURE0: GPU_TEVSRC = 3;
#[doc = "< Texture unit 1."]
pub const GPU_TEXTURE1: GPU_TEVSRC = 4;
#[doc = "< Texture unit 2."]
pub const GPU_TEXTURE2: GPU_TEVSRC = 5;
#[doc = "< Texture unit 3."]
pub const GPU_TEXTURE3: GPU_TEVSRC = 6;
#[doc = "< Previous buffer."]
pub const GPU_PREVIOUS_BUFFER: GPU_TEVSRC = 13;
#[doc = "< Constant value."]
pub const GPU_CONSTANT: GPU_TEVSRC = 14;
#[doc = "< Previous value."]
pub const GPU_PREVIOUS: GPU_TEVSRC = 15;
#[doc = "Texture combiner sources."]
pub type GPU_TEVSRC = ::libc::c_uchar;
#[doc = "< Source color."]
pub const GPU_TEVOP_RGB_SRC_COLOR: GPU_TEVOP_RGB = 0;
#[doc = "< Source color - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_COLOR: GPU_TEVOP_RGB = 1;
#[doc = "< Source alpha."]
pub const GPU_TEVOP_RGB_SRC_ALPHA: GPU_TEVOP_RGB = 2;
#[doc = "< Source alpha - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_ALPHA: GPU_TEVOP_RGB = 3;
#[doc = "< Source red."]
pub const GPU_TEVOP_RGB_SRC_R: GPU_TEVOP_RGB = 4;
#[doc = "< Source red - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_R: GPU_TEVOP_RGB = 5;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x06: GPU_TEVOP_RGB = 6;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x07: GPU_TEVOP_RGB = 7;
#[doc = "< Source green."]
pub const GPU_TEVOP_RGB_SRC_G: GPU_TEVOP_RGB = 8;
#[doc = "< Source green - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_G: GPU_TEVOP_RGB = 9;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x0A: GPU_TEVOP_RGB = 10;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x0B: GPU_TEVOP_RGB = 11;
#[doc = "< Source blue."]
pub const GPU_TEVOP_RGB_SRC_B: GPU_TEVOP_RGB = 12;
#[doc = "< Source blue - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_B: GPU_TEVOP_RGB = 13;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x0E: GPU_TEVOP_RGB = 14;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x0F: GPU_TEVOP_RGB = 15;
#[doc = "Texture RGB combiner operands."]
pub type GPU_TEVOP_RGB = ::libc::c_uchar;
#[doc = "< Source alpha."]
pub const GPU_TEVOP_A_SRC_ALPHA: GPU_TEVOP_A = 0;
#[doc = "< Source alpha - 1."]
pub const GPU_TEVOP_A_ONE_MINUS_SRC_ALPHA: GPU_TEVOP_A = 1;
#[doc = "< Source red."]
pub const GPU_TEVOP_A_SRC_R: GPU_TEVOP_A = 2;
#[doc = "< Source red - 1."]
pub const GPU_TEVOP_A_ONE_MINUS_SRC_R: GPU_TEVOP_A = 3;
#[doc = "< Source green."]
pub const GPU_TEVOP_A_SRC_G: GPU_TEVOP_A = 4;
#[doc = "< Source green - 1."]
pub const GPU_TEVOP_A_ONE_MINUS_SRC_G: GPU_TEVOP_A = 5;
#[doc = "< Source blue."]
pub const GPU_TEVOP_A_SRC_B: GPU_TEVOP_A = 6;
#[doc = "< Source blue - 1."]
pub const GPU_TEVOP_A_ONE_MINUS_SRC_B: GPU_TEVOP_A = 7;
#[doc = "Texture Alpha combiner operands."]
pub type GPU_TEVOP_A = ::libc::c_uchar;
#[doc = "< Replace."]
pub const GPU_REPLACE: GPU_COMBINEFUNC = 0;
#[doc = "< Modulate."]
pub const GPU_MODULATE: GPU_COMBINEFUNC = 1;
#[doc = "< Add."]
pub const GPU_ADD: GPU_COMBINEFUNC = 2;
#[doc = "< Signed add."]
pub const GPU_ADD_SIGNED: GPU_COMBINEFUNC = 3;
#[doc = "< Interpolate."]
pub const GPU_INTERPOLATE: GPU_COMBINEFUNC = 4;
#[doc = "< Subtract."]
pub const GPU_SUBTRACT: GPU_COMBINEFUNC = 5;
#[doc = "< Dot3. Scalar result is written to RGB only."]
pub const GPU_DOT3_RGB: GPU_COMBINEFUNC = 6;
#[doc = "< Dot3. Scalar result is written to RGBA."]
pub const GPU_DOT3_RGBA: GPU_COMBINEFUNC = 7;
#[doc = "< Multiply then add."]
pub const GPU_MULTIPLY_ADD: GPU_COMBINEFUNC = 8;
#[doc = "< Add then multiply."]
pub const GPU_ADD_MULTIPLY: GPU_COMBINEFUNC = 9;
#[doc = "Texture combiner functions."]
pub type GPU_COMBINEFUNC = ::libc::c_uchar;
#[doc = "< 1x"]
pub const GPU_TEVSCALE_1: GPU_TEVSCALE = 0;
#[doc = "< 2x"]
pub const GPU_TEVSCALE_2: GPU_TEVSCALE = 1;
#[doc = "< 4x"]
pub const GPU_TEVSCALE_4: GPU_TEVSCALE = 2;
#[doc = "Texture scale factors."]
pub type GPU_TEVSCALE = ::libc::c_uchar;
#[doc = "< None."]
pub const GPU_NO_FRESNEL: GPU_FRESNELSEL = 0;
#[doc = "< Primary alpha."]
pub const GPU_PRI_ALPHA_FRESNEL: GPU_FRESNELSEL = 1;
#[doc = "< Secondary alpha."]
pub const GPU_SEC_ALPHA_FRESNEL: GPU_FRESNELSEL = 2;
#[doc = "< Primary and secondary alpha."]
pub const GPU_PRI_SEC_ALPHA_FRESNEL: GPU_FRESNELSEL = 3;
#[doc = "Fresnel options."]
pub type GPU_FRESNELSEL = ::libc::c_uchar;
#[doc = "< Disabled."]
pub const GPU_BUMP_NOT_USED: GPU_BUMPMODE = 0;
#[doc = "< Bump as bump mapping."]
pub const GPU_BUMP_AS_BUMP: GPU_BUMPMODE = 1;
#[doc = "< Bump as tangent/normal mapping."]
pub const GPU_BUMP_AS_TANG: GPU_BUMPMODE = 2;
#[doc = "Bump map modes."]
pub type GPU_BUMPMODE = ::libc::c_uchar;
#[doc = "< D0 LUT."]
pub const GPU_LUT_D0: GPU_LIGHTLUTID = 0;
#[doc = "< D1 LUT."]
pub const GPU_LUT_D1: GPU_LIGHTLUTID = 1;
#[doc = "< Spotlight LUT."]
pub const GPU_LUT_SP: GPU_LIGHTLUTID = 2;
#[doc = "< Fresnel LUT."]
pub const GPU_LUT_FR: GPU_LIGHTLUTID = 3;
#[doc = "< Reflection-Blue LUT."]
pub const GPU_LUT_RB: GPU_LIGHTLUTID = 4;
#[doc = "< Reflection-Green LUT."]
pub const GPU_LUT_RG: GPU_LIGHTLUTID = 5;
#[doc = "< Reflection-Red LUT."]
pub const GPU_LUT_RR: GPU_LIGHTLUTID = 6;
#[doc = "< Distance attenuation LUT."]
pub const GPU_LUT_DA: GPU_LIGHTLUTID = 7;
#[doc = "LUT IDs."]
pub type GPU_LIGHTLUTID = ::libc::c_uchar;
#[doc = "< Normal*HalfVector"]
pub const GPU_LUTINPUT_NH: GPU_LIGHTLUTINPUT = 0;
#[doc = "< View*HalfVector"]
pub const GPU_LUTINPUT_VH: GPU_LIGHTLUTINPUT = 1;
#[doc = "< Normal*View"]
pub const GPU_LUTINPUT_NV: GPU_LIGHTLUTINPUT = 2;
#[doc = "< LightVector*Normal"]
pub const GPU_LUTINPUT_LN: GPU_LIGHTLUTINPUT = 3;
#[doc = "< -LightVector*SpotlightVector"]
pub const GPU_LUTINPUT_SP: GPU_LIGHTLUTINPUT = 4;
#[doc = "< cosine of phi"]
pub const GPU_LUTINPUT_CP: GPU_LIGHTLUTINPUT = 5;
#[doc = "LUT inputs."]
pub type GPU_LIGHTLUTINPUT = ::libc::c_uchar;
#[doc = "< 1x scale."]
pub const GPU_LUTSCALER_1x: GPU_LIGHTLUTSCALER = 0;
#[doc = "< 2x scale."]
pub const GPU_LUTSCALER_2x: GPU_LIGHTLUTSCALER = 1;
#[doc = "< 4x scale."]
pub const GPU_LUTSCALER_4x: GPU_LIGHTLUTSCALER = 2;
#[doc = "< 8x scale."]
pub const GPU_LUTSCALER_8x: GPU_LIGHTLUTSCALER = 3;
#[doc = "< 0.25x scale."]
pub const GPU_LUTSCALER_0_25x: GPU_LIGHTLUTSCALER = 6;
#[doc = "< 0.5x scale."]
pub const GPU_LUTSCALER_0_5x: GPU_LIGHTLUTSCALER = 7;
#[doc = "LUT scalers."]
pub type GPU_LIGHTLUTSCALER = ::libc::c_uchar;
#[doc = "< LUTs that are common to all lights."]
pub const GPU_LUTSELECT_COMMON: GPU_LIGHTLUTSELECT = 0;
#[doc = "< Spotlight LUT."]
pub const GPU_LUTSELECT_SP: GPU_LIGHTLUTSELECT = 1;
#[doc = "< Distance attenuation LUT."]
pub const GPU_LUTSELECT_DA: GPU_LIGHTLUTSELECT = 2;
#[doc = "LUT selection."]
pub type GPU_LIGHTLUTSELECT = ::libc::c_uchar;
#[doc = "< Fog/Gas unit disabled."]
pub const GPU_NO_FOG: GPU_FOGMODE = 0;
#[doc = "< Fog/Gas unit configured in Fog mode."]
pub const GPU_FOG: GPU_FOGMODE = 5;
#[doc = "< Fog/Gas unit configured in Gas mode."]
pub const GPU_GAS: GPU_FOGMODE = 7;
#[doc = "Fog modes."]
pub type GPU_FOGMODE = ::libc::c_uchar;
#[doc = "< Plain density."]
pub const GPU_PLAIN_DENSITY: GPU_GASMODE = 0;
#[doc = "< Depth density."]
pub const GPU_DEPTH_DENSITY: GPU_GASMODE = 1;
#[doc = "Gas shading density source values."]
pub type GPU_GASMODE = ::libc::c_uchar;
#[doc = "< Gas density used as input."]
pub const GPU_GAS_DENSITY: GPU_GASLUTINPUT = 0;
#[doc = "< Light factor used as input."]
pub const GPU_GAS_LIGHT_FACTOR: GPU_GASLUTINPUT = 1;
#[doc = "Gas color LUT inputs."]
pub type GPU_GASLUTINPUT = ::libc::c_uchar;
#[doc = "< Triangles."]
pub const GPU_TRIANGLES: GPU_Primitive_t = 0;
#[doc = "< Triangle strip."]
pub const GPU_TRIANGLE_STRIP: GPU_Primitive_t = 256;
#[doc = "< Triangle fan."]
pub const GPU_TRIANGLE_FAN: GPU_Primitive_t = 512;
#[doc = "< Geometry shader primitive."]
pub const GPU_GEOMETRY_PRIM: GPU_Primitive_t = 768;
#[doc = "Supported primitives."]
pub type GPU_Primitive_t = ::libc::c_ushort;
#[doc = "< Vertex shader."]
pub const GPU_VERTEX_SHADER: GPU_SHADER_TYPE = 0;
#[doc = "< Geometry shader."]
pub const GPU_GEOMETRY_SHADER: GPU_SHADER_TYPE = 1;
#[doc = "Shader types."]
pub type GPU_SHADER_TYPE = ::libc::c_uchar;
unsafe extern "C" {
    #[doc = "< GPU command buffer."]
    pub static mut gpuCmdBuf: *mut u32_;
}
unsafe extern "C" {
    #[doc = "< GPU command buffer size."]
    pub static mut gpuCmdBufSize: u32_;
}
unsafe extern "C" {
    #[doc = "< GPU command buffer offset."]
    pub static mut gpuCmdBufOffset: u32_;
}
unsafe extern "C" {
    #[doc = "Sets the GPU command buffer to use.\n # Arguments\n\n* `adr` - Pointer to the command buffer.\n * `size` - Size of the command buffer.\n * `offset` - Offset of the command buffer."]
    #[link_name = "GPUCMD_SetBuffer__extern"]
    pub fn GPUCMD_SetBuffer(adr: *mut u32_, size: u32_, offset: u32_);
}
unsafe extern "C" {
    #[doc = "Sets the offset of the GPU command buffer.\n # Arguments\n\n* `offset` - Offset of the command buffer."]
    #[link_name = "GPUCMD_SetBufferOffset__extern"]
    pub fn GPUCMD_SetBufferOffset(offset: u32_);
}
unsafe extern "C" {
    #[doc = "Gets the current GPU command buffer.\n # Arguments\n\n* `addr` - Pointer to output the command buffer to.\n * `size` - Pointer to output the size (in words) of the command buffer to.\n * `offset` - Pointer to output the offset of the command buffer to."]
    #[link_name = "GPUCMD_GetBuffer__extern"]
    pub fn GPUCMD_GetBuffer(addr: *mut *mut u32_, size: *mut u32_, offset: *mut u32_);
}
unsafe extern "C" {
    #[doc = "Adds raw GPU commands to the current command buffer.\n # Arguments\n\n* `cmd` - Buffer containing commands to add.\n * `size` - Size of the buffer."]
    pub fn GPUCMD_AddRawCommands(cmd: *const u32_, size: u32_);
}
unsafe extern "C" {
    #[doc = "Adds a GPU command to the current command buffer.\n # Arguments\n\n* `header` - Header of the command.\n * `param` - Parameters of the command.\n * `paramlength` - Size of the parameter buffer."]
    pub fn GPUCMD_Add(header: u32_, param: *const u32_, paramlength: u32_);
}
unsafe extern "C" {
    #[doc = "Splits the current GPU command buffer.\n # Arguments\n\n* `addr` - Pointer to output the command buffer to.\n * `size` - Pointer to output the size (in words) of the command buffer to."]
    pub fn GPUCMD_Split(addr: *mut *mut u32_, size: *mut u32_);
}
unsafe extern "C" {
    #[doc = "Converts a 32-bit float to a 16-bit float.\n # Arguments\n\n* `f` - Float to convert.\n # Returns\n\nThe converted float."]
    pub fn f32tof16(f: f32) -> u32_;
}
unsafe extern "C" {
    #[doc = "Converts a 32-bit float to a 20-bit float.\n # Arguments\n\n* `f` - Float to convert.\n # Returns\n\nThe converted float."]
    pub fn f32tof20(f: f32) -> u32_;
}
unsafe extern "C" {
    #[doc = "Converts a 32-bit float to a 24-bit float.\n # Arguments\n\n* `f` - Float to convert.\n # Returns\n\nThe converted float."]
    pub fn f32tof24(f: f32) -> u32_;
}
unsafe extern "C" {
    #[doc = "Converts a 32-bit float to a 31-bit float.\n # Arguments\n\n* `f` - Float to convert.\n # Returns\n\nThe converted float."]
    pub fn f32tof31(f: f32) -> u32_;
}
unsafe extern "C" {
    #[doc = "Adds a command with a single parameter to the current command buffer."]
    #[link_name = "GPUCMD_AddSingleParam__extern"]
    pub fn GPUCMD_AddSingleParam(header: u32_, param: u32_);
}
#[doc = "< Vertex shader."]
pub const VERTEX_SHDR: DVLE_type = 0;
#[doc = "< Geometry shader."]
pub const GEOMETRY_SHDR: DVLE_type = 1;
#[doc = "DVLE type."]
pub type DVLE_type = ::libc::c_uchar;
#[doc = "< Bool."]
pub const DVLE_CONST_BOOL: DVLE_constantType = 0;
#[doc = "< Unsigned 8-bit integer."]
pub const DVLE_CONST_u8: DVLE_constantType = 1;
#[doc = "< 24-bit float."]
pub const DVLE_CONST_FLOAT24: DVLE_constantType = 2;
#[doc = "Constant type."]
pub type DVLE_constantType = ::libc::c_uchar;
#[doc = "< Position."]
pub const RESULT_POSITION: DVLE_outputAttribute_t = 0;
#[doc = "< Normal Quaternion."]
pub const RESULT_NORMALQUAT: DVLE_outputAttribute_t = 1;
#[doc = "< Color."]
pub const RESULT_COLOR: DVLE_outputAttribute_t = 2;
#[doc = "< Texture coordinate 0."]
pub const RESULT_TEXCOORD0: DVLE_outputAttribute_t = 3;
#[doc = "< Texture coordinate 0 W."]
pub const RESULT_TEXCOORD0W: DVLE_outputAttribute_t = 4;
#[doc = "< Texture coordinate 1."]
pub const RESULT_TEXCOORD1: DVLE_outputAttribute_t = 5;
#[doc = "< Texture coordinate 2."]
pub const RESULT_TEXCOORD2: DVLE_outputAttribute_t = 6;
#[doc = "< View."]
pub const RESULT_VIEW: DVLE_outputAttribute_t = 8;
#[doc = "< Dummy attribute (used as passthrough for geometry shader input)."]
pub const RESULT_DUMMY: DVLE_outputAttribute_t = 9;
#[doc = "Output attribute."]
pub type DVLE_outputAttribute_t = ::libc::c_uchar;
#[doc = "< Point processing mode."]
pub const GSH_POINT: DVLE_geoShaderMode = 0;
#[doc = "< Variable-size primitive processing mode."]
pub const GSH_VARIABLE_PRIM: DVLE_geoShaderMode = 1;
#[doc = "< Fixed-size primitive processing mode."]
pub const GSH_FIXED_PRIM: DVLE_geoShaderMode = 2;
#[doc = "Geometry shader operation modes."]
pub type DVLE_geoShaderMode = ::libc::c_uchar;
#[doc = "DVLP data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLP_s {
    #[doc = "< Code size."]
    pub codeSize: u32_,
    #[doc = "< Code data."]
    pub codeData: *mut u32_,
    #[doc = "< Operand description size."]
    pub opdescSize: u32_,
    #[doc = "< Operand description data."]
    pub opcdescData: *mut u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DVLP_s"][::core::mem::size_of::<DVLP_s>() - 16usize];
    ["Alignment of DVLP_s"][::core::mem::align_of::<DVLP_s>() - 4usize];
    ["Offset of field: DVLP_s::codeSize"][::core::mem::offset_of!(DVLP_s, codeSize) - 0usize];
    ["Offset of field: DVLP_s::codeData"][::core::mem::offset_of!(DVLP_s, codeData) - 4usize];
    ["Offset of field: DVLP_s::opdescSize"][::core::mem::offset_of!(DVLP_s, opdescSize) - 8usize];
    ["Offset of field: DVLP_s::opcdescData"]
        [::core::mem::offset_of!(DVLP_s, opcdescData) - 12usize];
};
impl Default for DVLP_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "DVLE constant entry data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DVLE_constEntry_s {
    #[doc = "< Constant type. See DVLE_constantType"]
    pub type_: u16_,
    #[doc = "< Constant ID."]
    pub id: u16_,
    #[doc = "< Constant data."]
    pub data: [u32_; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DVLE_constEntry_s"][::core::mem::size_of::<DVLE_constEntry_s>() - 20usize];
    ["Alignment of DVLE_constEntry_s"][::core::mem::align_of::<DVLE_constEntry_s>() - 4usize];
    ["Offset of field: DVLE_constEntry_s::type_"]
        [::core::mem::offset_of!(DVLE_constEntry_s, type_) - 0usize];
    ["Offset of field: DVLE_constEntry_s::id"]
        [::core::mem::offset_of!(DVLE_constEntry_s, id) - 2usize];
    ["Offset of field: DVLE_constEntry_s::data"]
        [::core::mem::offset_of!(DVLE_constEntry_s, data) - 4usize];
};
#[doc = "DVLE output entry data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DVLE_outEntry_s {
    #[doc = "< Output type. See DVLE_outputAttribute_t"]
    pub type_: u16_,
    #[doc = "< Output register ID."]
    pub regID: u16_,
    #[doc = "< Output mask."]
    pub mask: u8_,
    #[doc = "< Unknown."]
    pub unk: [u8_; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DVLE_outEntry_s"][::core::mem::size_of::<DVLE_outEntry_s>() - 8usize];
    ["Alignment of DVLE_outEntry_s"][::core::mem::align_of::<DVLE_outEntry_s>() - 2usize];
    ["Offset of field: DVLE_outEntry_s::type_"]
        [::core::mem::offset_of!(DVLE_outEntry_s, type_) - 0usize];
    ["Offset of field: DVLE_outEntry_s::regID"]
        [::core::mem::offset_of!(DVLE_outEntry_s, regID) - 2usize];
    ["Offset of field: DVLE_outEntry_s::mask"]
        [::core::mem::offset_of!(DVLE_outEntry_s, mask) - 4usize];
    ["Offset of field: DVLE_outEntry_s::unk"]
        [::core::mem::offset_of!(DVLE_outEntry_s, unk) - 5usize];
};
#[doc = "DVLE uniform entry data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DVLE_uniformEntry_s {
    #[doc = "< Symbol offset."]
    pub symbolOffset: u32_,
    #[doc = "< Start register."]
    pub startReg: u16_,
    #[doc = "< End register."]
    pub endReg: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DVLE_uniformEntry_s"][::core::mem::size_of::<DVLE_uniformEntry_s>() - 8usize];
    ["Alignment of DVLE_uniformEntry_s"][::core::mem::align_of::<DVLE_uniformEntry_s>() - 4usize];
    ["Offset of field: DVLE_uniformEntry_s::symbolOffset"]
        [::core::mem::offset_of!(DVLE_uniformEntry_s, symbolOffset) - 0usize];
    ["Offset of field: DVLE_uniformEntry_s::startReg"]
        [::core::mem::offset_of!(DVLE_uniformEntry_s, startReg) - 4usize];
    ["Offset of field: DVLE_uniformEntry_s::endReg"]
        [::core::mem::offset_of!(DVLE_uniformEntry_s, endReg) - 6usize];
};
#[doc = "DVLE data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLE_s {
    #[doc = "< DVLE type."]
    pub type_: DVLE_type,
    #[doc = "< true = merge vertex/geometry shader outmaps ('dummy' output attribute is present)."]
    pub mergeOutmaps: bool,
    #[doc = "< Geometry shader operation mode."]
    pub gshMode: DVLE_geoShaderMode,
    #[doc = "< Starting float uniform register number for storing the fixed-size primitive vertex array."]
    pub gshFixedVtxStart: u8_,
    #[doc = "< Number of fully-defined vertices in the variable-size primitive vertex array."]
    pub gshVariableVtxNum: u8_,
    #[doc = "< Number of vertices in the fixed-size primitive vertex array."]
    pub gshFixedVtxNum: u8_,
    #[doc = "< Contained DVLPs."]
    pub dvlp: *mut DVLP_s,
    #[doc = "< Offset of the start of the main function."]
    pub mainOffset: u32_,
    #[doc = "< Offset of the end of the main function."]
    pub endmainOffset: u32_,
    #[doc = "< Constant table size."]
    pub constTableSize: u32_,
    #[doc = "< Constant table data."]
    pub constTableData: *mut DVLE_constEntry_s,
    #[doc = "< Output table size."]
    pub outTableSize: u32_,
    #[doc = "< Output table data."]
    pub outTableData: *mut DVLE_outEntry_s,
    #[doc = "< Uniform table size."]
    pub uniformTableSize: u32_,
    #[doc = "< Uniform table data."]
    pub uniformTableData: *mut DVLE_uniformEntry_s,
    #[doc = "< Symbol table data."]
    pub symbolTableData: *mut ::libc::c_char,
    #[doc = "< Output map mask."]
    pub outmapMask: u8_,
    #[doc = "< Output map data."]
    pub outmapData: [u32_; 8usize],
    #[doc = "< Output map mode."]
    pub outmapMode: u32_,
    #[doc = "< Output map attribute clock."]
    pub outmapClock: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DVLE_s"][::core::mem::size_of::<DVLE_s>() - 92usize];
    ["Alignment of DVLE_s"][::core::mem::align_of::<DVLE_s>() - 4usize];
    ["Offset of field: DVLE_s::type_"][::core::mem::offset_of!(DVLE_s, type_) - 0usize];
    ["Offset of field: DVLE_s::mergeOutmaps"]
        [::core::mem::offset_of!(DVLE_s, mergeOutmaps) - 1usize];
    ["Offset of field: DVLE_s::gshMode"][::core::mem::offset_of!(DVLE_s, gshMode) - 2usize];
    ["Offset of field: DVLE_s::gshFixedVtxStart"]
        [::core::mem::offset_of!(DVLE_s, gshFixedVtxStart) - 3usize];
    ["Offset of field: DVLE_s::gshVariableVtxNum"]
        [::core::mem::offset_of!(DVLE_s, gshVariableVtxNum) - 4usize];
    ["Offset of field: DVLE_s::gshFixedVtxNum"]
        [::core::mem::offset_of!(DVLE_s, gshFixedVtxNum) - 5usize];
    ["Offset of field: DVLE_s::dvlp"][::core::mem::offset_of!(DVLE_s, dvlp) - 8usize];
    ["Offset of field: DVLE_s::mainOffset"][::core::mem::offset_of!(DVLE_s, mainOffset) - 12usize];
    ["Offset of field: DVLE_s::endmainOffset"]
        [::core::mem::offset_of!(DVLE_s, endmainOffset) - 16usize];
    ["Offset of field: DVLE_s::constTableSize"]
        [::core::mem::offset_of!(DVLE_s, constTableSize) - 20usize];
    ["Offset of field: DVLE_s::constTableData"]
        [::core::mem::offset_of!(DVLE_s, constTableData) - 24usize];
    ["Offset of field: DVLE_s::outTableSize"]
        [::core::mem::offset_of!(DVLE_s, outTableSize) - 28usize];
    ["Offset of field: DVLE_s::outTableData"]
        [::core::mem::offset_of!(DVLE_s, outTableData) - 32usize];
    ["Offset of field: DVLE_s::uniformTableSize"]
        [::core::mem::offset_of!(DVLE_s, uniformTableSize) - 36usize];
    ["Offset of field: DVLE_s::uniformTableData"]
        [::core::mem::offset_of!(DVLE_s, uniformTableData) - 40usize];
    ["Offset of field: DVLE_s::symbolTableData"]
        [::core::mem::offset_of!(DVLE_s, symbolTableData) - 44usize];
    ["Offset of field: DVLE_s::outmapMask"][::core::mem::offset_of!(DVLE_s, outmapMask) - 48usize];
    ["Offset of field: DVLE_s::outmapData"][::core::mem::offset_of!(DVLE_s, outmapData) - 52usize];
    ["Offset of field: DVLE_s::outmapMode"][::core::mem::offset_of!(DVLE_s, outmapMode) - 84usize];
    ["Offset of field: DVLE_s::outmapClock"]
        [::core::mem::offset_of!(DVLE_s, outmapClock) - 88usize];
};
impl Default for DVLE_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "DVLB data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLB_s {
    #[doc = "< DVLE count."]
    pub numDVLE: u32_,
    #[doc = "< Primary DVLP."]
    pub DVLP: DVLP_s,
    #[doc = "< Contained DVLE."]
    pub DVLE: *mut DVLE_s,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DVLB_s"][::core::mem::size_of::<DVLB_s>() - 24usize];
    ["Alignment of DVLB_s"][::core::mem::align_of::<DVLB_s>() - 4usize];
    ["Offset of field: DVLB_s::numDVLE"][::core::mem::offset_of!(DVLB_s, numDVLE) - 0usize];
    ["Offset of field: DVLB_s::DVLP"][::core::mem::offset_of!(DVLB_s, DVLP) - 4usize];
    ["Offset of field: DVLB_s::DVLE"][::core::mem::offset_of!(DVLB_s, DVLE) - 20usize];
};
impl Default for DVLB_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = "Parses a shader binary.\n # Arguments\n\n* `shbinData` - Shader binary data.\n * `shbinSize` - Shader binary size.\n # Returns\n\nThe parsed shader binary."]
    pub fn DVLB_ParseFile(shbinData: *mut u32_, shbinSize: u32_) -> *mut DVLB_s;
}
unsafe extern "C" {
    #[doc = "Frees shader binary data.\n # Arguments\n\n* `dvlb` - DVLB to free."]
    pub fn DVLB_Free(dvlb: *mut DVLB_s);
}
unsafe extern "C" {
    #[doc = "Gets a uniform register index from a shader.\n # Arguments\n\n* `dvle` - Shader to get the register from.\n * `name` - Name of the register.\n # Returns\n\nThe uniform register index."]
    pub fn DVLE_GetUniformRegister(dvle: *mut DVLE_s, name: *const ::libc::c_char) -> s8;
}
unsafe extern "C" {
    #[doc = "Generates a shader output map.\n # Arguments\n\n* `dvle` - Shader to generate an output map for."]
    pub fn DVLE_GenerateOutmap(dvle: *mut DVLE_s);
}
#[doc = "24-bit float uniforms."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct float24Uniform_s {
    #[doc = "< Uniform ID."]
    pub id: u32_,
    #[doc = "< Uniform data."]
    pub data: [u32_; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of float24Uniform_s"][::core::mem::size_of::<float24Uniform_s>() - 16usize];
    ["Alignment of float24Uniform_s"][::core::mem::align_of::<float24Uniform_s>() - 4usize];
    ["Offset of field: float24Uniform_s::id"]
        [::core::mem::offset_of!(float24Uniform_s, id) - 0usize];
    ["Offset of field: float24Uniform_s::data"]
        [::core::mem::offset_of!(float24Uniform_s, data) - 4usize];
};
#[doc = "Describes an instance of either a vertex or geometry shader."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shaderInstance_s {
    #[doc = "< Shader DVLE."]
    pub dvle: *mut DVLE_s,
    #[doc = "< Boolean uniforms."]
    pub boolUniforms: u16_,
    #[doc = "< Used boolean uniform mask."]
    pub boolUniformMask: u16_,
    #[doc = "< Integer uniforms."]
    pub intUniforms: [u32_; 4usize],
    #[doc = "< 24-bit float uniforms."]
    pub float24Uniforms: *mut float24Uniform_s,
    #[doc = "< Used integer uniform mask."]
    pub intUniformMask: u8_,
    #[doc = "< Float uniform count."]
    pub numFloat24Uniforms: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of shaderInstance_s"][::core::mem::size_of::<shaderInstance_s>() - 32usize];
    ["Alignment of shaderInstance_s"][::core::mem::align_of::<shaderInstance_s>() - 4usize];
    ["Offset of field: shaderInstance_s::dvle"]
        [::core::mem::offset_of!(shaderInstance_s, dvle) - 0usize];
    ["Offset of field: shaderInstance_s::boolUniforms"]
        [::core::mem::offset_of!(shaderInstance_s, boolUniforms) - 4usize];
    ["Offset of field: shaderInstance_s::boolUniformMask"]
        [::core::mem::offset_of!(shaderInstance_s, boolUniformMask) - 6usize];
    ["Offset of field: shaderInstance_s::intUniforms"]
        [::core::mem::offset_of!(shaderInstance_s, intUniforms) - 8usize];
    ["Offset of field: shaderInstance_s::float24Uniforms"]
        [::core::mem::offset_of!(shaderInstance_s, float24Uniforms) - 24usize];
    ["Offset of field: shaderInstance_s::intUniformMask"]
        [::core::mem::offset_of!(shaderInstance_s, intUniformMask) - 28usize];
    ["Offset of field: shaderInstance_s::numFloat24Uniforms"]
        [::core::mem::offset_of!(shaderInstance_s, numFloat24Uniforms) - 29usize];
};
impl Default for shaderInstance_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Describes an instance of a full shader program."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shaderProgram_s {
    #[doc = "< Vertex shader."]
    pub vertexShader: *mut shaderInstance_s,
    #[doc = "< Geometry shader."]
    pub geometryShader: *mut shaderInstance_s,
    #[doc = "< Geometry shader input permutation."]
    pub geoShaderInputPermutation: [u32_; 2usize],
    #[doc = "< Geometry shader input stride."]
    pub geoShaderInputStride: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of shaderProgram_s"][::core::mem::size_of::<shaderProgram_s>() - 20usize];
    ["Alignment of shaderProgram_s"][::core::mem::align_of::<shaderProgram_s>() - 4usize];
    ["Offset of field: shaderProgram_s::vertexShader"]
        [::core::mem::offset_of!(shaderProgram_s, vertexShader) - 0usize];
    ["Offset of field: shaderProgram_s::geometryShader"]
        [::core::mem::offset_of!(shaderProgram_s, geometryShader) - 4usize];
    ["Offset of field: shaderProgram_s::geoShaderInputPermutation"]
        [::core::mem::offset_of!(shaderProgram_s, geoShaderInputPermutation) - 8usize];
    ["Offset of field: shaderProgram_s::geoShaderInputStride"]
        [::core::mem::offset_of!(shaderProgram_s, geoShaderInputStride) - 16usize];
};
impl Default for shaderProgram_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes a shader instance.\n # Arguments\n\n* `si` - Shader instance to initialize.\n * `dvle` - DVLE to initialize the shader instance with."]
    pub fn shaderInstanceInit(si: *mut shaderInstance_s, dvle: *mut DVLE_s) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Frees a shader instance.\n # Arguments\n\n* `si` - Shader instance to free."]
    pub fn shaderInstanceFree(si: *mut shaderInstance_s) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets a bool uniform of a shader.\n # Arguments\n\n* `si` - Shader instance to use.\n * `id` - ID of the bool uniform.\n * `value` - Value to set."]
    pub fn shaderInstanceSetBool(
        si: *mut shaderInstance_s,
        id: ::libc::c_int,
        value: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Gets a bool uniform of a shader.\n # Arguments\n\n* `si` - Shader instance to use.\n * `id` - ID of the bool uniform.\n * `value` - Pointer to output the value to."]
    pub fn shaderInstanceGetBool(
        si: *mut shaderInstance_s,
        id: ::libc::c_int,
        value: *mut bool,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Gets the location of a shader's uniform.\n # Arguments\n\n* `si` - Shader instance to use.\n * `name` - Name of the uniform."]
    pub fn shaderInstanceGetUniformLocation(
        si: *mut shaderInstance_s,
        name: *const ::libc::c_char,
    ) -> s8;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes a shader program.\n # Arguments\n\n* `sp` - Shader program to initialize."]
    pub fn shaderProgramInit(sp: *mut shaderProgram_s) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Frees a shader program.\n # Arguments\n\n* `sp` - Shader program to free."]
    pub fn shaderProgramFree(sp: *mut shaderProgram_s) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the vertex shader of a shader program.\n # Arguments\n\n* `sp` - Shader program to use.\n * `dvle` - Vertex shader to set."]
    pub fn shaderProgramSetVsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Sets the geometry shader of a shader program.\n # Arguments\n\n* `sp` - Shader program to use.\n * `dvle` - Geometry shader to set.\n * `stride` - Input stride of the shader (pass 0 to match the number of outputs of the vertex shader)."]
    pub fn shaderProgramSetGsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s, stride: u8_) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures the permutation of the input attributes of the geometry shader of a shader program.\n # Arguments\n\n* `sp` - Shader program to use.\n * `permutation` - Attribute permutation to use."]
    pub fn shaderProgramSetGshInputPermutation(
        sp: *mut shaderProgram_s,
        permutation: u64_,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Configures the shader units to use the specified shader program.\n # Arguments\n\n* `sp` - Shader program to use.\n * `sendVshCode` - When true, the vertex shader's code and operand descriptors are uploaded.\n * `sendGshCode` - When true, the geometry shader's code and operand descriptors are uploaded."]
    pub fn shaderProgramConfigure(
        sp: *mut shaderProgram_s,
        sendVshCode: bool,
        sendGshCode: bool,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Same as shaderProgramConfigure, but always loading code/operand descriptors and uploading DVLE constants afterwards.\n # Arguments\n\n* `sp` - Shader program to use."]
    pub fn shaderProgramUse(sp: *mut shaderProgram_s) -> Result;
}
#[doc = "< Mono sound"]
pub const NDSP_OUTPUT_MONO: ndspOutputMode = 0;
#[doc = "< Stereo sound"]
pub const NDSP_OUTPUT_STEREO: ndspOutputMode = 1;
#[doc = "< 3D Surround sound"]
pub const NDSP_OUTPUT_SURROUND: ndspOutputMode = 2;
#[doc = "Data types\n# Sound output modes."]
pub type ndspOutputMode = ::libc::c_uchar;
#[doc = "< \"Normal\" clipping mode (?)"]
pub const NDSP_CLIP_NORMAL: ndspClippingMode = 0;
#[doc = "< \"Soft\" clipping mode (?)"]
pub const NDSP_CLIP_SOFT: ndspClippingMode = 1;
pub type ndspClippingMode = ::libc::c_uchar;
#[doc = "<?"]
pub const NDSP_SPKPOS_SQUARE: ndspSpeakerPos = 0;
#[doc = "<?"]
pub const NDSP_SPKPOS_WIDE: ndspSpeakerPos = 1;
#[doc = "<?"]
pub const NDSP_SPKPOS_NUM: ndspSpeakerPos = 2;
pub type ndspSpeakerPos = ::libc::c_uchar;
#[doc = "ADPCM data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ndspAdpcmData {
    #[doc = "< Current predictor index"]
    pub index: u16_,
    #[doc = "< Last outputted PCM16 sample."]
    pub history0: s16,
    #[doc = "< Second to last outputted PCM16 sample."]
    pub history1: s16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ndspAdpcmData"][::core::mem::size_of::<ndspAdpcmData>() - 6usize];
    ["Alignment of ndspAdpcmData"][::core::mem::align_of::<ndspAdpcmData>() - 2usize];
    ["Offset of field: ndspAdpcmData::index"]
        [::core::mem::offset_of!(ndspAdpcmData, index) - 0usize];
    ["Offset of field: ndspAdpcmData::history0"]
        [::core::mem::offset_of!(ndspAdpcmData, history0) - 2usize];
    ["Offset of field: ndspAdpcmData::history1"]
        [::core::mem::offset_of!(ndspAdpcmData, history1) - 4usize];
};
#[doc = "Wave buffer type."]
pub type ndspWaveBuf = tag_ndspWaveBuf;
#[doc = "< The wave buffer is not queued."]
pub const NDSP_WBUF_FREE: _bindgen_ty_30 = 0;
#[doc = "< The wave buffer is queued and has not been played yet."]
pub const NDSP_WBUF_QUEUED: _bindgen_ty_30 = 1;
#[doc = "< The wave buffer is playing right now."]
pub const NDSP_WBUF_PLAYING: _bindgen_ty_30 = 2;
#[doc = "< The wave buffer has finished being played."]
pub const NDSP_WBUF_DONE: _bindgen_ty_30 = 3;
#[doc = "Wave buffer status."]
pub type _bindgen_ty_30 = ::libc::c_uchar;
#[doc = "Wave buffer struct."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tag_ndspWaveBuf {
    pub __bindgen_anon_1: tag_ndspWaveBuf__bindgen_ty_1,
    #[doc = "< Total number of samples (PCM8=bytes, PCM16=halfwords, DSPADPCM=nibbles without frame headers)"]
    pub nsamples: u32_,
    #[doc = "< ADPCM data."]
    pub adpcm_data: *mut ndspAdpcmData,
    #[doc = "< Buffer offset. Only used for capture."]
    pub offset: u32_,
    #[doc = "< Whether to loop the buffer."]
    pub looping: bool,
    #[doc = "< Queuing/playback status."]
    pub status: u8_,
    #[doc = "< Sequence ID. Assigned automatically by ndspChnWaveBufAdd."]
    pub sequence_id: u16_,
    #[doc = "< Next buffer to play. Used internally, do not modify."]
    pub next: *mut ndspWaveBuf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tag_ndspWaveBuf__bindgen_ty_1 {
    #[doc = "< Pointer to PCM8 sample data."]
    pub data_pcm8: *mut s8,
    #[doc = "< Pointer to PCM16 sample data."]
    pub data_pcm16: *mut s16,
    #[doc = "< Pointer to DSPADPCM sample data."]
    pub data_adpcm: *mut u8_,
    #[doc = "< Data virtual address."]
    pub data_vaddr: *const ::libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tag_ndspWaveBuf__bindgen_ty_1"]
        [::core::mem::size_of::<tag_ndspWaveBuf__bindgen_ty_1>() - 4usize];
    ["Alignment of tag_ndspWaveBuf__bindgen_ty_1"]
        [::core::mem::align_of::<tag_ndspWaveBuf__bindgen_ty_1>() - 4usize];
    ["Offset of field: tag_ndspWaveBuf__bindgen_ty_1::data_pcm8"]
        [::core::mem::offset_of!(tag_ndspWaveBuf__bindgen_ty_1, data_pcm8) - 0usize];
    ["Offset of field: tag_ndspWaveBuf__bindgen_ty_1::data_pcm16"]
        [::core::mem::offset_of!(tag_ndspWaveBuf__bindgen_ty_1, data_pcm16) - 0usize];
    ["Offset of field: tag_ndspWaveBuf__bindgen_ty_1::data_adpcm"]
        [::core::mem::offset_of!(tag_ndspWaveBuf__bindgen_ty_1, data_adpcm) - 0usize];
    ["Offset of field: tag_ndspWaveBuf__bindgen_ty_1::data_vaddr"]
        [::core::mem::offset_of!(tag_ndspWaveBuf__bindgen_ty_1, data_vaddr) - 0usize];
};
impl Default for tag_ndspWaveBuf__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tag_ndspWaveBuf"][::core::mem::size_of::<tag_ndspWaveBuf>() - 24usize];
    ["Alignment of tag_ndspWaveBuf"][::core::mem::align_of::<tag_ndspWaveBuf>() - 4usize];
    ["Offset of field: tag_ndspWaveBuf::nsamples"]
        [::core::mem::offset_of!(tag_ndspWaveBuf, nsamples) - 4usize];
    ["Offset of field: tag_ndspWaveBuf::adpcm_data"]
        [::core::mem::offset_of!(tag_ndspWaveBuf, adpcm_data) - 8usize];
    ["Offset of field: tag_ndspWaveBuf::offset"]
        [::core::mem::offset_of!(tag_ndspWaveBuf, offset) - 12usize];
    ["Offset of field: tag_ndspWaveBuf::looping"]
        [::core::mem::offset_of!(tag_ndspWaveBuf, looping) - 16usize];
    ["Offset of field: tag_ndspWaveBuf::status"]
        [::core::mem::offset_of!(tag_ndspWaveBuf, status) - 17usize];
    ["Offset of field: tag_ndspWaveBuf::sequence_id"]
        [::core::mem::offset_of!(tag_ndspWaveBuf, sequence_id) - 18usize];
    ["Offset of field: tag_ndspWaveBuf::next"]
        [::core::mem::offset_of!(tag_ndspWaveBuf, next) - 20usize];
};
impl Default for tag_ndspWaveBuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Sound frame callback function. (data = User provided data)"]
pub type ndspCallback = ::core::option::Option<unsafe extern "C" fn(data: *mut ::libc::c_void)>;
#[doc = "Auxiliary output callback function. (data = User provided data, nsamples = Number of samples, samples = Sample data)"]
pub type ndspAuxCallback = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut ::libc::c_void,
        nsamples: ::libc::c_int,
        samples: *mut *mut ::libc::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = "Initialization and basic operations\n# *\n* Sets up the DSP component.\n # Arguments\n\n* `binary` - DSP binary to load.\n * `size` - Size of the DSP binary.\n * `progMask` - Program RAM block mask to load the binary to.\n * `dataMask` - Data RAM block mask to load the binary to.\n/"]
    pub fn ndspUseComponent(
        binary: *const ::libc::c_void,
        size: u32_,
        progMask: u16_,
        dataMask: u16_,
    );
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Initializes NDSP."]
    pub fn ndspInit() -> Result;
}
unsafe extern "C" {
    #[doc = "Exits NDSP."]
    pub fn ndspExit();
}
unsafe extern "C" {
    #[doc = "Gets the number of dropped sound frames.\n # Returns\n\nThe number of dropped sound frames."]
    pub fn ndspGetDroppedFrames() -> u32_;
}
unsafe extern "C" {
    #[doc = "Gets the total sound frame count.\n # Returns\n\nThe total sound frame count."]
    pub fn ndspGetFrameCount() -> u32_;
}
unsafe extern "C" {
    #[doc = "General parameters\n# *\n* Sets the master volume.\n # Arguments\n\n* `volume` - Volume to set. Defaults to 1.0f.\n/"]
    pub fn ndspSetMasterVol(volume: f32);
}
unsafe extern "C" {
    #[doc = "Gets the master volume.\n # Returns\n\nThe master volume."]
    pub fn ndspGetMasterVol() -> f32;
}
unsafe extern "C" {
    #[doc = "Sets the output mode.\n # Arguments\n\n* `mode` - Output mode to set. Defaults to NDSP_OUTPUT_STEREO."]
    pub fn ndspSetOutputMode(mode: ndspOutputMode);
}
unsafe extern "C" {
    #[doc = "Gets the output mode.\n # Returns\n\nThe output mode."]
    pub fn ndspGetOutputMode() -> ndspOutputMode;
}
unsafe extern "C" {
    #[doc = "Sets the clipping mode.\n # Arguments\n\n* `mode` - Clipping mode to set. Defaults to NDSP_CLIP_SOFT."]
    pub fn ndspSetClippingMode(mode: ndspClippingMode);
}
unsafe extern "C" {
    #[doc = "Gets the clipping mode.\n # Returns\n\nThe clipping mode."]
    pub fn ndspGetClippingMode() -> ndspClippingMode;
}
unsafe extern "C" {
    #[doc = "Sets the output count.\n # Arguments\n\n* `count` - Output count to set. Defaults to 2."]
    pub fn ndspSetOutputCount(count: ::libc::c_int);
}
unsafe extern "C" {
    #[doc = "Gets the output count.\n # Returns\n\nThe output count."]
    pub fn ndspGetOutputCount() -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Sets the wave buffer to capture audio to.\n # Arguments\n\n* `capture` - Wave buffer to capture to."]
    pub fn ndspSetCapture(capture: *mut ndspWaveBuf);
}
unsafe extern "C" {
    #[doc = "Sets the sound frame callback.\n # Arguments\n\n* `callback` - Callback to set.\n * `data` - User-defined data to pass to the callback."]
    pub fn ndspSetCallback(callback: ndspCallback, data: *mut ::libc::c_void);
}
unsafe extern "C" {
    #[doc = "Surround\n# *\n* Sets the surround sound depth.\n # Arguments\n\n* `depth` - Depth to set. Defaults to 0x7FFF.\n/"]
    pub fn ndspSurroundSetDepth(depth: u16_);
}
unsafe extern "C" {
    #[doc = "Gets the surround sound depth.\n # Returns\n\nThe surround sound depth."]
    pub fn ndspSurroundGetDepth() -> u16_;
}
unsafe extern "C" {
    #[doc = "Sets the surround sound position.\n # Arguments\n\n* `pos` - Position to set. Defaults to NDSP_SPKPOS_SQUARE."]
    pub fn ndspSurroundSetPos(pos: ndspSpeakerPos);
}
unsafe extern "C" {
    #[doc = "Gets the surround sound position.\n # Returns\n\nThe surround sound speaker position."]
    pub fn ndspSurroundGetPos() -> ndspSpeakerPos;
}
unsafe extern "C" {
    #[doc = "Sets the surround sound rear ratio.\n # Arguments\n\n* `ratio` - Rear ratio to set. Defaults to 0x8000."]
    pub fn ndspSurroundSetRearRatio(ratio: u16_);
}
unsafe extern "C" {
    #[doc = "Gets the surround sound rear ratio.\n # Returns\n\nThe rear ratio."]
    pub fn ndspSurroundGetRearRatio() -> u16_;
}
unsafe extern "C" {
    #[doc = "Auxiliary output\n# *\n* Configures whether an auxiliary output is enabled.\n # Arguments\n\n* `id` - ID of the auxiliary output.\n * `enable` - Whether to enable the auxiliary output.\n/"]
    pub fn ndspAuxSetEnable(id: ::libc::c_int, enable: bool);
}
unsafe extern "C" {
    #[doc = "Gets whether auxiliary output is enabled.\n # Arguments\n\n* `id` - ID of the auxiliary output.\n # Returns\n\nWhether auxiliary output is enabled."]
    pub fn ndspAuxIsEnabled(id: ::libc::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = "Configures whether an auxiliary output should use front bypass.\n # Arguments\n\n* `id` - ID of the auxiliary output.\n * `bypass` - Whether to use front bypass."]
    pub fn ndspAuxSetFrontBypass(id: ::libc::c_int, bypass: bool);
}
unsafe extern "C" {
    #[doc = "Gets whether auxiliary output front bypass is enabled.\n # Arguments\n\n* `id` - ID of the auxiliary output.\n # Returns\n\nWhether auxiliary output front bypass is enabled."]
    pub fn ndspAuxGetFrontBypass(id: ::libc::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = "Sets the volume of an auxiliary output.\n # Arguments\n\n* `id` - ID of the auxiliary output.\n * `volume` - Volume to set."]
    pub fn ndspAuxSetVolume(id: ::libc::c_int, volume: f32);
}
unsafe extern "C" {
    #[doc = "Gets the volume of an auxiliary output.\n # Arguments\n\n* `id` - ID of the auxiliary output.\n # Returns\n\nVolume of the auxiliary output."]
    pub fn ndspAuxGetVolume(id: ::libc::c_int) -> f32;
}
unsafe extern "C" {
    #[doc = "Sets the callback of an auxiliary output.\n # Arguments\n\n* `id` - ID of the auxiliary output.\n * `callback` - Callback to set.\n * `data` - User-defined data to pass to the callback."]
    pub fn ndspAuxSetCallback(
        id: ::libc::c_int,
        callback: ndspAuxCallback,
        data: *mut ::libc::c_void,
    );
}
#[doc = "< PCM8"]
pub const NDSP_ENCODING_PCM8: _bindgen_ty_31 = 0;
#[doc = "< PCM16"]
pub const NDSP_ENCODING_PCM16: _bindgen_ty_31 = 1;
#[doc = "< DSPADPCM (GameCube format)"]
pub const NDSP_ENCODING_ADPCM: _bindgen_ty_31 = 2;
#[doc = "Data types\n# Supported sample encodings."]
pub type _bindgen_ty_31 = ::libc::c_uchar;
#[doc = "< Buffer contains Mono PCM8."]
pub const NDSP_FORMAT_MONO_PCM8: _bindgen_ty_32 = 1;
#[doc = "< Buffer contains Mono PCM16."]
pub const NDSP_FORMAT_MONO_PCM16: _bindgen_ty_32 = 5;
#[doc = "< Buffer contains Mono ADPCM."]
pub const NDSP_FORMAT_MONO_ADPCM: _bindgen_ty_32 = 9;
#[doc = "< Buffer contains Stereo PCM8."]
pub const NDSP_FORMAT_STEREO_PCM8: _bindgen_ty_32 = 2;
#[doc = "< Buffer contains Stereo PCM16."]
pub const NDSP_FORMAT_STEREO_PCM16: _bindgen_ty_32 = 6;
#[doc = "< (Alias) Buffer contains Mono PCM8."]
pub const NDSP_FORMAT_PCM8: _bindgen_ty_32 = 1;
#[doc = "< (Alias) Buffer contains Mono PCM16."]
pub const NDSP_FORMAT_PCM16: _bindgen_ty_32 = 5;
#[doc = "< (Alias) Buffer contains Mono ADPCM."]
pub const NDSP_FORMAT_ADPCM: _bindgen_ty_32 = 9;
#[doc = "< Front bypass."]
pub const NDSP_FRONT_BYPASS: _bindgen_ty_32 = 16;
#[doc = "< (?) Unknown, under research"]
pub const NDSP_3D_SURROUND_PREPROCESSED: _bindgen_ty_32 = 64;
#[doc = "Channel format flags for use with ndspChnSetFormat."]
pub type _bindgen_ty_32 = ::libc::c_uchar;
#[doc = "< Polyphase interpolation"]
pub const NDSP_INTERP_POLYPHASE: ndspInterpType = 0;
#[doc = "< Linear interpolation"]
pub const NDSP_INTERP_LINEAR: ndspInterpType = 1;
#[doc = "< No interpolation"]
pub const NDSP_INTERP_NONE: ndspInterpType = 2;
#[doc = "Interpolation types."]
pub type ndspInterpType = ::libc::c_uchar;
unsafe extern "C" {
    #[doc = "Basic channel operation\n# *\n* Resets a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n/"]
    pub fn ndspChnReset(id: ::libc::c_int);
}
unsafe extern "C" {
    #[doc = "Initializes the parameters of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23)."]
    pub fn ndspChnInitParams(id: ::libc::c_int);
}
unsafe extern "C" {
    #[doc = "Checks whether a channel is currently playing.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n # Returns\n\nWhether the channel is currently playing."]
    pub fn ndspChnIsPlaying(id: ::libc::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = "Gets the current sample position of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n # Returns\n\nThe channel's sample position."]
    pub fn ndspChnGetSamplePos(id: ::libc::c_int) -> u32_;
}
unsafe extern "C" {
    #[doc = "Gets the sequence ID of the wave buffer that is currently playing in a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n # Returns\n\nThe sequence ID of the wave buffer."]
    pub fn ndspChnGetWaveBufSeq(id: ::libc::c_int) -> u16_;
}
unsafe extern "C" {
    #[doc = "Checks whether a channel is currently paused.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n # Returns\n\nWhether the channel is currently paused."]
    pub fn ndspChnIsPaused(id: ::libc::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = "Sets the pause status of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `paused` - Whether the channel is to be paused (true) or unpaused (false)."]
    pub fn ndspChnSetPaused(id: ::libc::c_int, paused: bool);
}
unsafe extern "C" {
    #[doc = "Configuration\n# *\n* Sets the format of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `format` - Format to use.\n/"]
    pub fn ndspChnSetFormat(id: ::libc::c_int, format: u16_);
}
unsafe extern "C" {
    #[doc = "Gets the format of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n # Returns\n\nThe format of the channel."]
    pub fn ndspChnGetFormat(id: ::libc::c_int) -> u16_;
}
unsafe extern "C" {
    #[doc = "Sets the interpolation type of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `type` - Interpolation type to use."]
    pub fn ndspChnSetInterp(id: ::libc::c_int, type_: ndspInterpType);
}
unsafe extern "C" {
    #[doc = "Gets the interpolation type of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n # Returns\n\nThe interpolation type of the channel."]
    pub fn ndspChnGetInterp(id: ::libc::c_int) -> ndspInterpType;
}
unsafe extern "C" {
    #[doc = "Sets the sample rate of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `rate` - Sample rate to use."]
    pub fn ndspChnSetRate(id: ::libc::c_int, rate: f32);
}
unsafe extern "C" {
    #[doc = "Gets the sample rate of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n # Returns\n\nThe sample rate of the channel."]
    pub fn ndspChnGetRate(id: ::libc::c_int) -> f32;
}
unsafe extern "C" {
    #[doc = "Sets the mix parameters (volumes) of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `mix` - Mix parameters to use. Working hypothesis:\n - 0: Front left volume.\n - 1: Front right volume.\n - 2: Back left volume:\n - 3: Back right volume:\n - 4..7: Same as 0..3, but for auxiliary output 0.\n - 8..11: Same as 0..3, but for auxiliary output 1."]
    pub fn ndspChnSetMix(id: ::libc::c_int, mix: *mut f32);
}
unsafe extern "C" {
    #[doc = "Gets the mix parameters (volumes) of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23)\n * `mix` - Mix parameters to write out to. See ndspChnSetMix."]
    pub fn ndspChnGetMix(id: ::libc::c_int, mix: *mut f32);
}
unsafe extern "C" {
    #[doc = "Sets the DSPADPCM coefficients of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `coefs` - DSPADPCM coefficients to use."]
    pub fn ndspChnSetAdpcmCoefs(id: ::libc::c_int, coefs: *mut u16_);
}
unsafe extern "C" {
    #[doc = "Wave buffers\n# *\n* Clears the wave buffer queue of a channel and stops playback.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n/"]
    pub fn ndspChnWaveBufClear(id: ::libc::c_int);
}
unsafe extern "C" {
    #[doc = "Adds a wave buffer to the wave buffer queue of a channel.\n > If the channel's wave buffer queue was empty before the use of this function, playback is started.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `buf` - Wave buffer to add."]
    pub fn ndspChnWaveBufAdd(id: ::libc::c_int, buf: *mut ndspWaveBuf);
}
unsafe extern "C" {
    #[doc = "IIR filters\n# *\n* Configures whether the IIR monopole filter of a channel is enabled.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `enable` - Whether to enable the IIR monopole filter.\n/"]
    pub fn ndspChnIirMonoSetEnable(id: ::libc::c_int, enable: bool);
}
unsafe extern "C" {
    #[doc = "Manually sets up the parameters on monopole filter\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `enable` - Whether to enable the IIR monopole filter."]
    pub fn ndspChnIirMonoSetParamsCustomFilter(
        id: ::libc::c_int,
        a0: f32,
        a1: f32,
        b0: f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Sets the monopole to be a low pass filter. (Note: This is a lower-quality filter than the biquad one.)\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `f0` - Low pass cut-off frequency."]
    pub fn ndspChnIirMonoSetParamsLowPassFilter(id: ::libc::c_int, f0: f32) -> bool;
}
unsafe extern "C" {
    #[doc = "Sets the monopole to be a high pass filter. (Note: This is a lower-quality filter than the biquad one.)\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `f0` - High pass cut-off frequency."]
    pub fn ndspChnIirMonoSetParamsHighPassFilter(id: ::libc::c_int, f0: f32) -> bool;
}
unsafe extern "C" {
    #[doc = "Configures whether the IIR biquad filter of a channel is enabled.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `enable` - Whether to enable the IIR biquad filter."]
    pub fn ndspChnIirBiquadSetEnable(id: ::libc::c_int, enable: bool);
}
unsafe extern "C" {
    #[doc = "Manually sets up the parameters of the biquad filter\n # Arguments\n\n* `id` - ID of the channel (0..23)."]
    pub fn ndspChnIirBiquadSetParamsCustomFilter(
        id: ::libc::c_int,
        a0: f32,
        a1: f32,
        a2: f32,
        b0: f32,
        b1: f32,
        b2: f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Sets the biquad to be a low pass filter.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `f0` - Low pass cut-off frequency.\n * `Q` - \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071)."]
    pub fn ndspChnIirBiquadSetParamsLowPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
unsafe extern "C" {
    #[doc = "Sets the biquad to be a high pass filter.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `f0` - High pass cut-off frequency.\n * `Q` - \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071)."]
    pub fn ndspChnIirBiquadSetParamsHighPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
unsafe extern "C" {
    #[doc = "Sets the biquad to be a band pass filter.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `f0` - Mid-frequency.\n * `Q` - \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071)."]
    pub fn ndspChnIirBiquadSetParamsBandPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
unsafe extern "C" {
    #[doc = "Sets the biquad to be a notch filter.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `f0` - Notch frequency.\n * `Q` - \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071)."]
    pub fn ndspChnIirBiquadSetParamsNotchFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
unsafe extern "C" {
    #[doc = "Sets the biquad to be a peaking equalizer.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `f0` - Central frequency.\n * `Q` - \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071).\n * `gain` - Amount of gain (raw value = 10 ^ dB/40)"]
    pub fn ndspChnIirBiquadSetParamsPeakingEqualizer(
        id: ::libc::c_int,
        f0: f32,
        Q: f32,
        gain: f32,
    ) -> bool;
}
#[doc = "< Normal keyboard with several pages (QWERTY/accents/symbol/mobile)"]
pub const SWKBD_TYPE_NORMAL: SwkbdType = 0;
#[doc = "< QWERTY keyboard only."]
pub const SWKBD_TYPE_QWERTY: SwkbdType = 1;
#[doc = "< Number pad."]
pub const SWKBD_TYPE_NUMPAD: SwkbdType = 2;
#[doc = "< On JPN systems, a text keyboard without Japanese input capabilities, otherwise same as SWKBD_TYPE_NORMAL."]
pub const SWKBD_TYPE_WESTERN: SwkbdType = 3;
#[doc = "Keyboard types."]
pub type SwkbdType = ::libc::c_uchar;
#[doc = "< All inputs are accepted."]
pub const SWKBD_ANYTHING: SwkbdValidInput = 0;
#[doc = "< Empty inputs are not accepted."]
pub const SWKBD_NOTEMPTY: SwkbdValidInput = 1;
#[doc = "< Empty or blank inputs (consisting solely of whitespace) are not accepted."]
pub const SWKBD_NOTEMPTY_NOTBLANK: SwkbdValidInput = 2;
pub const SWKBD_NOTBLANK_NOTEMPTY: SwkbdValidInput = 2;
#[doc = "< Blank inputs (consisting solely of whitespace) are not accepted, but empty inputs are."]
pub const SWKBD_NOTBLANK: SwkbdValidInput = 3;
#[doc = "< The input must have a fixed length (specified by maxTextLength in swkbdInit)."]
pub const SWKBD_FIXEDLEN: SwkbdValidInput = 4;
#[doc = "Accepted input types."]
pub type SwkbdValidInput = ::libc::c_uchar;
#[doc = "< Left button (usually Cancel)"]
pub const SWKBD_BUTTON_LEFT: SwkbdButton = 0;
#[doc = "< Middle button (usually I Forgot)"]
pub const SWKBD_BUTTON_MIDDLE: SwkbdButton = 1;
#[doc = "< Right button (usually OK)"]
pub const SWKBD_BUTTON_RIGHT: SwkbdButton = 2;
pub const SWKBD_BUTTON_CONFIRM: SwkbdButton = 2;
#[doc = "< No button (returned by swkbdInputText in special cases)"]
pub const SWKBD_BUTTON_NONE: SwkbdButton = 3;
#[doc = "Keyboard dialog buttons."]
pub type SwkbdButton = ::libc::c_uchar;
#[doc = "< Characters are not concealed."]
pub const SWKBD_PASSWORD_NONE: SwkbdPasswordMode = 0;
#[doc = "< Characters are concealed immediately."]
pub const SWKBD_PASSWORD_HIDE: SwkbdPasswordMode = 1;
#[doc = "< Characters are concealed a second after they've been typed."]
pub const SWKBD_PASSWORD_HIDE_DELAY: SwkbdPasswordMode = 2;
#[doc = "Keyboard password modes."]
pub type SwkbdPasswordMode = ::libc::c_uchar;
#[doc = "< Disallow the use of more than a certain number of digits (0 or more)"]
pub const SWKBD_FILTER_DIGITS: _bindgen_ty_33 = 1;
#[doc = "< Disallow the use of the  sign."]
pub const SWKBD_FILTER_AT: _bindgen_ty_33 = 2;
#[doc = "< Disallow the use of the % sign."]
pub const SWKBD_FILTER_PERCENT: _bindgen_ty_33 = 4;
#[doc = "< Disallow the use of the  sign."]
pub const SWKBD_FILTER_BACKSLASH: _bindgen_ty_33 = 8;
#[doc = "< Disallow profanity using Nintendo's profanity filter."]
pub const SWKBD_FILTER_PROFANITY: _bindgen_ty_33 = 16;
#[doc = "< Use a callback in order to check the input."]
pub const SWKBD_FILTER_CALLBACK: _bindgen_ty_33 = 32;
#[doc = "Keyboard input filtering flags."]
pub type _bindgen_ty_33 = ::libc::c_uchar;
#[doc = "< Parental PIN mode."]
pub const SWKBD_PARENTAL: _bindgen_ty_34 = 1;
#[doc = "< Darken the top screen when the keyboard is shown."]
pub const SWKBD_DARKEN_TOP_SCREEN: _bindgen_ty_34 = 2;
#[doc = "< Enable predictive input (necessary for Kanji input in JPN systems)."]
pub const SWKBD_PREDICTIVE_INPUT: _bindgen_ty_34 = 4;
#[doc = "< Enable multiline input."]
pub const SWKBD_MULTILINE: _bindgen_ty_34 = 8;
#[doc = "< Enable fixed-width mode."]
pub const SWKBD_FIXED_WIDTH: _bindgen_ty_34 = 16;
#[doc = "< Allow the usage of the HOME button."]
pub const SWKBD_ALLOW_HOME: _bindgen_ty_34 = 32;
#[doc = "< Allow the usage of a software-reset combination."]
pub const SWKBD_ALLOW_RESET: _bindgen_ty_34 = 64;
#[doc = "< Allow the usage of the POWER button."]
pub const SWKBD_ALLOW_POWER: _bindgen_ty_34 = 128;
#[doc = "< Default to the QWERTY page when the keyboard is shown."]
pub const SWKBD_DEFAULT_QWERTY: _bindgen_ty_34 = 512;
#[doc = "Keyboard features."]
pub type _bindgen_ty_34 = ::libc::c_ushort;
#[doc = "< Specifies that the input is valid."]
pub const SWKBD_CALLBACK_OK: SwkbdCallbackResult = 0;
#[doc = "< Displays an error message, then closes the keyboard."]
pub const SWKBD_CALLBACK_CLOSE: SwkbdCallbackResult = 1;
#[doc = "< Displays an error message and continues displaying the keyboard."]
pub const SWKBD_CALLBACK_CONTINUE: SwkbdCallbackResult = 2;
#[doc = "Keyboard filter callback return values."]
pub type SwkbdCallbackResult = ::libc::c_uchar;
#[doc = "< Dummy/unused."]
pub const SWKBD_NONE: SwkbdResult = -1;
#[doc = "< Invalid parameters to swkbd."]
pub const SWKBD_INVALID_INPUT: SwkbdResult = -2;
#[doc = "< Out of memory."]
pub const SWKBD_OUTOFMEM: SwkbdResult = -3;
#[doc = "< The button was clicked in 1-button dialogs."]
pub const SWKBD_D0_CLICK: SwkbdResult = 0;
#[doc = "< The left button was clicked in 2-button dialogs."]
pub const SWKBD_D1_CLICK0: SwkbdResult = 1;
#[doc = "< The right button was clicked in 2-button dialogs."]
pub const SWKBD_D1_CLICK1: SwkbdResult = 2;
#[doc = "< The left button was clicked in 3-button dialogs."]
pub const SWKBD_D2_CLICK0: SwkbdResult = 3;
#[doc = "< The middle button was clicked in 3-button dialogs."]
pub const SWKBD_D2_CLICK1: SwkbdResult = 4;
#[doc = "< The right button was clicked in 3-button dialogs."]
pub const SWKBD_D2_CLICK2: SwkbdResult = 5;
#[doc = "< The HOME button was pressed."]
pub const SWKBD_HOMEPRESSED: SwkbdResult = 10;
#[doc = "< The soft-reset key combination was pressed."]
pub const SWKBD_RESETPRESSED: SwkbdResult = 11;
#[doc = "< The POWER button was pressed."]
pub const SWKBD_POWERPRESSED: SwkbdResult = 12;
#[doc = "< The parental PIN was verified successfully."]
pub const SWKBD_PARENTAL_OK: SwkbdResult = 20;
#[doc = "< The parental PIN was incorrect."]
pub const SWKBD_PARENTAL_FAIL: SwkbdResult = 21;
#[doc = "< The filter callback returned SWKBD_CALLBACK_CLOSE."]
pub const SWKBD_BANNED_INPUT: SwkbdResult = 30;
#[doc = "Keyboard return values."]
pub type SwkbdResult = ::libc::c_schar;
#[doc = "Keyboard dictionary word for predictive input."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwkbdDictWord {
    #[doc = "< Reading of the word (that is, the string that needs to be typed)."]
    pub reading: [u16_; 41usize],
    #[doc = "< Spelling of the word."]
    pub word: [u16_; 41usize],
    #[doc = "< Language the word applies to."]
    pub language: u8_,
    #[doc = "< Specifies if the word applies to all languages."]
    pub all_languages: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SwkbdDictWord"][::core::mem::size_of::<SwkbdDictWord>() - 166usize];
    ["Alignment of SwkbdDictWord"][::core::mem::align_of::<SwkbdDictWord>() - 2usize];
    ["Offset of field: SwkbdDictWord::reading"]
        [::core::mem::offset_of!(SwkbdDictWord, reading) - 0usize];
    ["Offset of field: SwkbdDictWord::word"]
        [::core::mem::offset_of!(SwkbdDictWord, word) - 82usize];
    ["Offset of field: SwkbdDictWord::language"]
        [::core::mem::offset_of!(SwkbdDictWord, language) - 164usize];
    ["Offset of field: SwkbdDictWord::all_languages"]
        [::core::mem::offset_of!(SwkbdDictWord, all_languages) - 165usize];
};
impl Default for SwkbdDictWord {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Keyboard filter callback function."]
pub type SwkbdCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        user: *mut ::libc::c_void,
        ppMessage: *mut *const ::libc::c_char,
        text: *const ::libc::c_char,
        textlen: usize,
    ) -> SwkbdCallbackResult,
>;
#[doc = "Keyboard status data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SwkbdStatusData {
    pub data: [u32_; 17usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SwkbdStatusData"][::core::mem::size_of::<SwkbdStatusData>() - 68usize];
    ["Alignment of SwkbdStatusData"][::core::mem::align_of::<SwkbdStatusData>() - 4usize];
    ["Offset of field: SwkbdStatusData::data"]
        [::core::mem::offset_of!(SwkbdStatusData, data) - 0usize];
};
#[doc = "Keyboard predictive input learning data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwkbdLearningData {
    pub data: [u32_; 10523usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SwkbdLearningData"][::core::mem::size_of::<SwkbdLearningData>() - 42092usize];
    ["Alignment of SwkbdLearningData"][::core::mem::align_of::<SwkbdLearningData>() - 4usize];
    ["Offset of field: SwkbdLearningData::data"]
        [::core::mem::offset_of!(SwkbdLearningData, data) - 0usize];
};
impl Default for SwkbdLearningData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Internal libctru book-keeping structure for software keyboards."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwkbdExtra {
    pub initial_text: *const ::libc::c_char,
    pub dict: *const SwkbdDictWord,
    pub status_data: *mut SwkbdStatusData,
    pub learning_data: *mut SwkbdLearningData,
    pub callback: SwkbdCallbackFn,
    pub callback_user: *mut ::libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SwkbdExtra"][::core::mem::size_of::<SwkbdExtra>() - 24usize];
    ["Alignment of SwkbdExtra"][::core::mem::align_of::<SwkbdExtra>() - 4usize];
    ["Offset of field: SwkbdExtra::initial_text"]
        [::core::mem::offset_of!(SwkbdExtra, initial_text) - 0usize];
    ["Offset of field: SwkbdExtra::dict"][::core::mem::offset_of!(SwkbdExtra, dict) - 4usize];
    ["Offset of field: SwkbdExtra::status_data"]
        [::core::mem::offset_of!(SwkbdExtra, status_data) - 8usize];
    ["Offset of field: SwkbdExtra::learning_data"]
        [::core::mem::offset_of!(SwkbdExtra, learning_data) - 12usize];
    ["Offset of field: SwkbdExtra::callback"]
        [::core::mem::offset_of!(SwkbdExtra, callback) - 16usize];
    ["Offset of field: SwkbdExtra::callback_user"]
        [::core::mem::offset_of!(SwkbdExtra, callback_user) - 20usize];
};
impl Default for SwkbdExtra {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Software keyboard parameter structure, it shouldn't be modified directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SwkbdState {
    pub type_: ::libc::c_int,
    pub num_buttons_m1: ::libc::c_int,
    pub valid_input: ::libc::c_int,
    pub password_mode: ::libc::c_int,
    pub is_parental_screen: ::libc::c_int,
    pub darken_top_screen: ::libc::c_int,
    pub filter_flags: u32_,
    pub save_state_flags: u32_,
    pub max_text_len: u16_,
    pub dict_word_count: u16_,
    pub max_digits: u16_,
    pub button_text: [[u16_; 17usize]; 3usize],
    pub numpad_keys: [u16_; 2usize],
    pub hint_text: [u16_; 65usize],
    pub predictive_input: bool,
    pub multiline: bool,
    pub fixed_width: bool,
    pub allow_home: bool,
    pub allow_reset: bool,
    pub allow_power: bool,
    pub unknown: bool,
    pub default_qwerty: bool,
    pub button_submits_text: [bool; 4usize],
    pub language: u16_,
    pub initial_text_offset: ::libc::c_int,
    pub dict_offset: ::libc::c_int,
    pub initial_status_offset: ::libc::c_int,
    pub initial_learning_offset: ::libc::c_int,
    pub shared_memory_size: usize,
    pub version: u32_,
    pub result: SwkbdResult,
    pub status_offset: ::libc::c_int,
    pub learning_offset: ::libc::c_int,
    pub text_offset: ::libc::c_int,
    pub text_length: u16_,
    pub callback_result: ::libc::c_int,
    pub callback_msg: [u16_; 257usize],
    pub skip_at_check: bool,
    pub __bindgen_anon_1: SwkbdState__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SwkbdState__bindgen_ty_1 {
    pub reserved: [u8_; 171usize],
    pub extra: SwkbdExtra,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SwkbdState__bindgen_ty_1"]
        [::core::mem::size_of::<SwkbdState__bindgen_ty_1>() - 172usize];
    ["Alignment of SwkbdState__bindgen_ty_1"]
        [::core::mem::align_of::<SwkbdState__bindgen_ty_1>() - 4usize];
    ["Offset of field: SwkbdState__bindgen_ty_1::reserved"]
        [::core::mem::offset_of!(SwkbdState__bindgen_ty_1, reserved) - 0usize];
    ["Offset of field: SwkbdState__bindgen_ty_1::extra"]
        [::core::mem::offset_of!(SwkbdState__bindgen_ty_1, extra) - 0usize];
};
impl Default for SwkbdState__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SwkbdState"][::core::mem::size_of::<SwkbdState>() - 1024usize];
    ["Alignment of SwkbdState"][::core::mem::align_of::<SwkbdState>() - 4usize];
    ["Offset of field: SwkbdState::type_"][::core::mem::offset_of!(SwkbdState, type_) - 0usize];
    ["Offset of field: SwkbdState::num_buttons_m1"]
        [::core::mem::offset_of!(SwkbdState, num_buttons_m1) - 4usize];
    ["Offset of field: SwkbdState::valid_input"]
        [::core::mem::offset_of!(SwkbdState, valid_input) - 8usize];
    ["Offset of field: SwkbdState::password_mode"]
        [::core::mem::offset_of!(SwkbdState, password_mode) - 12usize];
    ["Offset of field: SwkbdState::is_parental_screen"]
        [::core::mem::offset_of!(SwkbdState, is_parental_screen) - 16usize];
    ["Offset of field: SwkbdState::darken_top_screen"]
        [::core::mem::offset_of!(SwkbdState, darken_top_screen) - 20usize];
    ["Offset of field: SwkbdState::filter_flags"]
        [::core::mem::offset_of!(SwkbdState, filter_flags) - 24usize];
    ["Offset of field: SwkbdState::save_state_flags"]
        [::core::mem::offset_of!(SwkbdState, save_state_flags) - 28usize];
    ["Offset of field: SwkbdState::max_text_len"]
        [::core::mem::offset_of!(SwkbdState, max_text_len) - 32usize];
    ["Offset of field: SwkbdState::dict_word_count"]
        [::core::mem::offset_of!(SwkbdState, dict_word_count) - 34usize];
    ["Offset of field: SwkbdState::max_digits"]
        [::core::mem::offset_of!(SwkbdState, max_digits) - 36usize];
    ["Offset of field: SwkbdState::button_text"]
        [::core::mem::offset_of!(SwkbdState, button_text) - 38usize];
    ["Offset of field: SwkbdState::numpad_keys"]
        [::core::mem::offset_of!(SwkbdState, numpad_keys) - 140usize];
    ["Offset of field: SwkbdState::hint_text"]
        [::core::mem::offset_of!(SwkbdState, hint_text) - 144usize];
    ["Offset of field: SwkbdState::predictive_input"]
        [::core::mem::offset_of!(SwkbdState, predictive_input) - 274usize];
    ["Offset of field: SwkbdState::multiline"]
        [::core::mem::offset_of!(SwkbdState, multiline) - 275usize];
    ["Offset of field: SwkbdState::fixed_width"]
        [::core::mem::offset_of!(SwkbdState, fixed_width) - 276usize];
    ["Offset of field: SwkbdState::allow_home"]
        [::core::mem::offset_of!(SwkbdState, allow_home) - 277usize];
    ["Offset of field: SwkbdState::allow_reset"]
        [::core::mem::offset_of!(SwkbdState, allow_reset) - 278usize];
    ["Offset of field: SwkbdState::allow_power"]
        [::core::mem::offset_of!(SwkbdState, allow_power) - 279usize];
    ["Offset of field: SwkbdState::unknown"]
        [::core::mem::offset_of!(SwkbdState, unknown) - 280usize];
    ["Offset of field: SwkbdState::default_qwerty"]
        [::core::mem::offset_of!(SwkbdState, default_qwerty) - 281usize];
    ["Offset of field: SwkbdState::button_submits_text"]
        [::core::mem::offset_of!(SwkbdState, button_submits_text) - 282usize];
    ["Offset of field: SwkbdState::language"]
        [::core::mem::offset_of!(SwkbdState, language) - 286usize];
    ["Offset of field: SwkbdState::initial_text_offset"]
        [::core::mem::offset_of!(SwkbdState, initial_text_offset) - 288usize];
    ["Offset of field: SwkbdState::dict_offset"]
        [::core::mem::offset_of!(SwkbdState, dict_offset) - 292usize];
    ["Offset of field: SwkbdState::initial_status_offset"]
        [::core::mem::offset_of!(SwkbdState, initial_status_offset) - 296usize];
    ["Offset of field: SwkbdState::initial_learning_offset"]
        [::core::mem::offset_of!(SwkbdState, initial_learning_offset) - 300usize];
    ["Offset of field: SwkbdState::shared_memory_size"]
        [::core::mem::offset_of!(SwkbdState, shared_memory_size) - 304usize];
    ["Offset of field: SwkbdState::version"]
        [::core::mem::offset_of!(SwkbdState, version) - 308usize];
    ["Offset of field: SwkbdState::result"][::core::mem::offset_of!(SwkbdState, result) - 312usize];
    ["Offset of field: SwkbdState::status_offset"]
        [::core::mem::offset_of!(SwkbdState, status_offset) - 316usize];
    ["Offset of field: SwkbdState::learning_offset"]
        [::core::mem::offset_of!(SwkbdState, learning_offset) - 320usize];
    ["Offset of field: SwkbdState::text_offset"]
        [::core::mem::offset_of!(SwkbdState, text_offset) - 324usize];
    ["Offset of field: SwkbdState::text_length"]
        [::core::mem::offset_of!(SwkbdState, text_length) - 328usize];
    ["Offset of field: SwkbdState::callback_result"]
        [::core::mem::offset_of!(SwkbdState, callback_result) - 332usize];
    ["Offset of field: SwkbdState::callback_msg"]
        [::core::mem::offset_of!(SwkbdState, callback_msg) - 336usize];
    ["Offset of field: SwkbdState::skip_at_check"]
        [::core::mem::offset_of!(SwkbdState, skip_at_check) - 850usize];
};
impl Default for SwkbdState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = "Initializes software keyboard status.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `type` - Keyboard type.\n * `numButtons` - Number of dialog buttons to display (1, 2 or 3).\n * `maxTextLength` - Maximum number of UTF-16 code units that input text can have (or -1 to let libctru use a big default)."]
    pub fn swkbdInit(
        swkbd: *mut SwkbdState,
        type_: SwkbdType,
        numButtons: ::libc::c_int,
        maxTextLength: ::libc::c_int,
    );
}
unsafe extern "C" {
    #[doc = "Configures password mode in a software keyboard.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `mode` - Password mode."]
    #[link_name = "swkbdSetPasswordMode__extern"]
    pub fn swkbdSetPasswordMode(swkbd: *mut SwkbdState, mode: SwkbdPasswordMode);
}
unsafe extern "C" {
    #[doc = "Configures input validation in a software keyboard.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `validInput` - Specifies which inputs are valid.\n * `filterFlags` - Bitmask specifying which characters are disallowed (filtered).\n * `maxDigits` - In case digits are disallowed, specifies how many digits are allowed at maximum in input strings (0 completely restricts digit input)."]
    #[link_name = "swkbdSetValidation__extern"]
    pub fn swkbdSetValidation(
        swkbd: *mut SwkbdState,
        validInput: SwkbdValidInput,
        filterFlags: u32_,
        maxDigits: ::libc::c_int,
    );
}
unsafe extern "C" {
    #[doc = "Configures what characters will the two bottom keys in a numpad produce.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `left` - Unicode codepoint produced by the leftmost key in the bottom row (0 hides the key).\n * `left` - Unicode codepoint produced by the rightmost key in the bottom row (0 hides the key)."]
    #[link_name = "swkbdSetNumpadKeys__extern"]
    pub fn swkbdSetNumpadKeys(swkbd: *mut SwkbdState, left: ::libc::c_int, right: ::libc::c_int);
}
unsafe extern "C" {
    #[doc = "Specifies which special features are enabled in a software keyboard.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `features` - Feature bitmask."]
    pub fn swkbdSetFeatures(swkbd: *mut SwkbdState, features: u32_);
}
unsafe extern "C" {
    #[doc = "Sets the hint text of a software keyboard (that is, the help text that is displayed when the textbox is empty).\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `text` - Hint text."]
    pub fn swkbdSetHintText(swkbd: *mut SwkbdState, text: *const ::libc::c_char);
}
unsafe extern "C" {
    #[doc = "Configures a dialog button in a software keyboard.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `button` - Specifies which button to configure.\n * `text` - Button text.\n * `submit` - Specifies whether pushing the button will submit the text or discard it."]
    pub fn swkbdSetButton(
        swkbd: *mut SwkbdState,
        button: SwkbdButton,
        text: *const ::libc::c_char,
        submit: bool,
    );
}
unsafe extern "C" {
    #[doc = "Sets the initial text that a software keyboard will display on launch.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `text` - Initial text."]
    pub fn swkbdSetInitialText(swkbd: *mut SwkbdState, text: *const ::libc::c_char);
}
unsafe extern "C" {
    #[doc = "Configures a word in a predictive dictionary for use with a software keyboard.\n # Arguments\n\n* `word` - Pointer to dictionary word structure.\n * `reading` - Reading of the word, that is, the sequence of characters that need to be typed to trigger the word in the predictive input system.\n * `text` - Spelling of the word, that is, the actual characters that will be produced when the user decides to select the word."]
    pub fn swkbdSetDictWord(
        word: *mut SwkbdDictWord,
        reading: *const ::libc::c_char,
        text: *const ::libc::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Sets the custom word dictionary to be used with the predictive input system of a software keyboard.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `dict` - Pointer to dictionary words.\n * `wordCount` - Number of words in the dictionary."]
    pub fn swkbdSetDictionary(
        swkbd: *mut SwkbdState,
        dict: *const SwkbdDictWord,
        wordCount: ::libc::c_int,
    );
}
unsafe extern "C" {
    #[doc = "Configures software keyboard internal status management.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `data` - Pointer to internal status structure (can be in, out or both depending on the other parameters).\n * `in` - Specifies whether the data should be read from the structure when the keyboard is launched.\n * `out` - Specifies whether the data should be written to the structure when the keyboard is closed."]
    pub fn swkbdSetStatusData(
        swkbd: *mut SwkbdState,
        data: *mut SwkbdStatusData,
        in_: bool,
        out: bool,
    );
}
unsafe extern "C" {
    #[doc = "Configures software keyboard predictive input learning data management.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `data` - Pointer to learning data structure (can be in, out or both depending on the other parameters).\n * `in` - Specifies whether the data should be read from the structure when the keyboard is launched.\n * `out` - Specifies whether the data should be written to the structure when the keyboard is closed."]
    pub fn swkbdSetLearningData(
        swkbd: *mut SwkbdState,
        data: *mut SwkbdLearningData,
        in_: bool,
        out: bool,
    );
}
unsafe extern "C" {
    #[doc = "Configures a custom function to be used to check the validity of input when it is submitted in a software keyboard.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `callback` - Filter callback function.\n * `user` - Custom data to be passed to the callback function."]
    pub fn swkbdSetFilterCallback(
        swkbd: *mut SwkbdState,
        callback: SwkbdCallbackFn,
        user: *mut ::libc::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Launches a software keyboard in order to input text.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `buf` - Pointer to output buffer which will hold the inputted text.\n * `bufsize` - Maximum number of UTF-8 code units that the buffer can hold (including null terminator).\n # Returns\n\nThe identifier of the dialog button that was pressed, or SWKBD_BUTTON_NONE if a different condition was triggered - in that case use swkbdGetResult to check the condition."]
    pub fn swkbdInputText(
        swkbd: *mut SwkbdState,
        buf: *mut ::libc::c_char,
        bufsize: usize,
    ) -> SwkbdButton;
}
unsafe extern "C" {
    #[doc = "Retrieves the result condition of a software keyboard after it has been used.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n # Returns\n\nThe result value."]
    #[link_name = "swkbdGetResult__extern"]
    pub fn swkbdGetResult(swkbd: *mut SwkbdState) -> SwkbdResult;
}
#[doc = "<??-Unknown flag"]
pub const ERROR_LANGUAGE_FLAG: _bindgen_ty_35 = 256;
#[doc = "<??-Unknown flag"]
pub const ERROR_WORD_WRAP_FLAG: _bindgen_ty_35 = 512;
pub type _bindgen_ty_35 = ::libc::c_ushort;
#[doc = "< Displays the infrastructure communications-related error message corresponding to the error code."]
pub const ERROR_CODE: errorType = 0;
#[doc = "< Displays text passed to this applet."]
pub const ERROR_TEXT: errorType = 1;
#[doc = "< Displays the EULA"]
pub const ERROR_EULA: errorType = 2;
#[doc = "< Use prohibited."]
pub const ERROR_TYPE_EULA_FIRST_BOOT: errorType = 3;
#[doc = "< Use prohibited."]
pub const ERROR_TYPE_EULA_DRAW_ONLY: errorType = 4;
#[doc = "< Use prohibited."]
pub const ERROR_TYPE_AGREE: errorType = 5;
#[doc = "< Displays a network error message in a specified language."]
pub const ERROR_CODE_LANGUAGE: errorType = 256;
#[doc = "< Displays text passed to this applet in a specified language."]
pub const ERROR_TEXT_LANGUAGE: errorType = 257;
#[doc = "< Displays EULA in a specified language."]
pub const ERROR_EULA_LANGUAGE: errorType = 258;
#[doc = "< Displays the custom error message passed to this applet with automatic line wrapping"]
pub const ERROR_TEXT_WORD_WRAP: errorType = 513;
#[doc = "< Displays the custom error message with automatic line wrapping and in the specified language."]
pub const ERROR_TEXT_LANGUAGE_WORD_WRAP: errorType = 769;
pub type errorType = ::libc::c_ushort;
pub const ERROR_NORMAL: errorScreenFlag = 0;
pub const ERROR_STEREO: errorScreenFlag = 1;
pub type errorScreenFlag = ::libc::c_uchar;
pub const ERROR_UNKNOWN: errorReturnCode = -1;
pub const ERROR_NONE: errorReturnCode = 0;
pub const ERROR_SUCCESS: errorReturnCode = 1;
pub const ERROR_NOT_SUPPORTED: errorReturnCode = 2;
pub const ERROR_HOME_BUTTON: errorReturnCode = 10;
pub const ERROR_SOFTWARE_RESET: errorReturnCode = 11;
pub const ERROR_POWER_BUTTON: errorReturnCode = 12;
pub type errorReturnCode = ::libc::c_schar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct errorConf {
    pub type_: errorType,
    pub errorCode: ::libc::c_int,
    pub upperScreenFlag: errorScreenFlag,
    pub useLanguage: u16_,
    pub Text: [u16_; 1900usize],
    pub homeButton: bool,
    pub softwareReset: bool,
    pub appJump: bool,
    pub returnCode: errorReturnCode,
    pub eulaVersion: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of errorConf"][::core::mem::size_of::<errorConf>() - 3820usize];
    ["Alignment of errorConf"][::core::mem::align_of::<errorConf>() - 4usize];
    ["Offset of field: errorConf::type_"][::core::mem::offset_of!(errorConf, type_) - 0usize];
    ["Offset of field: errorConf::errorCode"]
        [::core::mem::offset_of!(errorConf, errorCode) - 4usize];
    ["Offset of field: errorConf::upperScreenFlag"]
        [::core::mem::offset_of!(errorConf, upperScreenFlag) - 8usize];
    ["Offset of field: errorConf::useLanguage"]
        [::core::mem::offset_of!(errorConf, useLanguage) - 10usize];
    ["Offset of field: errorConf::Text"][::core::mem::offset_of!(errorConf, Text) - 12usize];
    ["Offset of field: errorConf::homeButton"]
        [::core::mem::offset_of!(errorConf, homeButton) - 3812usize];
    ["Offset of field: errorConf::softwareReset"]
        [::core::mem::offset_of!(errorConf, softwareReset) - 3813usize];
    ["Offset of field: errorConf::appJump"]
        [::core::mem::offset_of!(errorConf, appJump) - 3814usize];
    ["Offset of field: errorConf::returnCode"]
        [::core::mem::offset_of!(errorConf, returnCode) - 3815usize];
    ["Offset of field: errorConf::eulaVersion"]
        [::core::mem::offset_of!(errorConf, eulaVersion) - 3816usize];
};
impl Default for errorConf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = "Init the error applet.\n # Arguments\n\n* `err` - Pointer to errorConf.\n * `type` - errorType Type of error.\n * `lang` - CFG_Language Lang of error."]
    pub fn errorInit(err: *mut errorConf, type_: errorType, lang: CFG_Language);
}
unsafe extern "C" {
    #[doc = "Sets error code to display.\n # Arguments\n\n* `err` - Pointer to errorConf.\n * `error` - Error-code to display."]
    pub fn errorCode(err: *mut errorConf, error: ::libc::c_int);
}
unsafe extern "C" {
    #[doc = "Sets error text to display.\n # Arguments\n\n* `err` - Pointer to errorConf.\n * `text` - Error-text to display."]
    pub fn errorText(err: *mut errorConf, text: *const ::libc::c_char);
}
unsafe extern "C" {
    #[doc = "Displays the error applet.\n # Arguments\n\n* `err` - Pointer to errorConf."]
    pub fn errorDisp(err: *mut errorConf);
}
#[doc = "Parameter structure passed to AppletEd"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MiiSelectorConf {
    #[doc = "< Enables canceling of selection if nonzero."]
    pub enable_cancel_button: u8_,
    #[doc = "< Makes Guets Miis selectable if nonzero."]
    pub enable_selecting_guests: u8_,
    #[doc = "< Shows applet on top screen if nonzero,\n< otherwise show it on the bottom screen."]
    pub show_on_top_screen: u8_,
    #[doc = "< "]
    pub _unk0x3: [u8_; 5usize],
    #[doc = "< UTF16-LE string displayed at the top of the applet. If\n< set to the empty string, a default title is displayed."]
    pub title: [u16_; 64usize],
    #[doc = "< "]
    pub _unk0x88: [u8_; 4usize],
    #[doc = "< If nonzero, the applet shows a page with Guest\n< Miis on launch."]
    pub show_guest_page: u8_,
    #[doc = "< "]
    pub _unk0x8D: [u8_; 3usize],
    #[doc = "< Index of the initially selected Mii. If\n< MiiSelectorConf.show_guest_page is\n< set, this is the index of a Guest Mii,\n< otherwise that of a user Mii."]
    pub initial_index: u32_,
    #[doc = "< Each byte set to a nonzero value\n< enables its corresponding Guest\n< Mii to be enabled for selection."]
    pub mii_guest_whitelist: [u8_; 6usize],
    #[doc = "< Each byte set to a nonzero value enables\n< its corresponding user Mii to be enabled\n< for selection."]
    pub mii_whitelist: [u8_; 100usize],
    #[doc = "< "]
    pub _unk0xFE: u16_,
    #[doc = "< Will be set to MIISELECTOR_MAGIC before launching the\n< applet."]
    pub magic: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiSelectorConf"][::core::mem::size_of::<MiiSelectorConf>() - 260usize];
    ["Alignment of MiiSelectorConf"][::core::mem::align_of::<MiiSelectorConf>() - 4usize];
    ["Offset of field: MiiSelectorConf::enable_cancel_button"]
        [::core::mem::offset_of!(MiiSelectorConf, enable_cancel_button) - 0usize];
    ["Offset of field: MiiSelectorConf::enable_selecting_guests"]
        [::core::mem::offset_of!(MiiSelectorConf, enable_selecting_guests) - 1usize];
    ["Offset of field: MiiSelectorConf::show_on_top_screen"]
        [::core::mem::offset_of!(MiiSelectorConf, show_on_top_screen) - 2usize];
    ["Offset of field: MiiSelectorConf::_unk0x3"]
        [::core::mem::offset_of!(MiiSelectorConf, _unk0x3) - 3usize];
    ["Offset of field: MiiSelectorConf::title"]
        [::core::mem::offset_of!(MiiSelectorConf, title) - 8usize];
    ["Offset of field: MiiSelectorConf::_unk0x88"]
        [::core::mem::offset_of!(MiiSelectorConf, _unk0x88) - 136usize];
    ["Offset of field: MiiSelectorConf::show_guest_page"]
        [::core::mem::offset_of!(MiiSelectorConf, show_guest_page) - 140usize];
    ["Offset of field: MiiSelectorConf::_unk0x8D"]
        [::core::mem::offset_of!(MiiSelectorConf, _unk0x8D) - 141usize];
    ["Offset of field: MiiSelectorConf::initial_index"]
        [::core::mem::offset_of!(MiiSelectorConf, initial_index) - 144usize];
    ["Offset of field: MiiSelectorConf::mii_guest_whitelist"]
        [::core::mem::offset_of!(MiiSelectorConf, mii_guest_whitelist) - 148usize];
    ["Offset of field: MiiSelectorConf::mii_whitelist"]
        [::core::mem::offset_of!(MiiSelectorConf, mii_whitelist) - 154usize];
    ["Offset of field: MiiSelectorConf::_unk0xFE"]
        [::core::mem::offset_of!(MiiSelectorConf, _unk0xFE) - 254usize];
    ["Offset of field: MiiSelectorConf::magic"]
        [::core::mem::offset_of!(MiiSelectorConf, magic) - 256usize];
};
impl Default for MiiSelectorConf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Structure written by AppletEd"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiSelectorReturn {
    #[doc = "< 0 if a Mii was selected, 1 if the selection was\n< canceled."]
    pub no_mii_selected: u32_,
    #[doc = "< 1 if a Guest Mii was selected, 0 otherwise."]
    pub guest_mii_was_selected: u32_,
    #[doc = "< Index of the selected Guest Mii,\n< 0xFFFFFFFF if no guest was selected."]
    pub guest_mii_index: u32_,
    #[doc = "< Data of selected Mii."]
    pub mii: MiiData,
    #[doc = "< "]
    pub _pad0x68: u16_,
    #[doc = "< Checksum of the returned Mii data.\n< Stored as a big-endian value; use\n< miiSelectorChecksumIsValid to\n< verify."]
    pub checksum: u16_,
    #[doc = "< Localized name of a Guest Mii,\n< if one was selected (UTF16-LE\n< string). Zeroed otherwise."]
    pub guest_mii_name: [u16_; 12usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MiiSelectorReturn"][::core::mem::size_of::<MiiSelectorReturn>() - 132usize];
    ["Alignment of MiiSelectorReturn"][::core::mem::align_of::<MiiSelectorReturn>() - 4usize];
    ["Offset of field: MiiSelectorReturn::no_mii_selected"]
        [::core::mem::offset_of!(MiiSelectorReturn, no_mii_selected) - 0usize];
    ["Offset of field: MiiSelectorReturn::guest_mii_was_selected"]
        [::core::mem::offset_of!(MiiSelectorReturn, guest_mii_was_selected) - 4usize];
    ["Offset of field: MiiSelectorReturn::guest_mii_index"]
        [::core::mem::offset_of!(MiiSelectorReturn, guest_mii_index) - 8usize];
    ["Offset of field: MiiSelectorReturn::mii"]
        [::core::mem::offset_of!(MiiSelectorReturn, mii) - 12usize];
    ["Offset of field: MiiSelectorReturn::_pad0x68"]
        [::core::mem::offset_of!(MiiSelectorReturn, _pad0x68) - 104usize];
    ["Offset of field: MiiSelectorReturn::checksum"]
        [::core::mem::offset_of!(MiiSelectorReturn, checksum) - 106usize];
    ["Offset of field: MiiSelectorReturn::guest_mii_name"]
        [::core::mem::offset_of!(MiiSelectorReturn, guest_mii_name) - 108usize];
};
#[doc = "< Show the cancel button"]
pub const MIISELECTOR_CANCEL: _bindgen_ty_36 = 1;
#[doc = "< Make Guets Miis selectable"]
pub const MIISELECTOR_GUESTS: _bindgen_ty_36 = 2;
#[doc = "< Show AppletEd on top screen"]
pub const MIISELECTOR_TOP: _bindgen_ty_36 = 4;
#[doc = "< Start on guest page"]
pub const MIISELECTOR_GUESTSTART: _bindgen_ty_36 = 8;
#[doc = "AppletEd options"]
pub type _bindgen_ty_36 = ::libc::c_uchar;
unsafe extern "C" {
    #[doc = "Initialize Mii selector config\n # Arguments\n\n* `conf` - Pointer to Miiselector config."]
    pub fn miiSelectorInit(conf: *mut MiiSelectorConf);
}
unsafe extern "C" {
    #[doc = "Launch the Mii selector library applet\n\n # Arguments\n\n* `conf` - Configuration determining how the applet should behave"]
    pub fn miiSelectorLaunch(conf: *const MiiSelectorConf, returnbuf: *mut MiiSelectorReturn);
}
unsafe extern "C" {
    #[doc = "Sets title of the Mii selector library applet\n\n # Arguments\n\n* `conf` - Pointer to miiSelector configuration\n * `text` - Title text of Mii selector"]
    pub fn miiSelectorSetTitle(conf: *mut MiiSelectorConf, text: *const ::libc::c_char);
}
unsafe extern "C" {
    #[doc = "Specifies which special options are enabled in the Mii selector\n\n # Arguments\n\n* `conf` - Pointer to miiSelector configuration\n * `options` - Options bitmask"]
    pub fn miiSelectorSetOptions(conf: *mut MiiSelectorConf, options: u32_);
}
unsafe extern "C" {
    #[doc = "Specifies which guest Miis will be selectable\n\n # Arguments\n\n* `conf` - Pointer to miiSelector configuration\n * `index` - Index of the guest Miis that will be whitelisted.\n MIISELECTOR_GUESTMII_SLOTS can be used to whitelist all the guest Miis."]
    pub fn miiSelectorWhitelistGuestMii(conf: *mut MiiSelectorConf, index: u32_);
}
unsafe extern "C" {
    #[doc = "Specifies which guest Miis will be unselectable\n\n # Arguments\n\n* `conf` - Pointer to miiSelector configuration\n * `index` - Index of the guest Miis that will be blacklisted.\n MIISELECTOR_GUESTMII_SLOTS can be used to blacklist all the guest Miis."]
    pub fn miiSelectorBlacklistGuestMii(conf: *mut MiiSelectorConf, index: u32_);
}
unsafe extern "C" {
    #[doc = "Specifies which user Miis will be selectable\n\n # Arguments\n\n* `conf` - Pointer to miiSelector configuration\n * `index` - Index of the user Miis that will be whitelisted.\n MIISELECTOR_USERMII_SLOTS can be used to whitlist all the user Miis"]
    pub fn miiSelectorWhitelistUserMii(conf: *mut MiiSelectorConf, index: u32_);
}
unsafe extern "C" {
    #[doc = "Specifies which user Miis will be selectable\n\n # Arguments\n\n* `conf` - Pointer to miiSelector configuration\n * `index` - Index of the user Miis that will be blacklisted.\n MIISELECTOR_USERMII_SLOTS can be used to blacklist all the user Miis"]
    pub fn miiSelectorBlacklistUserMii(conf: *mut MiiSelectorConf, index: u32_);
}
unsafe extern "C" {
    #[doc = "Specifies which Mii the cursor should start from\n\n # Arguments\n\n* `conf` - Pointer to miiSelector configuration\n * `index` - Indexed number of the Mii that the cursor will start on.\n If there is no mii with that index, the the cursor will start at the Mii\n with the index 0 (the personal Mii)."]
    #[link_name = "miiSelectorSetInitialIndex__extern"]
    pub fn miiSelectorSetInitialIndex(conf: *mut MiiSelectorConf, index: u32_);
}
unsafe extern "C" {
    #[doc = "Get Mii name\n\n # Arguments\n\n* `returnbuf` - Pointer to miiSelector return\n * `out` - String containing a Mii's name\n * `max_size` - Size of string. Since UTF8 characters range in size from 1-3 bytes\n (assuming that no non-BMP characters are used), this value should be 36 (or 30 if you are not\n dealing with guest miis)."]
    pub fn miiSelectorReturnGetName(
        returnbuf: *const MiiSelectorReturn,
        out: *mut ::libc::c_char,
        max_size: usize,
    );
}
unsafe extern "C" {
    #[doc = "Get Mii Author\n\n # Arguments\n\n* `returnbuf` - Pointer to miiSelector return\n * `out` - String containing a Mii's author\n * `max_size` - Size of string. Since UTF8 characters range in size from 1-3 bytes\n (assuming that no non-BMP characters are used), this value should be 30."]
    pub fn miiSelectorReturnGetAuthor(
        returnbuf: *const MiiSelectorReturn,
        out: *mut ::libc::c_char,
        max_size: usize,
    );
}
unsafe extern "C" {
    #[doc = "Verifies that the Mii data returned from the applet matches its\n checksum\n\n # Arguments\n\n* `returnbuf` - Buffer filled by Mii selector applet\n # Returns\n\n`true` if `returnbuf->checksum` is the same as the one computed from `returnbuf`"]
    pub fn miiSelectorChecksumIsValid(returnbuf: *const MiiSelectorReturn) -> bool;
}
#[doc = "Open directory struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct archive_dir_t {
    pub magic: u32_,
    #[doc = "\"arch\""]
    pub fd: Handle,
    #[doc = "CTRU handle"]
    pub index: isize,
    #[doc = "Current entry index"]
    pub size: usize,
    #[doc = "Current batch size"]
    pub entry_data: [FS_DirectoryEntry; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of archive_dir_t"][::core::mem::size_of::<archive_dir_t>() - 17680usize];
    ["Alignment of archive_dir_t"][::core::mem::align_of::<archive_dir_t>() - 8usize];
    ["Offset of field: archive_dir_t::magic"]
        [::core::mem::offset_of!(archive_dir_t, magic) - 0usize];
    ["Offset of field: archive_dir_t::fd"][::core::mem::offset_of!(archive_dir_t, fd) - 4usize];
    ["Offset of field: archive_dir_t::index"]
        [::core::mem::offset_of!(archive_dir_t, index) - 8usize];
    ["Offset of field: archive_dir_t::size"]
        [::core::mem::offset_of!(archive_dir_t, size) - 12usize];
    ["Offset of field: archive_dir_t::entry_data"]
        [::core::mem::offset_of!(archive_dir_t, entry_data) - 16usize];
};
impl Default for archive_dir_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Mounts the SD"]
    pub fn archiveMountSdmc() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Mounts and opens an archive as deviceName\n Returns either an archive open error code, or -1 for generic failure"]
    pub fn archiveMount(
        archiveID: FS_ArchiveID,
        archivePath: FS_Path,
        deviceName: *const ::libc::c_char,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Uses FSUSER_ControlArchive with control action ARCHIVE_ACTION_COMMIT_SAVE_DATA on the opened archive. Not done automatically at unmount.\n Returns -1 if the specified device is not found"]
    pub fn archiveCommitSaveData(deviceName: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unmounts the specified device, closing its archive in the process\n Returns -1 if the specified device was not found"]
    pub fn archiveUnmount(deviceName: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unmounts all devices and cleans up any resources used by the driver"]
    pub fn archiveUnmountAll() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Get a file's mtime"]
    pub fn archive_getmtime(name: *const ::libc::c_char, mtime: *mut u64_) -> Result;
}
#[doc = "RomFS header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct romfs_header {
    #[doc = "< Size of the header."]
    pub headerSize: u32_,
    #[doc = "< Offset of the directory hash table."]
    pub dirHashTableOff: u32_,
    #[doc = "< Size of the directory hash table."]
    pub dirHashTableSize: u32_,
    #[doc = "< Offset of the directory table."]
    pub dirTableOff: u32_,
    #[doc = "< Size of the directory table."]
    pub dirTableSize: u32_,
    #[doc = "< Offset of the file hash table."]
    pub fileHashTableOff: u32_,
    #[doc = "< Size of the file hash table."]
    pub fileHashTableSize: u32_,
    #[doc = "< Offset of the file table."]
    pub fileTableOff: u32_,
    #[doc = "< Size of the file table."]
    pub fileTableSize: u32_,
    #[doc = "< Offset of the file data."]
    pub fileDataOff: u32_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of romfs_header"][::core::mem::size_of::<romfs_header>() - 40usize];
    ["Alignment of romfs_header"][::core::mem::align_of::<romfs_header>() - 4usize];
    ["Offset of field: romfs_header::headerSize"]
        [::core::mem::offset_of!(romfs_header, headerSize) - 0usize];
    ["Offset of field: romfs_header::dirHashTableOff"]
        [::core::mem::offset_of!(romfs_header, dirHashTableOff) - 4usize];
    ["Offset of field: romfs_header::dirHashTableSize"]
        [::core::mem::offset_of!(romfs_header, dirHashTableSize) - 8usize];
    ["Offset of field: romfs_header::dirTableOff"]
        [::core::mem::offset_of!(romfs_header, dirTableOff) - 12usize];
    ["Offset of field: romfs_header::dirTableSize"]
        [::core::mem::offset_of!(romfs_header, dirTableSize) - 16usize];
    ["Offset of field: romfs_header::fileHashTableOff"]
        [::core::mem::offset_of!(romfs_header, fileHashTableOff) - 20usize];
    ["Offset of field: romfs_header::fileHashTableSize"]
        [::core::mem::offset_of!(romfs_header, fileHashTableSize) - 24usize];
    ["Offset of field: romfs_header::fileTableOff"]
        [::core::mem::offset_of!(romfs_header, fileTableOff) - 28usize];
    ["Offset of field: romfs_header::fileTableSize"]
        [::core::mem::offset_of!(romfs_header, fileTableSize) - 32usize];
    ["Offset of field: romfs_header::fileDataOff"]
        [::core::mem::offset_of!(romfs_header, fileDataOff) - 36usize];
};
#[doc = "RomFS directory."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct romfs_dir {
    #[doc = "< Offset of the parent directory."]
    pub parent: u32_,
    #[doc = "< Offset of the next sibling directory."]
    pub sibling: u32_,
    #[doc = "< Offset of the first child directory."]
    pub childDir: u32_,
    #[doc = "< Offset of the first file."]
    pub childFile: u32_,
    #[doc = "< Directory hash table pointer."]
    pub nextHash: u32_,
    #[doc = "< Name length."]
    pub nameLen: u32_,
    #[doc = "< Name. (UTF-16)"]
    pub name: __IncompleteArrayField<u16_>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of romfs_dir"][::core::mem::size_of::<romfs_dir>() - 24usize];
    ["Alignment of romfs_dir"][::core::mem::align_of::<romfs_dir>() - 4usize];
    ["Offset of field: romfs_dir::parent"][::core::mem::offset_of!(romfs_dir, parent) - 0usize];
    ["Offset of field: romfs_dir::sibling"][::core::mem::offset_of!(romfs_dir, sibling) - 4usize];
    ["Offset of field: romfs_dir::childDir"][::core::mem::offset_of!(romfs_dir, childDir) - 8usize];
    ["Offset of field: romfs_dir::childFile"]
        [::core::mem::offset_of!(romfs_dir, childFile) - 12usize];
    ["Offset of field: romfs_dir::nextHash"]
        [::core::mem::offset_of!(romfs_dir, nextHash) - 16usize];
    ["Offset of field: romfs_dir::nameLen"][::core::mem::offset_of!(romfs_dir, nameLen) - 20usize];
    ["Offset of field: romfs_dir::name"][::core::mem::offset_of!(romfs_dir, name) - 24usize];
};
#[doc = "RomFS file."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct romfs_file {
    #[doc = "< Offset of the parent directory."]
    pub parent: u32_,
    #[doc = "< Offset of the next sibling file."]
    pub sibling: u32_,
    #[doc = "< Offset of the file's data."]
    pub dataOff: u64_,
    #[doc = "< Length of the file's data."]
    pub dataSize: u64_,
    #[doc = "< File hash table pointer."]
    pub nextHash: u32_,
    #[doc = "< Name length."]
    pub nameLen: u32_,
    #[doc = "< Name. (UTF-16)"]
    pub name: __IncompleteArrayField<u16_>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of romfs_file"][::core::mem::size_of::<romfs_file>() - 32usize];
    ["Alignment of romfs_file"][::core::mem::align_of::<romfs_file>() - 8usize];
    ["Offset of field: romfs_file::parent"][::core::mem::offset_of!(romfs_file, parent) - 0usize];
    ["Offset of field: romfs_file::sibling"][::core::mem::offset_of!(romfs_file, sibling) - 4usize];
    ["Offset of field: romfs_file::dataOff"][::core::mem::offset_of!(romfs_file, dataOff) - 8usize];
    ["Offset of field: romfs_file::dataSize"]
        [::core::mem::offset_of!(romfs_file, dataSize) - 16usize];
    ["Offset of field: romfs_file::nextHash"]
        [::core::mem::offset_of!(romfs_file, nextHash) - 24usize];
    ["Offset of field: romfs_file::nameLen"]
        [::core::mem::offset_of!(romfs_file, nameLen) - 28usize];
    ["Offset of field: romfs_file::name"][::core::mem::offset_of!(romfs_file, name) - 32usize];
};
unsafe extern "C" {
    #[must_use]
    #[doc = "Mounts the Application's RomFS.\n # Arguments\n\n* `name` - Device mount name.\n > This function is intended to be used to access one's own RomFS.\n If the application is running as 3DSX, it mounts the embedded RomFS section inside the 3DSX.\n If on the other hand it's an NCCH, it behaves identically to romfsMountFromCurrentProcess."]
    pub fn romfsMountSelf(name: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Mounts RomFS from an open file.\n # Arguments\n\n* `fd` - FSFILE handle of the RomFS image.\n * `offset` - Offset of the RomFS within the file.\n * `name` - Device mount name."]
    pub fn romfsMountFromFile(fd: Handle, offset: u32_, name: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Mounts RomFS using the current process host program RomFS.\n # Arguments\n\n* `name` - Device mount name."]
    pub fn romfsMountFromCurrentProcess(name: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Mounts RomFS from the specified title.\n # Arguments\n\n* `tid` - Title ID\n * `mediatype` - Mediatype\n * `name` - Device mount name."]
    pub fn romfsMountFromTitle(
        tid: u64_,
        mediatype: FS_MediaType,
        name: *const ::libc::c_char,
    ) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Unmounts the RomFS device."]
    pub fn romfsUnmount(name: *const ::libc::c_char) -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Wrapper for romfsMountSelf with the default \"romfs\" device name."]
    #[link_name = "romfsInit__extern"]
    pub fn romfsInit() -> Result;
}
unsafe extern "C" {
    #[must_use]
    #[doc = "Wrapper for romfsUnmount with the default \"romfs\" device name."]
    #[link_name = "romfsExit__extern"]
    pub fn romfsExit() -> Result;
}
#[doc = "Character width information structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct charWidthInfo_s {
    #[doc = "< Horizontal offset to draw the glyph with."]
    pub left: s8,
    #[doc = "< Width of the glyph."]
    pub glyphWidth: u8_,
    #[doc = "< Width of the character, that is, horizontal distance to advance."]
    pub charWidth: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of charWidthInfo_s"][::core::mem::size_of::<charWidthInfo_s>() - 3usize];
    ["Alignment of charWidthInfo_s"][::core::mem::align_of::<charWidthInfo_s>() - 1usize];
    ["Offset of field: charWidthInfo_s::left"]
        [::core::mem::offset_of!(charWidthInfo_s, left) - 0usize];
    ["Offset of field: charWidthInfo_s::glyphWidth"]
        [::core::mem::offset_of!(charWidthInfo_s, glyphWidth) - 1usize];
    ["Offset of field: charWidthInfo_s::charWidth"]
        [::core::mem::offset_of!(charWidthInfo_s, charWidth) - 2usize];
};
#[doc = "Font texture sheet information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TGLP_s {
    #[doc = "< Width of a glyph cell."]
    pub cellWidth: u8_,
    #[doc = "< Height of a glyph cell."]
    pub cellHeight: u8_,
    #[doc = "< Vertical position of the baseline."]
    pub baselinePos: u8_,
    #[doc = "< Maximum character width."]
    pub maxCharWidth: u8_,
    #[doc = "< Size in bytes of a texture sheet."]
    pub sheetSize: u32_,
    #[doc = "< Number of texture sheets."]
    pub nSheets: u16_,
    #[doc = "< GPU texture format (GPU_TEXCOLOR)."]
    pub sheetFmt: u16_,
    #[doc = "< Number of glyphs per row per sheet."]
    pub nRows: u16_,
    #[doc = "< Number of glyph rows per sheet."]
    pub nLines: u16_,
    #[doc = "< Texture sheet width."]
    pub sheetWidth: u16_,
    #[doc = "< Texture sheet height."]
    pub sheetHeight: u16_,
    #[doc = "< Pointer to texture sheet data."]
    pub sheetData: *mut u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TGLP_s"][::core::mem::size_of::<TGLP_s>() - 24usize];
    ["Alignment of TGLP_s"][::core::mem::align_of::<TGLP_s>() - 4usize];
    ["Offset of field: TGLP_s::cellWidth"][::core::mem::offset_of!(TGLP_s, cellWidth) - 0usize];
    ["Offset of field: TGLP_s::cellHeight"][::core::mem::offset_of!(TGLP_s, cellHeight) - 1usize];
    ["Offset of field: TGLP_s::baselinePos"][::core::mem::offset_of!(TGLP_s, baselinePos) - 2usize];
    ["Offset of field: TGLP_s::maxCharWidth"]
        [::core::mem::offset_of!(TGLP_s, maxCharWidth) - 3usize];
    ["Offset of field: TGLP_s::sheetSize"][::core::mem::offset_of!(TGLP_s, sheetSize) - 4usize];
    ["Offset of field: TGLP_s::nSheets"][::core::mem::offset_of!(TGLP_s, nSheets) - 8usize];
    ["Offset of field: TGLP_s::sheetFmt"][::core::mem::offset_of!(TGLP_s, sheetFmt) - 10usize];
    ["Offset of field: TGLP_s::nRows"][::core::mem::offset_of!(TGLP_s, nRows) - 12usize];
    ["Offset of field: TGLP_s::nLines"][::core::mem::offset_of!(TGLP_s, nLines) - 14usize];
    ["Offset of field: TGLP_s::sheetWidth"][::core::mem::offset_of!(TGLP_s, sheetWidth) - 16usize];
    ["Offset of field: TGLP_s::sheetHeight"]
        [::core::mem::offset_of!(TGLP_s, sheetHeight) - 18usize];
    ["Offset of field: TGLP_s::sheetData"][::core::mem::offset_of!(TGLP_s, sheetData) - 20usize];
};
impl Default for TGLP_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Font character width information block type."]
pub type CWDH_s = tag_CWDH_s;
#[doc = "Font character width information block structure."]
#[repr(C)]
#[derive(Debug)]
pub struct tag_CWDH_s {
    #[doc = "< First Unicode codepoint the block applies to."]
    pub startIndex: u16_,
    #[doc = "< Last Unicode codepoint the block applies to."]
    pub endIndex: u16_,
    #[doc = "< Pointer to the next block."]
    pub next: *mut CWDH_s,
    #[doc = "< Table of character width information structures."]
    pub widths: __IncompleteArrayField<charWidthInfo_s>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tag_CWDH_s"][::core::mem::size_of::<tag_CWDH_s>() - 8usize];
    ["Alignment of tag_CWDH_s"][::core::mem::align_of::<tag_CWDH_s>() - 4usize];
    ["Offset of field: tag_CWDH_s::startIndex"]
        [::core::mem::offset_of!(tag_CWDH_s, startIndex) - 0usize];
    ["Offset of field: tag_CWDH_s::endIndex"]
        [::core::mem::offset_of!(tag_CWDH_s, endIndex) - 2usize];
    ["Offset of field: tag_CWDH_s::next"][::core::mem::offset_of!(tag_CWDH_s, next) - 4usize];
    ["Offset of field: tag_CWDH_s::widths"][::core::mem::offset_of!(tag_CWDH_s, widths) - 8usize];
};
impl Default for tag_CWDH_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Identity mapping."]
pub const CMAP_TYPE_DIRECT: _bindgen_ty_37 = 0;
#[doc = "< Mapping using a table."]
pub const CMAP_TYPE_TABLE: _bindgen_ty_37 = 1;
#[doc = "< Mapping using a list of mapped characters."]
pub const CMAP_TYPE_SCAN: _bindgen_ty_37 = 2;
#[doc = "Font character map methods."]
pub type _bindgen_ty_37 = ::libc::c_uchar;
#[doc = "Font character map type."]
pub type CMAP_s = tag_CMAP_s;
#[doc = "Font character map structure."]
#[repr(C)]
pub struct tag_CMAP_s {
    #[doc = "< First Unicode codepoint the block applies to."]
    pub codeBegin: u16_,
    #[doc = "< Last Unicode codepoint the block applies to."]
    pub codeEnd: u16_,
    #[doc = "< Mapping method."]
    pub mappingMethod: u16_,
    pub reserved: u16_,
    #[doc = "< Pointer to the next map."]
    pub next: *mut CMAP_s,
    pub __bindgen_anon_1: tag_CMAP_s__bindgen_ty_1,
}
#[repr(C)]
pub struct tag_CMAP_s__bindgen_ty_1 {
    #[doc = "< For CMAP_TYPE_DIRECT: index of the first glyph."]
    pub indexOffset: __BindgenUnionField<u16_>,
    #[doc = "< For CMAP_TYPE_TABLE: table of glyph indices."]
    pub indexTable: __BindgenUnionField<[u16_; 0usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u16,
}
#[doc = "For CMAP_TYPE_SCAN: Mapping data."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct tag_CMAP_s__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Number of pairs."]
    pub nScanEntries: u16_,
    pub scanEntries: __IncompleteArrayField<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
}
#[doc = "Mapping pairs."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Unicode codepoint."]
    pub code: u16_,
    #[doc = "< Mapped glyph index."]
    pub glyphIndex: u16_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>() - 2usize];
    ["Offset of field: tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::code"][::core::mem::offset_of!(
        tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        code
    ) - 0usize];
    ["Offset of field: tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::glyphIndex"][::core::mem::offset_of!(
        tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        glyphIndex
    )
        - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tag_CMAP_s__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1>() - 2usize];
    ["Alignment of tag_CMAP_s__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1>() - 2usize];
    ["Offset of field: tag_CMAP_s__bindgen_ty_1__bindgen_ty_1::nScanEntries"]
        [::core::mem::offset_of!(tag_CMAP_s__bindgen_ty_1__bindgen_ty_1, nScanEntries) - 0usize];
    ["Offset of field: tag_CMAP_s__bindgen_ty_1__bindgen_ty_1::scanEntries"]
        [::core::mem::offset_of!(tag_CMAP_s__bindgen_ty_1__bindgen_ty_1, scanEntries) - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tag_CMAP_s__bindgen_ty_1"]
        [::core::mem::size_of::<tag_CMAP_s__bindgen_ty_1>() - 2usize];
    ["Alignment of tag_CMAP_s__bindgen_ty_1"]
        [::core::mem::align_of::<tag_CMAP_s__bindgen_ty_1>() - 2usize];
    ["Offset of field: tag_CMAP_s__bindgen_ty_1::indexOffset"]
        [::core::mem::offset_of!(tag_CMAP_s__bindgen_ty_1, indexOffset) - 0usize];
    ["Offset of field: tag_CMAP_s__bindgen_ty_1::indexTable"]
        [::core::mem::offset_of!(tag_CMAP_s__bindgen_ty_1, indexTable) - 0usize];
};
impl Default for tag_CMAP_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tag_CMAP_s"][::core::mem::size_of::<tag_CMAP_s>() - 16usize];
    ["Alignment of tag_CMAP_s"][::core::mem::align_of::<tag_CMAP_s>() - 4usize];
    ["Offset of field: tag_CMAP_s::codeBegin"]
        [::core::mem::offset_of!(tag_CMAP_s, codeBegin) - 0usize];
    ["Offset of field: tag_CMAP_s::codeEnd"][::core::mem::offset_of!(tag_CMAP_s, codeEnd) - 2usize];
    ["Offset of field: tag_CMAP_s::mappingMethod"]
        [::core::mem::offset_of!(tag_CMAP_s, mappingMethod) - 4usize];
    ["Offset of field: tag_CMAP_s::reserved"]
        [::core::mem::offset_of!(tag_CMAP_s, reserved) - 6usize];
    ["Offset of field: tag_CMAP_s::next"][::core::mem::offset_of!(tag_CMAP_s, next) - 8usize];
};
impl Default for tag_CMAP_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Font information structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FINF_s {
    #[doc = "< Signature (FINF)."]
    pub signature: u32_,
    #[doc = "< Section size."]
    pub sectionSize: u32_,
    #[doc = "< Font type"]
    pub fontType: u8_,
    #[doc = "< Line feed vertical distance."]
    pub lineFeed: u8_,
    #[doc = "< Glyph index of the replacement character."]
    pub alterCharIndex: u16_,
    #[doc = "< Default character width information."]
    pub defaultWidth: charWidthInfo_s,
    #[doc = "< Font encoding (?)"]
    pub encoding: u8_,
    #[doc = "< Pointer to texture sheet information."]
    pub tglp: *mut TGLP_s,
    #[doc = "< Pointer to the first character width information block."]
    pub cwdh: *mut CWDH_s,
    #[doc = "< Pointer to the first character map."]
    pub cmap: *mut CMAP_s,
    #[doc = "< Font height."]
    pub height: u8_,
    #[doc = "< Font width."]
    pub width: u8_,
    #[doc = "< Font ascent."]
    pub ascent: u8_,
    pub padding: u8_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FINF_s"][::core::mem::size_of::<FINF_s>() - 32usize];
    ["Alignment of FINF_s"][::core::mem::align_of::<FINF_s>() - 4usize];
    ["Offset of field: FINF_s::signature"][::core::mem::offset_of!(FINF_s, signature) - 0usize];
    ["Offset of field: FINF_s::sectionSize"][::core::mem::offset_of!(FINF_s, sectionSize) - 4usize];
    ["Offset of field: FINF_s::fontType"][::core::mem::offset_of!(FINF_s, fontType) - 8usize];
    ["Offset of field: FINF_s::lineFeed"][::core::mem::offset_of!(FINF_s, lineFeed) - 9usize];
    ["Offset of field: FINF_s::alterCharIndex"]
        [::core::mem::offset_of!(FINF_s, alterCharIndex) - 10usize];
    ["Offset of field: FINF_s::defaultWidth"]
        [::core::mem::offset_of!(FINF_s, defaultWidth) - 12usize];
    ["Offset of field: FINF_s::encoding"][::core::mem::offset_of!(FINF_s, encoding) - 15usize];
    ["Offset of field: FINF_s::tglp"][::core::mem::offset_of!(FINF_s, tglp) - 16usize];
    ["Offset of field: FINF_s::cwdh"][::core::mem::offset_of!(FINF_s, cwdh) - 20usize];
    ["Offset of field: FINF_s::cmap"][::core::mem::offset_of!(FINF_s, cmap) - 24usize];
    ["Offset of field: FINF_s::height"][::core::mem::offset_of!(FINF_s, height) - 28usize];
    ["Offset of field: FINF_s::width"][::core::mem::offset_of!(FINF_s, width) - 29usize];
    ["Offset of field: FINF_s::ascent"][::core::mem::offset_of!(FINF_s, ascent) - 30usize];
    ["Offset of field: FINF_s::padding"][::core::mem::offset_of!(FINF_s, padding) - 31usize];
};
impl Default for FINF_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Font structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFNT_s {
    #[doc = "< Signature (CFNU)."]
    pub signature: u32_,
    #[doc = "< Endianness constant (0xFEFF)."]
    pub endianness: u16_,
    #[doc = "< Header size."]
    pub headerSize: u16_,
    #[doc = "< Format version."]
    pub version: u32_,
    #[doc = "< File size."]
    pub fileSize: u32_,
    #[doc = "< Number of blocks."]
    pub nBlocks: u32_,
    #[doc = "< Font information."]
    pub finf: FINF_s,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CFNT_s"][::core::mem::size_of::<CFNT_s>() - 52usize];
    ["Alignment of CFNT_s"][::core::mem::align_of::<CFNT_s>() - 4usize];
    ["Offset of field: CFNT_s::signature"][::core::mem::offset_of!(CFNT_s, signature) - 0usize];
    ["Offset of field: CFNT_s::endianness"][::core::mem::offset_of!(CFNT_s, endianness) - 4usize];
    ["Offset of field: CFNT_s::headerSize"][::core::mem::offset_of!(CFNT_s, headerSize) - 6usize];
    ["Offset of field: CFNT_s::version"][::core::mem::offset_of!(CFNT_s, version) - 8usize];
    ["Offset of field: CFNT_s::fileSize"][::core::mem::offset_of!(CFNT_s, fileSize) - 12usize];
    ["Offset of field: CFNT_s::nBlocks"][::core::mem::offset_of!(CFNT_s, nBlocks) - 16usize];
    ["Offset of field: CFNT_s::finf"][::core::mem::offset_of!(CFNT_s, finf) - 20usize];
};
impl Default for CFNT_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Font glyph position structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fontGlyphPos_s {
    #[doc = "< Texture sheet index to use to render the glyph."]
    pub sheetIndex: ::libc::c_int,
    #[doc = "< Horizontal offset to draw the glyph width."]
    pub xOffset: f32,
    #[doc = "< Horizontal distance to advance after drawing the glyph."]
    pub xAdvance: f32,
    #[doc = "< Glyph width."]
    pub width: f32,
    pub texcoord: fontGlyphPos_s__bindgen_ty_1,
    pub vtxcoord: fontGlyphPos_s__bindgen_ty_2,
}
#[doc = "Texture coordinates to use to render the glyph."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fontGlyphPos_s__bindgen_ty_1 {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fontGlyphPos_s__bindgen_ty_1"]
        [::core::mem::size_of::<fontGlyphPos_s__bindgen_ty_1>() - 16usize];
    ["Alignment of fontGlyphPos_s__bindgen_ty_1"]
        [::core::mem::align_of::<fontGlyphPos_s__bindgen_ty_1>() - 4usize];
    ["Offset of field: fontGlyphPos_s__bindgen_ty_1::left"]
        [::core::mem::offset_of!(fontGlyphPos_s__bindgen_ty_1, left) - 0usize];
    ["Offset of field: fontGlyphPos_s__bindgen_ty_1::top"]
        [::core::mem::offset_of!(fontGlyphPos_s__bindgen_ty_1, top) - 4usize];
    ["Offset of field: fontGlyphPos_s__bindgen_ty_1::right"]
        [::core::mem::offset_of!(fontGlyphPos_s__bindgen_ty_1, right) - 8usize];
    ["Offset of field: fontGlyphPos_s__bindgen_ty_1::bottom"]
        [::core::mem::offset_of!(fontGlyphPos_s__bindgen_ty_1, bottom) - 12usize];
};
#[doc = "Vertex coordinates to use to render the glyph."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fontGlyphPos_s__bindgen_ty_2 {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fontGlyphPos_s__bindgen_ty_2"]
        [::core::mem::size_of::<fontGlyphPos_s__bindgen_ty_2>() - 16usize];
    ["Alignment of fontGlyphPos_s__bindgen_ty_2"]
        [::core::mem::align_of::<fontGlyphPos_s__bindgen_ty_2>() - 4usize];
    ["Offset of field: fontGlyphPos_s__bindgen_ty_2::left"]
        [::core::mem::offset_of!(fontGlyphPos_s__bindgen_ty_2, left) - 0usize];
    ["Offset of field: fontGlyphPos_s__bindgen_ty_2::top"]
        [::core::mem::offset_of!(fontGlyphPos_s__bindgen_ty_2, top) - 4usize];
    ["Offset of field: fontGlyphPos_s__bindgen_ty_2::right"]
        [::core::mem::offset_of!(fontGlyphPos_s__bindgen_ty_2, right) - 8usize];
    ["Offset of field: fontGlyphPos_s__bindgen_ty_2::bottom"]
        [::core::mem::offset_of!(fontGlyphPos_s__bindgen_ty_2, bottom) - 12usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fontGlyphPos_s"][::core::mem::size_of::<fontGlyphPos_s>() - 48usize];
    ["Alignment of fontGlyphPos_s"][::core::mem::align_of::<fontGlyphPos_s>() - 4usize];
    ["Offset of field: fontGlyphPos_s::sheetIndex"]
        [::core::mem::offset_of!(fontGlyphPos_s, sheetIndex) - 0usize];
    ["Offset of field: fontGlyphPos_s::xOffset"]
        [::core::mem::offset_of!(fontGlyphPos_s, xOffset) - 4usize];
    ["Offset of field: fontGlyphPos_s::xAdvance"]
        [::core::mem::offset_of!(fontGlyphPos_s, xAdvance) - 8usize];
    ["Offset of field: fontGlyphPos_s::width"]
        [::core::mem::offset_of!(fontGlyphPos_s, width) - 12usize];
    ["Offset of field: fontGlyphPos_s::texcoord"]
        [::core::mem::offset_of!(fontGlyphPos_s, texcoord) - 16usize];
    ["Offset of field: fontGlyphPos_s::vtxcoord"]
        [::core::mem::offset_of!(fontGlyphPos_s, vtxcoord) - 32usize];
};
#[doc = "< Calculates vertex coordinates in addition to texture coordinates."]
pub const GLYPH_POS_CALC_VTXCOORD: _bindgen_ty_38 = 1;
#[doc = "< Position the glyph at the baseline instead of at the top-left corner."]
pub const GLYPH_POS_AT_BASELINE: _bindgen_ty_38 = 2;
#[doc = "< Indicates that the Y axis points up instead of down."]
pub const GLYPH_POS_Y_POINTS_UP: _bindgen_ty_38 = 4;
#[doc = "Flags for use with fontCalcGlyphPos."]
pub type _bindgen_ty_38 = ::libc::c_uchar;
unsafe extern "C" {
    #[must_use]
    #[doc = "Ensures the shared system font is mapped."]
    pub fn fontEnsureMapped() -> Result;
}
unsafe extern "C" {
    #[doc = "Fixes the pointers internal to a just-loaded font\n # Arguments\n\n* `font` - Font to fix\n > Should never be run on the system font, and only once on any other font."]
    pub fn fontFixPointers(font: *mut CFNT_s);
}
unsafe extern "C" {
    #[doc = "Gets the currently loaded system font"]
    #[link_name = "fontGetSystemFont__extern"]
    pub fn fontGetSystemFont() -> *mut CFNT_s;
}
unsafe extern "C" {
    #[doc = "Retrieves the font information structure of a font.\n # Arguments\n\n* `font` - Pointer to font structure. If NULL, the shared system font is used."]
    #[link_name = "fontGetInfo__extern"]
    pub fn fontGetInfo(font: *mut CFNT_s) -> *mut FINF_s;
}
unsafe extern "C" {
    #[doc = "Retrieves the texture sheet information of a font.\n # Arguments\n\n* `font` - Pointer to font structure. If NULL, the shared system font is used."]
    #[link_name = "fontGetGlyphInfo__extern"]
    pub fn fontGetGlyphInfo(font: *mut CFNT_s) -> *mut TGLP_s;
}
unsafe extern "C" {
    #[doc = "Retrieves the pointer to texture data for the specified texture sheet.\n # Arguments\n\n* `font` - Pointer to font structure. If NULL, the shared system font is used.\n * `sheetIndex` - Index of the texture sheet."]
    #[link_name = "fontGetGlyphSheetTex__extern"]
    pub fn fontGetGlyphSheetTex(
        font: *mut CFNT_s,
        sheetIndex: ::libc::c_int,
    ) -> *mut ::libc::c_void;
}
unsafe extern "C" {
    #[doc = "Retrieves the glyph index of the specified Unicode codepoint.\n # Arguments\n\n* `font` - Pointer to font structure. If NULL, the shared system font is used.\n * `codePoint` - Unicode codepoint."]
    pub fn fontGlyphIndexFromCodePoint(font: *mut CFNT_s, codePoint: u32_) -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Retrieves character width information of the specified glyph.\n # Arguments\n\n* `font` - Pointer to font structure. If NULL, the shared system font is used.\n * `glyphIndex` - Index of the glyph."]
    pub fn fontGetCharWidthInfo(
        font: *mut CFNT_s,
        glyphIndex: ::libc::c_int,
    ) -> *mut charWidthInfo_s;
}
unsafe extern "C" {
    #[doc = "Calculates position information for the specified glyph.\n # Arguments\n\n* `out` - Output structure in which to write the information.\n * `font` - Pointer to font structure. If NULL, the shared system font is used.\n * `glyphIndex` - Index of the glyph.\n * `flags` - Calculation flags (see GLYPH_POS_* flags).\n * `scaleX` - Scale factor to apply horizontally.\n * `scaleY` - Scale factor to apply vertically."]
    pub fn fontCalcGlyphPos(
        out: *mut fontGlyphPos_s,
        font: *mut CFNT_s,
        glyphIndex: ::libc::c_int,
        flags: u32_,
        scaleX: f32,
        scaleY: f32,
    );
}
unsafe extern "C" {
    pub fn gdbHioDevInit() -> ::libc::c_int;
}
unsafe extern "C" {
    pub fn gdbHioDevExit();
}
unsafe extern "C" {
    pub fn gdbHioDevGetStdin() -> ::libc::c_int;
}
unsafe extern "C" {
    pub fn gdbHioDevGetStdout() -> ::libc::c_int;
}
unsafe extern "C" {
    pub fn gdbHioDevGetStderr() -> ::libc::c_int;
}
unsafe extern "C" {
    pub fn gdbHioDevRedirectStdStreams(in_: bool, out: bool, err: bool) -> ::libc::c_int;
}
unsafe extern "C" {
    pub fn gdbHioDevGettimeofday(tv: *mut timeval, tz: *mut ::libc::c_void) -> ::libc::c_int;
}
unsafe extern "C" {
    pub fn gdbHioDevIsatty(fd: ::libc::c_int) -> ::libc::c_int;
}
unsafe extern "C" {
    pub fn gdbHioDevSystem(command: *const ::libc::c_char) -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Address of the host connected through 3dslink"]
    pub static mut __3dslink_host: in_addr;
}
unsafe extern "C" {
    #[doc = "Connects to the 3dslink host, setting up an output stream.\n # Arguments\n\n* `redirStdout` (direction in) - Whether to redirect stdout to nxlink output.\n * `redirStderr` (direction in) - Whether to redirect stderr to nxlink output.\n # Returns\n\nSocket fd on success, negative number on failure.\n > **Note:** The socket should be closed with close() during application cleanup."]
    pub fn link3dsConnectToHost(redirStdout: bool, redirStderr: bool) -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Same as link3dsConnectToHost but redirecting both stdout/stderr."]
    #[link_name = "link3dsStdio__extern"]
    pub fn link3dsStdio() -> ::libc::c_int;
}
unsafe extern "C" {
    #[doc = "Same as link3dsConnectToHost but redirecting only stderr."]
    #[link_name = "link3dsStdioForDebug__extern"]
    pub fn link3dsStdioForDebug() -> ::libc::c_int;
}
unsafe extern "C" {
    pub fn __errno() -> *mut ::libc::c_int;
}
